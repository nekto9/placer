
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model City
 * * Город
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Game
 * 
 */
export type Game = $Result.DefaultSelection<Prisma.$GamePayload>
/**
 * Model GameUser
 * 
 */
export type GameUser = $Result.DefaultSelection<Prisma.$GameUserPayload>
/**
 * Model Place
 * 
 */
export type Place = $Result.DefaultSelection<Prisma.$PlacePayload>
/**
 * Model PlaceFavorite
 * 
 */
export type PlaceFavorite = $Result.DefaultSelection<Prisma.$PlaceFavoritePayload>
/**
 * Model PlaceCovers
 * 
 */
export type PlaceCovers = $Result.DefaultSelection<Prisma.$PlaceCoversPayload>
/**
 * Model PlaceSport
 * 
 */
export type PlaceSport = $Result.DefaultSelection<Prisma.$PlaceSportPayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model TimeSlot
 * 
 */
export type TimeSlot = $Result.DefaultSelection<Prisma.$TimeSlotPayload>
/**
 * Model Sport
 * 
 */
export type Sport = $Result.DefaultSelection<Prisma.$SportPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserFavorite
 * 
 */
export type UserFavorite = $Result.DefaultSelection<Prisma.$UserFavoritePayload>
/**
 * Model UserSport
 * 
 */
export type UserSport = $Result.DefaultSelection<Prisma.$UserSportPayload>
/**
 * Model UserTgLinker
 * 
 */
export type UserTgLinker = $Result.DefaultSelection<Prisma.$UserTgLinkerPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const GameStatus: {
  DRAFT: 'DRAFT',
  APROVED: 'APROVED'
};

export type GameStatus = (typeof GameStatus)[keyof typeof GameStatus]


export const GameUserRole: {
  MEMBER: 'MEMBER',
  CREATOR: 'CREATOR'
};

export type GameUserRole = (typeof GameUserRole)[keyof typeof GameUserRole]


export const GameUserStatus: {
  INVITED: 'INVITED',
  CONFIRMED: 'CONFIRMED',
  REJECTED: 'REJECTED',
  REQUESTED: 'REQUESTED',
  ALLOWED: 'ALLOWED',
  DECLINED: 'DECLINED'
};

export type GameUserStatus = (typeof GameUserStatus)[keyof typeof GameUserStatus]


export const RequestMode: {
  PRIVATE: 'PRIVATE',
  MODERATE: 'MODERATE',
  PUBLIC: 'PUBLIC'
};

export type RequestMode = (typeof RequestMode)[keyof typeof RequestMode]


export const GameLevel: {
  EASY: 'EASY',
  MEDIUM: 'MEDIUM',
  HARD: 'HARD'
};

export type GameLevel = (typeof GameLevel)[keyof typeof GameLevel]


export const GameTimeFrame: {
  UPCOMING: 'UPCOMING',
  PAST: 'PAST',
  ALL: 'ALL'
};

export type GameTimeFrame = (typeof GameTimeFrame)[keyof typeof GameTimeFrame]


export const CalendarRepeatMode: {
  ONCE: 'ONCE',
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  CALENDDAYS: 'CALENDDAYS',
  WEEKDAYS: 'WEEKDAYS'
};

export type CalendarRepeatMode = (typeof CalendarRepeatMode)[keyof typeof CalendarRepeatMode]


export const WorkTimeMode: {
  TIMEGRID: 'TIMEGRID',
  CUSTOM: 'CUSTOM',
  DAILY: 'DAILY',
  NONE: 'NONE'
};

export type WorkTimeMode = (typeof WorkTimeMode)[keyof typeof WorkTimeMode]


export const ScheduleStatus: {
  ACTIVE: 'ACTIVE',
  DISABLED: 'DISABLED'
};

export type ScheduleStatus = (typeof ScheduleStatus)[keyof typeof ScheduleStatus]

}

export type GameStatus = $Enums.GameStatus

export const GameStatus: typeof $Enums.GameStatus

export type GameUserRole = $Enums.GameUserRole

export const GameUserRole: typeof $Enums.GameUserRole

export type GameUserStatus = $Enums.GameUserStatus

export const GameUserStatus: typeof $Enums.GameUserStatus

export type RequestMode = $Enums.RequestMode

export const RequestMode: typeof $Enums.RequestMode

export type GameLevel = $Enums.GameLevel

export const GameLevel: typeof $Enums.GameLevel

export type GameTimeFrame = $Enums.GameTimeFrame

export const GameTimeFrame: typeof $Enums.GameTimeFrame

export type CalendarRepeatMode = $Enums.CalendarRepeatMode

export const CalendarRepeatMode: typeof $Enums.CalendarRepeatMode

export type WorkTimeMode = $Enums.WorkTimeMode

export const WorkTimeMode: typeof $Enums.WorkTimeMode

export type ScheduleStatus = $Enums.ScheduleStatus

export const ScheduleStatus: typeof $Enums.ScheduleStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Cities
 * const cities = await prisma.city.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Cities
   * const cities = await prisma.city.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game`: Exposes CRUD operations for the **Game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Games
    * const games = await prisma.game.findMany()
    * ```
    */
  get game(): Prisma.GameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gameUser`: Exposes CRUD operations for the **GameUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GameUsers
    * const gameUsers = await prisma.gameUser.findMany()
    * ```
    */
  get gameUser(): Prisma.GameUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.place`: Exposes CRUD operations for the **Place** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Places
    * const places = await prisma.place.findMany()
    * ```
    */
  get place(): Prisma.PlaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.placeFavorite`: Exposes CRUD operations for the **PlaceFavorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaceFavorites
    * const placeFavorites = await prisma.placeFavorite.findMany()
    * ```
    */
  get placeFavorite(): Prisma.PlaceFavoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.placeCovers`: Exposes CRUD operations for the **PlaceCovers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaceCovers
    * const placeCovers = await prisma.placeCovers.findMany()
    * ```
    */
  get placeCovers(): Prisma.PlaceCoversDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.placeSport`: Exposes CRUD operations for the **PlaceSport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaceSports
    * const placeSports = await prisma.placeSport.findMany()
    * ```
    */
  get placeSport(): Prisma.PlaceSportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeSlot`: Exposes CRUD operations for the **TimeSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeSlots
    * const timeSlots = await prisma.timeSlot.findMany()
    * ```
    */
  get timeSlot(): Prisma.TimeSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sport`: Exposes CRUD operations for the **Sport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sports
    * const sports = await prisma.sport.findMany()
    * ```
    */
  get sport(): Prisma.SportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFavorite`: Exposes CRUD operations for the **UserFavorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFavorites
    * const userFavorites = await prisma.userFavorite.findMany()
    * ```
    */
  get userFavorite(): Prisma.UserFavoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSport`: Exposes CRUD operations for the **UserSport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSports
    * const userSports = await prisma.userSport.findMany()
    * ```
    */
  get userSport(): Prisma.UserSportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTgLinker`: Exposes CRUD operations for the **UserTgLinker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTgLinkers
    * const userTgLinkers = await prisma.userTgLinker.findMany()
    * ```
    */
  get userTgLinker(): Prisma.UserTgLinkerDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    City: 'City',
    Game: 'Game',
    GameUser: 'GameUser',
    Place: 'Place',
    PlaceFavorite: 'PlaceFavorite',
    PlaceCovers: 'PlaceCovers',
    PlaceSport: 'PlaceSport',
    Schedule: 'Schedule',
    TimeSlot: 'TimeSlot',
    Sport: 'Sport',
    User: 'User',
    UserFavorite: 'UserFavorite',
    UserSport: 'UserSport',
    UserTgLinker: 'UserTgLinker'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "city" | "game" | "gameUser" | "place" | "placeFavorite" | "placeCovers" | "placeSport" | "schedule" | "timeSlot" | "sport" | "user" | "userFavorite" | "userSport" | "userTgLinker"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Game: {
        payload: Prisma.$GamePayload<ExtArgs>
        fields: Prisma.GameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findFirst: {
            args: Prisma.GameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          findMany: {
            args: Prisma.GameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          create: {
            args: Prisma.GameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          createMany: {
            args: Prisma.GameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          delete: {
            args: Prisma.GameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          update: {
            args: Prisma.GameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          deleteMany: {
            args: Prisma.GameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>[]
          }
          upsert: {
            args: Prisma.GameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamePayload>
          }
          aggregate: {
            args: Prisma.GameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame>
          }
          groupBy: {
            args: Prisma.GameGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameCountArgs<ExtArgs>
            result: $Utils.Optional<GameCountAggregateOutputType> | number
          }
        }
      }
      GameUser: {
        payload: Prisma.$GameUserPayload<ExtArgs>
        fields: Prisma.GameUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GameUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GameUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>
          }
          findFirst: {
            args: Prisma.GameUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GameUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>
          }
          findMany: {
            args: Prisma.GameUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>[]
          }
          create: {
            args: Prisma.GameUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>
          }
          createMany: {
            args: Prisma.GameUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GameUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>[]
          }
          delete: {
            args: Prisma.GameUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>
          }
          update: {
            args: Prisma.GameUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>
          }
          deleteMany: {
            args: Prisma.GameUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GameUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GameUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>[]
          }
          upsert: {
            args: Prisma.GameUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GameUserPayload>
          }
          aggregate: {
            args: Prisma.GameUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGameUser>
          }
          groupBy: {
            args: Prisma.GameUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<GameUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.GameUserCountArgs<ExtArgs>
            result: $Utils.Optional<GameUserCountAggregateOutputType> | number
          }
        }
      }
      Place: {
        payload: Prisma.$PlacePayload<ExtArgs>
        fields: Prisma.PlaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          findFirst: {
            args: Prisma.PlaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          findMany: {
            args: Prisma.PlaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>[]
          }
          create: {
            args: Prisma.PlaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          createMany: {
            args: Prisma.PlaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>[]
          }
          delete: {
            args: Prisma.PlaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          update: {
            args: Prisma.PlaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          deleteMany: {
            args: Prisma.PlaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>[]
          }
          upsert: {
            args: Prisma.PlaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          aggregate: {
            args: Prisma.PlaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlace>
          }
          groupBy: {
            args: Prisma.PlaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaceCountArgs<ExtArgs>
            result: $Utils.Optional<PlaceCountAggregateOutputType> | number
          }
        }
      }
      PlaceFavorite: {
        payload: Prisma.$PlaceFavoritePayload<ExtArgs>
        fields: Prisma.PlaceFavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaceFavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceFavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaceFavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceFavoritePayload>
          }
          findFirst: {
            args: Prisma.PlaceFavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceFavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaceFavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceFavoritePayload>
          }
          findMany: {
            args: Prisma.PlaceFavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceFavoritePayload>[]
          }
          create: {
            args: Prisma.PlaceFavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceFavoritePayload>
          }
          createMany: {
            args: Prisma.PlaceFavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaceFavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceFavoritePayload>[]
          }
          delete: {
            args: Prisma.PlaceFavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceFavoritePayload>
          }
          update: {
            args: Prisma.PlaceFavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceFavoritePayload>
          }
          deleteMany: {
            args: Prisma.PlaceFavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaceFavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaceFavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceFavoritePayload>[]
          }
          upsert: {
            args: Prisma.PlaceFavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceFavoritePayload>
          }
          aggregate: {
            args: Prisma.PlaceFavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaceFavorite>
          }
          groupBy: {
            args: Prisma.PlaceFavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaceFavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaceFavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<PlaceFavoriteCountAggregateOutputType> | number
          }
        }
      }
      PlaceCovers: {
        payload: Prisma.$PlaceCoversPayload<ExtArgs>
        fields: Prisma.PlaceCoversFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaceCoversFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceCoversPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaceCoversFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceCoversPayload>
          }
          findFirst: {
            args: Prisma.PlaceCoversFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceCoversPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaceCoversFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceCoversPayload>
          }
          findMany: {
            args: Prisma.PlaceCoversFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceCoversPayload>[]
          }
          create: {
            args: Prisma.PlaceCoversCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceCoversPayload>
          }
          createMany: {
            args: Prisma.PlaceCoversCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaceCoversCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceCoversPayload>[]
          }
          delete: {
            args: Prisma.PlaceCoversDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceCoversPayload>
          }
          update: {
            args: Prisma.PlaceCoversUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceCoversPayload>
          }
          deleteMany: {
            args: Prisma.PlaceCoversDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaceCoversUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaceCoversUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceCoversPayload>[]
          }
          upsert: {
            args: Prisma.PlaceCoversUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceCoversPayload>
          }
          aggregate: {
            args: Prisma.PlaceCoversAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaceCovers>
          }
          groupBy: {
            args: Prisma.PlaceCoversGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaceCoversGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaceCoversCountArgs<ExtArgs>
            result: $Utils.Optional<PlaceCoversCountAggregateOutputType> | number
          }
        }
      }
      PlaceSport: {
        payload: Prisma.$PlaceSportPayload<ExtArgs>
        fields: Prisma.PlaceSportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaceSportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceSportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaceSportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceSportPayload>
          }
          findFirst: {
            args: Prisma.PlaceSportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceSportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaceSportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceSportPayload>
          }
          findMany: {
            args: Prisma.PlaceSportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceSportPayload>[]
          }
          create: {
            args: Prisma.PlaceSportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceSportPayload>
          }
          createMany: {
            args: Prisma.PlaceSportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaceSportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceSportPayload>[]
          }
          delete: {
            args: Prisma.PlaceSportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceSportPayload>
          }
          update: {
            args: Prisma.PlaceSportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceSportPayload>
          }
          deleteMany: {
            args: Prisma.PlaceSportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaceSportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaceSportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceSportPayload>[]
          }
          upsert: {
            args: Prisma.PlaceSportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceSportPayload>
          }
          aggregate: {
            args: Prisma.PlaceSportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaceSport>
          }
          groupBy: {
            args: Prisma.PlaceSportGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaceSportGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaceSportCountArgs<ExtArgs>
            result: $Utils.Optional<PlaceSportCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      TimeSlot: {
        payload: Prisma.$TimeSlotPayload<ExtArgs>
        fields: Prisma.TimeSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          findFirst: {
            args: Prisma.TimeSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          findMany: {
            args: Prisma.TimeSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
          }
          create: {
            args: Prisma.TimeSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          createMany: {
            args: Prisma.TimeSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeSlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
          }
          delete: {
            args: Prisma.TimeSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          update: {
            args: Prisma.TimeSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          deleteMany: {
            args: Prisma.TimeSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimeSlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>[]
          }
          upsert: {
            args: Prisma.TimeSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotPayload>
          }
          aggregate: {
            args: Prisma.TimeSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeSlot>
          }
          groupBy: {
            args: Prisma.TimeSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeSlotCountArgs<ExtArgs>
            result: $Utils.Optional<TimeSlotCountAggregateOutputType> | number
          }
        }
      }
      Sport: {
        payload: Prisma.$SportPayload<ExtArgs>
        fields: Prisma.SportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          findFirst: {
            args: Prisma.SportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          findMany: {
            args: Prisma.SportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>[]
          }
          create: {
            args: Prisma.SportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          createMany: {
            args: Prisma.SportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>[]
          }
          delete: {
            args: Prisma.SportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          update: {
            args: Prisma.SportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          deleteMany: {
            args: Prisma.SportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>[]
          }
          upsert: {
            args: Prisma.SportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SportPayload>
          }
          aggregate: {
            args: Prisma.SportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSport>
          }
          groupBy: {
            args: Prisma.SportGroupByArgs<ExtArgs>
            result: $Utils.Optional<SportGroupByOutputType>[]
          }
          count: {
            args: Prisma.SportCountArgs<ExtArgs>
            result: $Utils.Optional<SportCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserFavorite: {
        payload: Prisma.$UserFavoritePayload<ExtArgs>
        fields: Prisma.UserFavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          findFirst: {
            args: Prisma.UserFavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          findMany: {
            args: Prisma.UserFavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          create: {
            args: Prisma.UserFavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          createMany: {
            args: Prisma.UserFavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          delete: {
            args: Prisma.UserFavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          update: {
            args: Prisma.UserFavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          deleteMany: {
            args: Prisma.UserFavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserFavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>[]
          }
          upsert: {
            args: Prisma.UserFavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavoritePayload>
          }
          aggregate: {
            args: Prisma.UserFavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFavorite>
          }
          groupBy: {
            args: Prisma.UserFavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<UserFavoriteCountAggregateOutputType> | number
          }
        }
      }
      UserSport: {
        payload: Prisma.$UserSportPayload<ExtArgs>
        fields: Prisma.UserSportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSportPayload>
          }
          findFirst: {
            args: Prisma.UserSportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSportPayload>
          }
          findMany: {
            args: Prisma.UserSportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSportPayload>[]
          }
          create: {
            args: Prisma.UserSportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSportPayload>
          }
          createMany: {
            args: Prisma.UserSportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSportPayload>[]
          }
          delete: {
            args: Prisma.UserSportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSportPayload>
          }
          update: {
            args: Prisma.UserSportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSportPayload>
          }
          deleteMany: {
            args: Prisma.UserSportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSportPayload>[]
          }
          upsert: {
            args: Prisma.UserSportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSportPayload>
          }
          aggregate: {
            args: Prisma.UserSportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSport>
          }
          groupBy: {
            args: Prisma.UserSportGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSportGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSportCountArgs<ExtArgs>
            result: $Utils.Optional<UserSportCountAggregateOutputType> | number
          }
        }
      }
      UserTgLinker: {
        payload: Prisma.$UserTgLinkerPayload<ExtArgs>
        fields: Prisma.UserTgLinkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTgLinkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTgLinkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTgLinkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTgLinkerPayload>
          }
          findFirst: {
            args: Prisma.UserTgLinkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTgLinkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTgLinkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTgLinkerPayload>
          }
          findMany: {
            args: Prisma.UserTgLinkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTgLinkerPayload>[]
          }
          create: {
            args: Prisma.UserTgLinkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTgLinkerPayload>
          }
          createMany: {
            args: Prisma.UserTgLinkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTgLinkerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTgLinkerPayload>[]
          }
          delete: {
            args: Prisma.UserTgLinkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTgLinkerPayload>
          }
          update: {
            args: Prisma.UserTgLinkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTgLinkerPayload>
          }
          deleteMany: {
            args: Prisma.UserTgLinkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTgLinkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserTgLinkerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTgLinkerPayload>[]
          }
          upsert: {
            args: Prisma.UserTgLinkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTgLinkerPayload>
          }
          aggregate: {
            args: Prisma.UserTgLinkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTgLinker>
          }
          groupBy: {
            args: Prisma.UserTgLinkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTgLinkerGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTgLinkerCountArgs<ExtArgs>
            result: $Utils.Optional<UserTgLinkerCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    city?: CityOmit
    game?: GameOmit
    gameUser?: GameUserOmit
    place?: PlaceOmit
    placeFavorite?: PlaceFavoriteOmit
    placeCovers?: PlaceCoversOmit
    placeSport?: PlaceSportOmit
    schedule?: ScheduleOmit
    timeSlot?: TimeSlotOmit
    sport?: SportOmit
    user?: UserOmit
    userFavorite?: UserFavoriteOmit
    userSport?: UserSportOmit
    userTgLinker?: UserTgLinkerOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    places: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    places?: boolean | CityCountOutputTypeCountPlacesArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountPlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceWhereInput
  }


  /**
   * Count Type GameCountOutputType
   */

  export type GameCountOutputType = {
    users: number
  }

  export type GameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | GameCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameCountOutputType
     */
    select?: GameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GameCountOutputType without action
   */
  export type GameCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameUserWhereInput
  }


  /**
   * Count Type PlaceCountOutputType
   */

  export type PlaceCountOutputType = {
    schedules: number
    games: number
    covers: number
    sports: number
    favoritedUsers: number
  }

  export type PlaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedules?: boolean | PlaceCountOutputTypeCountSchedulesArgs
    games?: boolean | PlaceCountOutputTypeCountGamesArgs
    covers?: boolean | PlaceCountOutputTypeCountCoversArgs
    sports?: boolean | PlaceCountOutputTypeCountSportsArgs
    favoritedUsers?: boolean | PlaceCountOutputTypeCountFavoritedUsersArgs
  }

  // Custom InputTypes
  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCountOutputType
     */
    select?: PlaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }

  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeCountCoversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceCoversWhereInput
  }

  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeCountSportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceSportWhereInput
  }

  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeCountFavoritedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceFavoriteWhereInput
  }


  /**
   * Count Type ScheduleCountOutputType
   */

  export type ScheduleCountOutputType = {
    timeSlots: number
  }

  export type ScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timeSlots?: boolean | ScheduleCountOutputTypeCountTimeSlotsArgs
  }

  // Custom InputTypes
  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleCountOutputType
     */
    select?: ScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeCountTimeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSlotWhereInput
  }


  /**
   * Count Type SportCountOutputType
   */

  export type SportCountOutputType = {
    places: number
    games: number
    users: number
  }

  export type SportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    places?: boolean | SportCountOutputTypeCountPlacesArgs
    games?: boolean | SportCountOutputTypeCountGamesArgs
    users?: boolean | SportCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * SportCountOutputType without action
   */
  export type SportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SportCountOutputType
     */
    select?: SportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SportCountOutputType without action
   */
  export type SportCountOutputTypeCountPlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceSportWhereInput
  }

  /**
   * SportCountOutputType without action
   */
  export type SportCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
  }

  /**
   * SportCountOutputType without action
   */
  export type SportCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSportWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    games: number
    places: number
    favoritePlaces: number
    sports: number
    favorites: number
    favoritedBy: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | UserCountOutputTypeCountGamesArgs
    places?: boolean | UserCountOutputTypeCountPlacesArgs
    favoritePlaces?: boolean | UserCountOutputTypeCountFavoritePlacesArgs
    sports?: boolean | UserCountOutputTypeCountSportsArgs
    favorites?: boolean | UserCountOutputTypeCountFavoritesArgs
    favoritedBy?: boolean | UserCountOutputTypeCountFavoritedByArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritePlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceFavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
  }


  /**
   * Models
   */

  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    region: number | null
  }

  export type CitySumAggregateOutputType = {
    region: number | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    region: number | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    region: number | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    region: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    region?: true
  }

  export type CitySumAggregateInputType = {
    region?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    region?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    region?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    region?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    region: number
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    region?: boolean
    places?: boolean | City$placesArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    region?: boolean
  }, ExtArgs["result"]["city"]>

  export type CitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    region?: boolean
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    region?: boolean
  }

  export type CityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "region", ExtArgs["result"]["city"]>
  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    places?: boolean | City$placesArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      places: Prisma.$PlacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      region: number
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {CityCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CityCreateManyAndReturnArgs>(args?: SelectSubset<T, CityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities and returns the data updated in the database.
     * @param {CityUpdateManyAndReturnArgs} args - Arguments to update many Cities.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cities and only return the `id`
     * const cityWithIdOnly = await prisma.city.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CityUpdateManyAndReturnArgs>(args: SelectSubset<T, CityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    places<T extends City$placesArgs<ExtArgs> = {}>(args?: Subset<T, City$placesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly createdAt: FieldRef<"City", 'DateTime'>
    readonly updatedAt: FieldRef<"City", 'DateTime'>
    readonly name: FieldRef<"City", 'String'>
    readonly region: FieldRef<"City", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City createManyAndReturn
   */
  export type CityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
  }

  /**
   * City updateManyAndReturn
   */
  export type CityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to delete.
     */
    limit?: number
  }

  /**
   * City.places
   */
  export type City$placesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    where?: PlaceWhereInput
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    cursor?: PlaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model Game
   */

  export type AggregateGame = {
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  export type GameAvgAggregateOutputType = {
    timeStart: number | null
    timeEnd: number | null
    countMembersMin: number | null
    countMembersMax: number | null
  }

  export type GameSumAggregateOutputType = {
    timeStart: number | null
    timeEnd: number | null
    countMembersMin: number | null
    countMembersMax: number | null
  }

  export type GameMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    timeStart: number | null
    timeEnd: number | null
    date: Date | null
    status: $Enums.GameStatus | null
    level: $Enums.GameLevel | null
    countMembersMin: number | null
    countMembersMax: number | null
    description: string | null
    requestMode: $Enums.RequestMode | null
    placeId: string | null
    sportId: string | null
  }

  export type GameMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    timeStart: number | null
    timeEnd: number | null
    date: Date | null
    status: $Enums.GameStatus | null
    level: $Enums.GameLevel | null
    countMembersMin: number | null
    countMembersMax: number | null
    description: string | null
    requestMode: $Enums.RequestMode | null
    placeId: string | null
    sportId: string | null
  }

  export type GameCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    timeStart: number
    timeEnd: number
    date: number
    status: number
    level: number
    countMembersMin: number
    countMembersMax: number
    description: number
    requestMode: number
    placeId: number
    sportId: number
    _all: number
  }


  export type GameAvgAggregateInputType = {
    timeStart?: true
    timeEnd?: true
    countMembersMin?: true
    countMembersMax?: true
  }

  export type GameSumAggregateInputType = {
    timeStart?: true
    timeEnd?: true
    countMembersMin?: true
    countMembersMax?: true
  }

  export type GameMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    timeStart?: true
    timeEnd?: true
    date?: true
    status?: true
    level?: true
    countMembersMin?: true
    countMembersMax?: true
    description?: true
    requestMode?: true
    placeId?: true
    sportId?: true
  }

  export type GameMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    timeStart?: true
    timeEnd?: true
    date?: true
    status?: true
    level?: true
    countMembersMin?: true
    countMembersMax?: true
    description?: true
    requestMode?: true
    placeId?: true
    sportId?: true
  }

  export type GameCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    timeStart?: true
    timeEnd?: true
    date?: true
    status?: true
    level?: true
    countMembersMin?: true
    countMembersMax?: true
    description?: true
    requestMode?: true
    placeId?: true
    sportId?: true
    _all?: true
  }

  export type GameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Game to aggregate.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Games
    **/
    _count?: true | GameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameMaxAggregateInputType
  }

  export type GetGameAggregateType<T extends GameAggregateArgs> = {
        [P in keyof T & keyof AggregateGame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame[P]>
      : GetScalarType<T[P], AggregateGame[P]>
  }




  export type GameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameWhereInput
    orderBy?: GameOrderByWithAggregationInput | GameOrderByWithAggregationInput[]
    by: GameScalarFieldEnum[] | GameScalarFieldEnum
    having?: GameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameCountAggregateInputType | true
    _avg?: GameAvgAggregateInputType
    _sum?: GameSumAggregateInputType
    _min?: GameMinAggregateInputType
    _max?: GameMaxAggregateInputType
  }

  export type GameGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    timeStart: number
    timeEnd: number
    date: Date
    status: $Enums.GameStatus
    level: $Enums.GameLevel
    countMembersMin: number
    countMembersMax: number
    description: string | null
    requestMode: $Enums.RequestMode
    placeId: string
    sportId: string | null
    _count: GameCountAggregateOutputType | null
    _avg: GameAvgAggregateOutputType | null
    _sum: GameSumAggregateOutputType | null
    _min: GameMinAggregateOutputType | null
    _max: GameMaxAggregateOutputType | null
  }

  type GetGameGroupByPayload<T extends GameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameGroupByOutputType[P]>
            : GetScalarType<T[P], GameGroupByOutputType[P]>
        }
      >
    >


  export type GameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timeStart?: boolean
    timeEnd?: boolean
    date?: boolean
    status?: boolean
    level?: boolean
    countMembersMin?: boolean
    countMembersMax?: boolean
    description?: boolean
    requestMode?: boolean
    placeId?: boolean
    sportId?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    users?: boolean | Game$usersArgs<ExtArgs>
    sport?: boolean | Game$sportArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timeStart?: boolean
    timeEnd?: boolean
    date?: boolean
    status?: boolean
    level?: boolean
    countMembersMin?: boolean
    countMembersMax?: boolean
    description?: boolean
    requestMode?: boolean
    placeId?: boolean
    sportId?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    sport?: boolean | Game$sportArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timeStart?: boolean
    timeEnd?: boolean
    date?: boolean
    status?: boolean
    level?: boolean
    countMembersMin?: boolean
    countMembersMax?: boolean
    description?: boolean
    requestMode?: boolean
    placeId?: boolean
    sportId?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    sport?: boolean | Game$sportArgs<ExtArgs>
  }, ExtArgs["result"]["game"]>

  export type GameSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timeStart?: boolean
    timeEnd?: boolean
    date?: boolean
    status?: boolean
    level?: boolean
    countMembersMin?: boolean
    countMembersMax?: boolean
    description?: boolean
    requestMode?: boolean
    placeId?: boolean
    sportId?: boolean
  }

  export type GameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "timeStart" | "timeEnd" | "date" | "status" | "level" | "countMembersMin" | "countMembersMax" | "description" | "requestMode" | "placeId" | "sportId", ExtArgs["result"]["game"]>
  export type GameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    users?: boolean | Game$usersArgs<ExtArgs>
    sport?: boolean | Game$sportArgs<ExtArgs>
    _count?: boolean | GameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    sport?: boolean | Game$sportArgs<ExtArgs>
  }
  export type GameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    sport?: boolean | Game$sportArgs<ExtArgs>
  }

  export type $GamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Game"
    objects: {
      place: Prisma.$PlacePayload<ExtArgs>
      users: Prisma.$GameUserPayload<ExtArgs>[]
      /**
       * * Вид спорта для этой игры
       */
      sport: Prisma.$SportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      /**
       * * Время начала слота в минутах с 00:00
       */
      timeStart: number
      /**
       * * Время окончания слота в минутах с 00:00
       */
      timeEnd: number
      /**
       * * Дата игры
       */
      date: Date
      /**
       * * Статус игры
       */
      status: $Enums.GameStatus
      /**
       * * Уровень сложности игры
       */
      level: $Enums.GameLevel
      /**
       * * Минимальное число участников
       */
      countMembersMin: number
      /**
       * * Максимальное число участников
       */
      countMembersMax: number
      /**
       * * Коментарии к игре
       */
      description: string | null
      /**
       * * Режим принятия запросов на участие
       */
      requestMode: $Enums.RequestMode
      placeId: string
      sportId: string | null
    }, ExtArgs["result"]["game"]>
    composites: {}
  }

  type GameGetPayload<S extends boolean | null | undefined | GameDefaultArgs> = $Result.GetResult<Prisma.$GamePayload, S>

  type GameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameCountAggregateInputType | true
    }

  export interface GameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Game'], meta: { name: 'Game' } }
    /**
     * Find zero or one Game that matches the filter.
     * @param {GameFindUniqueArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameFindUniqueArgs>(args: SelectSubset<T, GameFindUniqueArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameFindUniqueOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameFindUniqueOrThrowArgs>(args: SelectSubset<T, GameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameFindFirstArgs>(args?: SelectSubset<T, GameFindFirstArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindFirstOrThrowArgs} args - Arguments to find a Game
     * @example
     * // Get one Game
     * const game = await prisma.game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameFindFirstOrThrowArgs>(args?: SelectSubset<T, GameFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Games
     * const games = await prisma.game.findMany()
     * 
     * // Get first 10 Games
     * const games = await prisma.game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gameWithIdOnly = await prisma.game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GameFindManyArgs>(args?: SelectSubset<T, GameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game.
     * @param {GameCreateArgs} args - Arguments to create a Game.
     * @example
     * // Create one Game
     * const Game = await prisma.game.create({
     *   data: {
     *     // ... data to create a Game
     *   }
     * })
     * 
     */
    create<T extends GameCreateArgs>(args: SelectSubset<T, GameCreateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Games.
     * @param {GameCreateManyArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameCreateManyArgs>(args?: SelectSubset<T, GameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Games and returns the data saved in the database.
     * @param {GameCreateManyAndReturnArgs} args - Arguments to create many Games.
     * @example
     * // Create many Games
     * const game = await prisma.game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameCreateManyAndReturnArgs>(args?: SelectSubset<T, GameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Game.
     * @param {GameDeleteArgs} args - Arguments to delete one Game.
     * @example
     * // Delete one Game
     * const Game = await prisma.game.delete({
     *   where: {
     *     // ... filter to delete one Game
     *   }
     * })
     * 
     */
    delete<T extends GameDeleteArgs>(args: SelectSubset<T, GameDeleteArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game.
     * @param {GameUpdateArgs} args - Arguments to update one Game.
     * @example
     * // Update one Game
     * const game = await prisma.game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUpdateArgs>(args: SelectSubset<T, GameUpdateArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Games.
     * @param {GameDeleteManyArgs} args - Arguments to filter Games to delete.
     * @example
     * // Delete a few Games
     * const { count } = await prisma.game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameDeleteManyArgs>(args?: SelectSubset<T, GameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUpdateManyArgs>(args: SelectSubset<T, GameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Games and returns the data updated in the database.
     * @param {GameUpdateManyAndReturnArgs} args - Arguments to update many Games.
     * @example
     * // Update many Games
     * const game = await prisma.game.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Games and only return the `id`
     * const gameWithIdOnly = await prisma.game.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameUpdateManyAndReturnArgs>(args: SelectSubset<T, GameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Game.
     * @param {GameUpsertArgs} args - Arguments to update or create a Game.
     * @example
     * // Update or create a Game
     * const game = await prisma.game.upsert({
     *   create: {
     *     // ... data to create a Game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game we want to update
     *   }
     * })
     */
    upsert<T extends GameUpsertArgs>(args: SelectSubset<T, GameUpsertArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameCountArgs} args - Arguments to filter Games to count.
     * @example
     * // Count the number of Games
     * const count = await prisma.game.count({
     *   where: {
     *     // ... the filter for the Games we want to count
     *   }
     * })
    **/
    count<T extends GameCountArgs>(
      args?: Subset<T, GameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameAggregateArgs>(args: Subset<T, GameAggregateArgs>): Prisma.PrismaPromise<GetGameAggregateType<T>>

    /**
     * Group by Game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameGroupByArgs['orderBy'] }
        : { orderBy?: GameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Game model
   */
  readonly fields: GameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    place<T extends PlaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceDefaultArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends Game$usersArgs<ExtArgs> = {}>(args?: Subset<T, Game$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sport<T extends Game$sportArgs<ExtArgs> = {}>(args?: Subset<T, Game$sportArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Game model
   */
  interface GameFieldRefs {
    readonly id: FieldRef<"Game", 'String'>
    readonly createdAt: FieldRef<"Game", 'DateTime'>
    readonly updatedAt: FieldRef<"Game", 'DateTime'>
    readonly timeStart: FieldRef<"Game", 'Int'>
    readonly timeEnd: FieldRef<"Game", 'Int'>
    readonly date: FieldRef<"Game", 'DateTime'>
    readonly status: FieldRef<"Game", 'GameStatus'>
    readonly level: FieldRef<"Game", 'GameLevel'>
    readonly countMembersMin: FieldRef<"Game", 'Int'>
    readonly countMembersMax: FieldRef<"Game", 'Int'>
    readonly description: FieldRef<"Game", 'String'>
    readonly requestMode: FieldRef<"Game", 'RequestMode'>
    readonly placeId: FieldRef<"Game", 'String'>
    readonly sportId: FieldRef<"Game", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Game findUnique
   */
  export type GameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findUniqueOrThrow
   */
  export type GameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game findFirst
   */
  export type GameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findFirstOrThrow
   */
  export type GameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Game to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Games.
     */
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game findMany
   */
  export type GameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter, which Games to fetch.
     */
    where?: GameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Games to fetch.
     */
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Games.
     */
    cursor?: GameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Games.
     */
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Game create
   */
  export type GameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to create a Game.
     */
    data: XOR<GameCreateInput, GameUncheckedCreateInput>
  }

  /**
   * Game createMany
   */
  export type GameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Game createManyAndReturn
   */
  export type GameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to create many Games.
     */
    data: GameCreateManyInput | GameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game update
   */
  export type GameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The data needed to update a Game.
     */
    data: XOR<GameUpdateInput, GameUncheckedUpdateInput>
    /**
     * Choose, which Game to update.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game updateMany
   */
  export type GameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
  }

  /**
   * Game updateManyAndReturn
   */
  export type GameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * The data used to update Games.
     */
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyInput>
    /**
     * Filter which Games to update
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Game upsert
   */
  export type GameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * The filter to search for the Game to update in case it exists.
     */
    where: GameWhereUniqueInput
    /**
     * In case the Game found by the `where` argument doesn't exist, create a new Game with this data.
     */
    create: XOR<GameCreateInput, GameUncheckedCreateInput>
    /**
     * In case the Game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUpdateInput, GameUncheckedUpdateInput>
  }

  /**
   * Game delete
   */
  export type GameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    /**
     * Filter which Game to delete.
     */
    where: GameWhereUniqueInput
  }

  /**
   * Game deleteMany
   */
  export type GameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Games to delete
     */
    where?: GameWhereInput
    /**
     * Limit how many Games to delete.
     */
    limit?: number
  }

  /**
   * Game.users
   */
  export type Game$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    where?: GameUserWhereInput
    orderBy?: GameUserOrderByWithRelationInput | GameUserOrderByWithRelationInput[]
    cursor?: GameUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameUserScalarFieldEnum | GameUserScalarFieldEnum[]
  }

  /**
   * Game.sport
   */
  export type Game$sportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    where?: SportWhereInput
  }

  /**
   * Game without action
   */
  export type GameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
  }


  /**
   * Model GameUser
   */

  export type AggregateGameUser = {
    _count: GameUserCountAggregateOutputType | null
    _min: GameUserMinAggregateOutputType | null
    _max: GameUserMaxAggregateOutputType | null
  }

  export type GameUserMinAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    gameId: string | null
    userId: string | null
    role: $Enums.GameUserRole | null
    status: $Enums.GameUserStatus | null
  }

  export type GameUserMaxAggregateOutputType = {
    createdAt: Date | null
    updatedAt: Date | null
    gameId: string | null
    userId: string | null
    role: $Enums.GameUserRole | null
    status: $Enums.GameUserStatus | null
  }

  export type GameUserCountAggregateOutputType = {
    createdAt: number
    updatedAt: number
    gameId: number
    userId: number
    role: number
    status: number
    _all: number
  }


  export type GameUserMinAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    gameId?: true
    userId?: true
    role?: true
    status?: true
  }

  export type GameUserMaxAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    gameId?: true
    userId?: true
    role?: true
    status?: true
  }

  export type GameUserCountAggregateInputType = {
    createdAt?: true
    updatedAt?: true
    gameId?: true
    userId?: true
    role?: true
    status?: true
    _all?: true
  }

  export type GameUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameUser to aggregate.
     */
    where?: GameUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameUsers to fetch.
     */
    orderBy?: GameUserOrderByWithRelationInput | GameUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GameUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GameUsers
    **/
    _count?: true | GameUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GameUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GameUserMaxAggregateInputType
  }

  export type GetGameUserAggregateType<T extends GameUserAggregateArgs> = {
        [P in keyof T & keyof AggregateGameUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGameUser[P]>
      : GetScalarType<T[P], AggregateGameUser[P]>
  }




  export type GameUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GameUserWhereInput
    orderBy?: GameUserOrderByWithAggregationInput | GameUserOrderByWithAggregationInput[]
    by: GameUserScalarFieldEnum[] | GameUserScalarFieldEnum
    having?: GameUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GameUserCountAggregateInputType | true
    _min?: GameUserMinAggregateInputType
    _max?: GameUserMaxAggregateInputType
  }

  export type GameUserGroupByOutputType = {
    createdAt: Date
    updatedAt: Date
    gameId: string
    userId: string
    role: $Enums.GameUserRole
    status: $Enums.GameUserStatus
    _count: GameUserCountAggregateOutputType | null
    _min: GameUserMinAggregateOutputType | null
    _max: GameUserMaxAggregateOutputType | null
  }

  type GetGameUserGroupByPayload<T extends GameUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GameUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GameUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GameUserGroupByOutputType[P]>
            : GetScalarType<T[P], GameUserGroupByOutputType[P]>
        }
      >
    >


  export type GameUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    gameId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameUser"]>

  export type GameUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    gameId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameUser"]>

  export type GameUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    updatedAt?: boolean
    gameId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gameUser"]>

  export type GameUserSelectScalar = {
    createdAt?: boolean
    updatedAt?: boolean
    gameId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
  }

  export type GameUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "updatedAt" | "gameId" | "userId" | "role" | "status", ExtArgs["result"]["gameUser"]>
  export type GameUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GameUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GameUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game?: boolean | GameDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GameUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GameUser"
    objects: {
      game: Prisma.$GamePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      updatedAt: Date
      gameId: string
      userId: string
      role: $Enums.GameUserRole
      status: $Enums.GameUserStatus
    }, ExtArgs["result"]["gameUser"]>
    composites: {}
  }

  type GameUserGetPayload<S extends boolean | null | undefined | GameUserDefaultArgs> = $Result.GetResult<Prisma.$GameUserPayload, S>

  type GameUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GameUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GameUserCountAggregateInputType | true
    }

  export interface GameUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GameUser'], meta: { name: 'GameUser' } }
    /**
     * Find zero or one GameUser that matches the filter.
     * @param {GameUserFindUniqueArgs} args - Arguments to find a GameUser
     * @example
     * // Get one GameUser
     * const gameUser = await prisma.gameUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GameUserFindUniqueArgs>(args: SelectSubset<T, GameUserFindUniqueArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GameUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GameUserFindUniqueOrThrowArgs} args - Arguments to find a GameUser
     * @example
     * // Get one GameUser
     * const gameUser = await prisma.gameUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GameUserFindUniqueOrThrowArgs>(args: SelectSubset<T, GameUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUserFindFirstArgs} args - Arguments to find a GameUser
     * @example
     * // Get one GameUser
     * const gameUser = await prisma.gameUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GameUserFindFirstArgs>(args?: SelectSubset<T, GameUserFindFirstArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GameUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUserFindFirstOrThrowArgs} args - Arguments to find a GameUser
     * @example
     * // Get one GameUser
     * const gameUser = await prisma.gameUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GameUserFindFirstOrThrowArgs>(args?: SelectSubset<T, GameUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GameUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GameUsers
     * const gameUsers = await prisma.gameUser.findMany()
     * 
     * // Get first 10 GameUsers
     * const gameUsers = await prisma.gameUser.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const gameUserWithCreatedAtOnly = await prisma.gameUser.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends GameUserFindManyArgs>(args?: SelectSubset<T, GameUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GameUser.
     * @param {GameUserCreateArgs} args - Arguments to create a GameUser.
     * @example
     * // Create one GameUser
     * const GameUser = await prisma.gameUser.create({
     *   data: {
     *     // ... data to create a GameUser
     *   }
     * })
     * 
     */
    create<T extends GameUserCreateArgs>(args: SelectSubset<T, GameUserCreateArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GameUsers.
     * @param {GameUserCreateManyArgs} args - Arguments to create many GameUsers.
     * @example
     * // Create many GameUsers
     * const gameUser = await prisma.gameUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GameUserCreateManyArgs>(args?: SelectSubset<T, GameUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GameUsers and returns the data saved in the database.
     * @param {GameUserCreateManyAndReturnArgs} args - Arguments to create many GameUsers.
     * @example
     * // Create many GameUsers
     * const gameUser = await prisma.gameUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GameUsers and only return the `createdAt`
     * const gameUserWithCreatedAtOnly = await prisma.gameUser.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GameUserCreateManyAndReturnArgs>(args?: SelectSubset<T, GameUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GameUser.
     * @param {GameUserDeleteArgs} args - Arguments to delete one GameUser.
     * @example
     * // Delete one GameUser
     * const GameUser = await prisma.gameUser.delete({
     *   where: {
     *     // ... filter to delete one GameUser
     *   }
     * })
     * 
     */
    delete<T extends GameUserDeleteArgs>(args: SelectSubset<T, GameUserDeleteArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GameUser.
     * @param {GameUserUpdateArgs} args - Arguments to update one GameUser.
     * @example
     * // Update one GameUser
     * const gameUser = await prisma.gameUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GameUserUpdateArgs>(args: SelectSubset<T, GameUserUpdateArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GameUsers.
     * @param {GameUserDeleteManyArgs} args - Arguments to filter GameUsers to delete.
     * @example
     * // Delete a few GameUsers
     * const { count } = await prisma.gameUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GameUserDeleteManyArgs>(args?: SelectSubset<T, GameUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GameUsers
     * const gameUser = await prisma.gameUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GameUserUpdateManyArgs>(args: SelectSubset<T, GameUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GameUsers and returns the data updated in the database.
     * @param {GameUserUpdateManyAndReturnArgs} args - Arguments to update many GameUsers.
     * @example
     * // Update many GameUsers
     * const gameUser = await prisma.gameUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GameUsers and only return the `createdAt`
     * const gameUserWithCreatedAtOnly = await prisma.gameUser.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GameUserUpdateManyAndReturnArgs>(args: SelectSubset<T, GameUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GameUser.
     * @param {GameUserUpsertArgs} args - Arguments to update or create a GameUser.
     * @example
     * // Update or create a GameUser
     * const gameUser = await prisma.gameUser.upsert({
     *   create: {
     *     // ... data to create a GameUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GameUser we want to update
     *   }
     * })
     */
    upsert<T extends GameUserUpsertArgs>(args: SelectSubset<T, GameUserUpsertArgs<ExtArgs>>): Prisma__GameUserClient<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GameUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUserCountArgs} args - Arguments to filter GameUsers to count.
     * @example
     * // Count the number of GameUsers
     * const count = await prisma.gameUser.count({
     *   where: {
     *     // ... the filter for the GameUsers we want to count
     *   }
     * })
    **/
    count<T extends GameUserCountArgs>(
      args?: Subset<T, GameUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GameUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GameUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GameUserAggregateArgs>(args: Subset<T, GameUserAggregateArgs>): Prisma.PrismaPromise<GetGameUserAggregateType<T>>

    /**
     * Group by GameUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GameUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GameUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GameUserGroupByArgs['orderBy'] }
        : { orderBy?: GameUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GameUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGameUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GameUser model
   */
  readonly fields: GameUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GameUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GameUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    game<T extends GameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GameDefaultArgs<ExtArgs>>): Prisma__GameClient<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GameUser model
   */
  interface GameUserFieldRefs {
    readonly createdAt: FieldRef<"GameUser", 'DateTime'>
    readonly updatedAt: FieldRef<"GameUser", 'DateTime'>
    readonly gameId: FieldRef<"GameUser", 'String'>
    readonly userId: FieldRef<"GameUser", 'String'>
    readonly role: FieldRef<"GameUser", 'GameUserRole'>
    readonly status: FieldRef<"GameUser", 'GameUserStatus'>
  }
    

  // Custom InputTypes
  /**
   * GameUser findUnique
   */
  export type GameUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * Filter, which GameUser to fetch.
     */
    where: GameUserWhereUniqueInput
  }

  /**
   * GameUser findUniqueOrThrow
   */
  export type GameUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * Filter, which GameUser to fetch.
     */
    where: GameUserWhereUniqueInput
  }

  /**
   * GameUser findFirst
   */
  export type GameUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * Filter, which GameUser to fetch.
     */
    where?: GameUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameUsers to fetch.
     */
    orderBy?: GameUserOrderByWithRelationInput | GameUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameUsers.
     */
    cursor?: GameUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameUsers.
     */
    distinct?: GameUserScalarFieldEnum | GameUserScalarFieldEnum[]
  }

  /**
   * GameUser findFirstOrThrow
   */
  export type GameUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * Filter, which GameUser to fetch.
     */
    where?: GameUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameUsers to fetch.
     */
    orderBy?: GameUserOrderByWithRelationInput | GameUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GameUsers.
     */
    cursor?: GameUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GameUsers.
     */
    distinct?: GameUserScalarFieldEnum | GameUserScalarFieldEnum[]
  }

  /**
   * GameUser findMany
   */
  export type GameUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * Filter, which GameUsers to fetch.
     */
    where?: GameUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GameUsers to fetch.
     */
    orderBy?: GameUserOrderByWithRelationInput | GameUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GameUsers.
     */
    cursor?: GameUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GameUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GameUsers.
     */
    skip?: number
    distinct?: GameUserScalarFieldEnum | GameUserScalarFieldEnum[]
  }

  /**
   * GameUser create
   */
  export type GameUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * The data needed to create a GameUser.
     */
    data: XOR<GameUserCreateInput, GameUserUncheckedCreateInput>
  }

  /**
   * GameUser createMany
   */
  export type GameUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GameUsers.
     */
    data: GameUserCreateManyInput | GameUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GameUser createManyAndReturn
   */
  export type GameUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * The data used to create many GameUsers.
     */
    data: GameUserCreateManyInput | GameUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameUser update
   */
  export type GameUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * The data needed to update a GameUser.
     */
    data: XOR<GameUserUpdateInput, GameUserUncheckedUpdateInput>
    /**
     * Choose, which GameUser to update.
     */
    where: GameUserWhereUniqueInput
  }

  /**
   * GameUser updateMany
   */
  export type GameUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GameUsers.
     */
    data: XOR<GameUserUpdateManyMutationInput, GameUserUncheckedUpdateManyInput>
    /**
     * Filter which GameUsers to update
     */
    where?: GameUserWhereInput
    /**
     * Limit how many GameUsers to update.
     */
    limit?: number
  }

  /**
   * GameUser updateManyAndReturn
   */
  export type GameUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * The data used to update GameUsers.
     */
    data: XOR<GameUserUpdateManyMutationInput, GameUserUncheckedUpdateManyInput>
    /**
     * Filter which GameUsers to update
     */
    where?: GameUserWhereInput
    /**
     * Limit how many GameUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GameUser upsert
   */
  export type GameUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * The filter to search for the GameUser to update in case it exists.
     */
    where: GameUserWhereUniqueInput
    /**
     * In case the GameUser found by the `where` argument doesn't exist, create a new GameUser with this data.
     */
    create: XOR<GameUserCreateInput, GameUserUncheckedCreateInput>
    /**
     * In case the GameUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GameUserUpdateInput, GameUserUncheckedUpdateInput>
  }

  /**
   * GameUser delete
   */
  export type GameUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    /**
     * Filter which GameUser to delete.
     */
    where: GameUserWhereUniqueInput
  }

  /**
   * GameUser deleteMany
   */
  export type GameUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GameUsers to delete
     */
    where?: GameUserWhereInput
    /**
     * Limit how many GameUsers to delete.
     */
    limit?: number
  }

  /**
   * GameUser without action
   */
  export type GameUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
  }


  /**
   * Model Place
   */

  export type AggregatePlace = {
    _count: PlaceCountAggregateOutputType | null
    _avg: PlaceAvgAggregateOutputType | null
    _sum: PlaceSumAggregateOutputType | null
    _min: PlaceMinAggregateOutputType | null
    _max: PlaceMaxAggregateOutputType | null
  }

  export type PlaceAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type PlaceSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type PlaceMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    ownerId: string | null
    isIndoor: boolean | null
    isFree: boolean | null
    cityId: string | null
    latitude: number | null
    longitude: number | null
  }

  export type PlaceMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
    ownerId: string | null
    isIndoor: boolean | null
    isFree: boolean | null
    cityId: string | null
    latitude: number | null
    longitude: number | null
  }

  export type PlaceCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    description: number
    ownerId: number
    isIndoor: number
    isFree: number
    cityId: number
    latitude: number
    longitude: number
    _all: number
  }


  export type PlaceAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type PlaceSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type PlaceMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    ownerId?: true
    isIndoor?: true
    isFree?: true
    cityId?: true
    latitude?: true
    longitude?: true
  }

  export type PlaceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    ownerId?: true
    isIndoor?: true
    isFree?: true
    cityId?: true
    latitude?: true
    longitude?: true
  }

  export type PlaceCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    ownerId?: true
    isIndoor?: true
    isFree?: true
    cityId?: true
    latitude?: true
    longitude?: true
    _all?: true
  }

  export type PlaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Place to aggregate.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Places
    **/
    _count?: true | PlaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaceMaxAggregateInputType
  }

  export type GetPlaceAggregateType<T extends PlaceAggregateArgs> = {
        [P in keyof T & keyof AggregatePlace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlace[P]>
      : GetScalarType<T[P], AggregatePlace[P]>
  }




  export type PlaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceWhereInput
    orderBy?: PlaceOrderByWithAggregationInput | PlaceOrderByWithAggregationInput[]
    by: PlaceScalarFieldEnum[] | PlaceScalarFieldEnum
    having?: PlaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaceCountAggregateInputType | true
    _avg?: PlaceAvgAggregateInputType
    _sum?: PlaceSumAggregateInputType
    _min?: PlaceMinAggregateInputType
    _max?: PlaceMaxAggregateInputType
  }

  export type PlaceGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    description: string
    ownerId: string
    isIndoor: boolean | null
    isFree: boolean | null
    cityId: string
    latitude: number
    longitude: number
    _count: PlaceCountAggregateOutputType | null
    _avg: PlaceAvgAggregateOutputType | null
    _sum: PlaceSumAggregateOutputType | null
    _min: PlaceMinAggregateOutputType | null
    _max: PlaceMaxAggregateOutputType | null
  }

  type GetPlaceGroupByPayload<T extends PlaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaceGroupByOutputType[P]>
            : GetScalarType<T[P], PlaceGroupByOutputType[P]>
        }
      >
    >


  export type PlaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    isIndoor?: boolean
    isFree?: boolean
    cityId?: boolean
    latitude?: boolean
    longitude?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    schedules?: boolean | Place$schedulesArgs<ExtArgs>
    games?: boolean | Place$gamesArgs<ExtArgs>
    covers?: boolean | Place$coversArgs<ExtArgs>
    sports?: boolean | Place$sportsArgs<ExtArgs>
    favoritedUsers?: boolean | Place$favoritedUsersArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    _count?: boolean | PlaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["place"]>

  export type PlaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    isIndoor?: boolean
    isFree?: boolean
    cityId?: boolean
    latitude?: boolean
    longitude?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["place"]>

  export type PlaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    isIndoor?: boolean
    isFree?: boolean
    cityId?: boolean
    latitude?: boolean
    longitude?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["place"]>

  export type PlaceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    isIndoor?: boolean
    isFree?: boolean
    cityId?: boolean
    latitude?: boolean
    longitude?: boolean
  }

  export type PlaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "description" | "ownerId" | "isIndoor" | "isFree" | "cityId" | "latitude" | "longitude", ExtArgs["result"]["place"]>
  export type PlaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    schedules?: boolean | Place$schedulesArgs<ExtArgs>
    games?: boolean | Place$gamesArgs<ExtArgs>
    covers?: boolean | Place$coversArgs<ExtArgs>
    sports?: boolean | Place$sportsArgs<ExtArgs>
    favoritedUsers?: boolean | Place$favoritedUsersArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    _count?: boolean | PlaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }
  export type PlaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $PlacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Place"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
      games: Prisma.$GamePayload<ExtArgs>[]
      covers: Prisma.$PlaceCoversPayload<ExtArgs>[]
      sports: Prisma.$PlaceSportPayload<ExtArgs>[]
      favoritedUsers: Prisma.$PlaceFavoritePayload<ExtArgs>[]
      city: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      description: string
      ownerId: string
      isIndoor: boolean | null
      isFree: boolean | null
      cityId: string
      latitude: number
      longitude: number
    }, ExtArgs["result"]["place"]>
    composites: {}
  }

  type PlaceGetPayload<S extends boolean | null | undefined | PlaceDefaultArgs> = $Result.GetResult<Prisma.$PlacePayload, S>

  type PlaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaceCountAggregateInputType | true
    }

  export interface PlaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Place'], meta: { name: 'Place' } }
    /**
     * Find zero or one Place that matches the filter.
     * @param {PlaceFindUniqueArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaceFindUniqueArgs>(args: SelectSubset<T, PlaceFindUniqueArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Place that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaceFindUniqueOrThrowArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaceFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Place that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindFirstArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaceFindFirstArgs>(args?: SelectSubset<T, PlaceFindFirstArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Place that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindFirstOrThrowArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaceFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Places that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Places
     * const places = await prisma.place.findMany()
     * 
     * // Get first 10 Places
     * const places = await prisma.place.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const placeWithIdOnly = await prisma.place.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaceFindManyArgs>(args?: SelectSubset<T, PlaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Place.
     * @param {PlaceCreateArgs} args - Arguments to create a Place.
     * @example
     * // Create one Place
     * const Place = await prisma.place.create({
     *   data: {
     *     // ... data to create a Place
     *   }
     * })
     * 
     */
    create<T extends PlaceCreateArgs>(args: SelectSubset<T, PlaceCreateArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Places.
     * @param {PlaceCreateManyArgs} args - Arguments to create many Places.
     * @example
     * // Create many Places
     * const place = await prisma.place.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaceCreateManyArgs>(args?: SelectSubset<T, PlaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Places and returns the data saved in the database.
     * @param {PlaceCreateManyAndReturnArgs} args - Arguments to create many Places.
     * @example
     * // Create many Places
     * const place = await prisma.place.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Places and only return the `id`
     * const placeWithIdOnly = await prisma.place.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaceCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Place.
     * @param {PlaceDeleteArgs} args - Arguments to delete one Place.
     * @example
     * // Delete one Place
     * const Place = await prisma.place.delete({
     *   where: {
     *     // ... filter to delete one Place
     *   }
     * })
     * 
     */
    delete<T extends PlaceDeleteArgs>(args: SelectSubset<T, PlaceDeleteArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Place.
     * @param {PlaceUpdateArgs} args - Arguments to update one Place.
     * @example
     * // Update one Place
     * const place = await prisma.place.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaceUpdateArgs>(args: SelectSubset<T, PlaceUpdateArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Places.
     * @param {PlaceDeleteManyArgs} args - Arguments to filter Places to delete.
     * @example
     * // Delete a few Places
     * const { count } = await prisma.place.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaceDeleteManyArgs>(args?: SelectSubset<T, PlaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Places.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Places
     * const place = await prisma.place.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaceUpdateManyArgs>(args: SelectSubset<T, PlaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Places and returns the data updated in the database.
     * @param {PlaceUpdateManyAndReturnArgs} args - Arguments to update many Places.
     * @example
     * // Update many Places
     * const place = await prisma.place.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Places and only return the `id`
     * const placeWithIdOnly = await prisma.place.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaceUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Place.
     * @param {PlaceUpsertArgs} args - Arguments to update or create a Place.
     * @example
     * // Update or create a Place
     * const place = await prisma.place.upsert({
     *   create: {
     *     // ... data to create a Place
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Place we want to update
     *   }
     * })
     */
    upsert<T extends PlaceUpsertArgs>(args: SelectSubset<T, PlaceUpsertArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Places.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceCountArgs} args - Arguments to filter Places to count.
     * @example
     * // Count the number of Places
     * const count = await prisma.place.count({
     *   where: {
     *     // ... the filter for the Places we want to count
     *   }
     * })
    **/
    count<T extends PlaceCountArgs>(
      args?: Subset<T, PlaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Place.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaceAggregateArgs>(args: Subset<T, PlaceAggregateArgs>): Prisma.PrismaPromise<GetPlaceAggregateType<T>>

    /**
     * Group by Place.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaceGroupByArgs['orderBy'] }
        : { orderBy?: PlaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Place model
   */
  readonly fields: PlaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Place.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schedules<T extends Place$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Place$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    games<T extends Place$gamesArgs<ExtArgs> = {}>(args?: Subset<T, Place$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    covers<T extends Place$coversArgs<ExtArgs> = {}>(args?: Subset<T, Place$coversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceCoversPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sports<T extends Place$sportsArgs<ExtArgs> = {}>(args?: Subset<T, Place$sportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceSportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favoritedUsers<T extends Place$favoritedUsersArgs<ExtArgs> = {}>(args?: Subset<T, Place$favoritedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Place model
   */
  interface PlaceFieldRefs {
    readonly id: FieldRef<"Place", 'String'>
    readonly createdAt: FieldRef<"Place", 'DateTime'>
    readonly updatedAt: FieldRef<"Place", 'DateTime'>
    readonly name: FieldRef<"Place", 'String'>
    readonly description: FieldRef<"Place", 'String'>
    readonly ownerId: FieldRef<"Place", 'String'>
    readonly isIndoor: FieldRef<"Place", 'Boolean'>
    readonly isFree: FieldRef<"Place", 'Boolean'>
    readonly cityId: FieldRef<"Place", 'String'>
    readonly latitude: FieldRef<"Place", 'Float'>
    readonly longitude: FieldRef<"Place", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Place findUnique
   */
  export type PlaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place findUniqueOrThrow
   */
  export type PlaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place findFirst
   */
  export type PlaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Places.
     */
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place findFirstOrThrow
   */
  export type PlaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Places.
     */
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place findMany
   */
  export type PlaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Places to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place create
   */
  export type PlaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Place.
     */
    data: XOR<PlaceCreateInput, PlaceUncheckedCreateInput>
  }

  /**
   * Place createMany
   */
  export type PlaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Places.
     */
    data: PlaceCreateManyInput | PlaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Place createManyAndReturn
   */
  export type PlaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * The data used to create many Places.
     */
    data: PlaceCreateManyInput | PlaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Place update
   */
  export type PlaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Place.
     */
    data: XOR<PlaceUpdateInput, PlaceUncheckedUpdateInput>
    /**
     * Choose, which Place to update.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place updateMany
   */
  export type PlaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Places.
     */
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyInput>
    /**
     * Filter which Places to update
     */
    where?: PlaceWhereInput
    /**
     * Limit how many Places to update.
     */
    limit?: number
  }

  /**
   * Place updateManyAndReturn
   */
  export type PlaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * The data used to update Places.
     */
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyInput>
    /**
     * Filter which Places to update
     */
    where?: PlaceWhereInput
    /**
     * Limit how many Places to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Place upsert
   */
  export type PlaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Place to update in case it exists.
     */
    where: PlaceWhereUniqueInput
    /**
     * In case the Place found by the `where` argument doesn't exist, create a new Place with this data.
     */
    create: XOR<PlaceCreateInput, PlaceUncheckedCreateInput>
    /**
     * In case the Place was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaceUpdateInput, PlaceUncheckedUpdateInput>
  }

  /**
   * Place delete
   */
  export type PlaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter which Place to delete.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place deleteMany
   */
  export type PlaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Places to delete
     */
    where?: PlaceWhereInput
    /**
     * Limit how many Places to delete.
     */
    limit?: number
  }

  /**
   * Place.schedules
   */
  export type Place$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Place.games
   */
  export type Place$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Place.covers
   */
  export type Place$coversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCovers
     */
    select?: PlaceCoversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceCovers
     */
    omit?: PlaceCoversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceCoversInclude<ExtArgs> | null
    where?: PlaceCoversWhereInput
    orderBy?: PlaceCoversOrderByWithRelationInput | PlaceCoversOrderByWithRelationInput[]
    cursor?: PlaceCoversWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceCoversScalarFieldEnum | PlaceCoversScalarFieldEnum[]
  }

  /**
   * Place.sports
   */
  export type Place$sportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceSport
     */
    select?: PlaceSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceSport
     */
    omit?: PlaceSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceSportInclude<ExtArgs> | null
    where?: PlaceSportWhereInput
    orderBy?: PlaceSportOrderByWithRelationInput | PlaceSportOrderByWithRelationInput[]
    cursor?: PlaceSportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceSportScalarFieldEnum | PlaceSportScalarFieldEnum[]
  }

  /**
   * Place.favoritedUsers
   */
  export type Place$favoritedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceFavorite
     */
    select?: PlaceFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceFavorite
     */
    omit?: PlaceFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceFavoriteInclude<ExtArgs> | null
    where?: PlaceFavoriteWhereInput
    orderBy?: PlaceFavoriteOrderByWithRelationInput | PlaceFavoriteOrderByWithRelationInput[]
    cursor?: PlaceFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceFavoriteScalarFieldEnum | PlaceFavoriteScalarFieldEnum[]
  }

  /**
   * Place without action
   */
  export type PlaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
  }


  /**
   * Model PlaceFavorite
   */

  export type AggregatePlaceFavorite = {
    _count: PlaceFavoriteCountAggregateOutputType | null
    _min: PlaceFavoriteMinAggregateOutputType | null
    _max: PlaceFavoriteMaxAggregateOutputType | null
  }

  export type PlaceFavoriteMinAggregateOutputType = {
    createdAt: Date | null
    userId: string | null
    placeId: string | null
  }

  export type PlaceFavoriteMaxAggregateOutputType = {
    createdAt: Date | null
    userId: string | null
    placeId: string | null
  }

  export type PlaceFavoriteCountAggregateOutputType = {
    createdAt: number
    userId: number
    placeId: number
    _all: number
  }


  export type PlaceFavoriteMinAggregateInputType = {
    createdAt?: true
    userId?: true
    placeId?: true
  }

  export type PlaceFavoriteMaxAggregateInputType = {
    createdAt?: true
    userId?: true
    placeId?: true
  }

  export type PlaceFavoriteCountAggregateInputType = {
    createdAt?: true
    userId?: true
    placeId?: true
    _all?: true
  }

  export type PlaceFavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaceFavorite to aggregate.
     */
    where?: PlaceFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceFavorites to fetch.
     */
    orderBy?: PlaceFavoriteOrderByWithRelationInput | PlaceFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaceFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaceFavorites
    **/
    _count?: true | PlaceFavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaceFavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaceFavoriteMaxAggregateInputType
  }

  export type GetPlaceFavoriteAggregateType<T extends PlaceFavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaceFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaceFavorite[P]>
      : GetScalarType<T[P], AggregatePlaceFavorite[P]>
  }




  export type PlaceFavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceFavoriteWhereInput
    orderBy?: PlaceFavoriteOrderByWithAggregationInput | PlaceFavoriteOrderByWithAggregationInput[]
    by: PlaceFavoriteScalarFieldEnum[] | PlaceFavoriteScalarFieldEnum
    having?: PlaceFavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaceFavoriteCountAggregateInputType | true
    _min?: PlaceFavoriteMinAggregateInputType
    _max?: PlaceFavoriteMaxAggregateInputType
  }

  export type PlaceFavoriteGroupByOutputType = {
    createdAt: Date
    userId: string
    placeId: string
    _count: PlaceFavoriteCountAggregateOutputType | null
    _min: PlaceFavoriteMinAggregateOutputType | null
    _max: PlaceFavoriteMaxAggregateOutputType | null
  }

  type GetPlaceFavoriteGroupByPayload<T extends PlaceFavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaceFavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaceFavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaceFavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], PlaceFavoriteGroupByOutputType[P]>
        }
      >
    >


  export type PlaceFavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    userId?: boolean
    placeId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeFavorite"]>

  export type PlaceFavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    userId?: boolean
    placeId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeFavorite"]>

  export type PlaceFavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    userId?: boolean
    placeId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeFavorite"]>

  export type PlaceFavoriteSelectScalar = {
    createdAt?: boolean
    userId?: boolean
    placeId?: boolean
  }

  export type PlaceFavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "userId" | "placeId", ExtArgs["result"]["placeFavorite"]>
  export type PlaceFavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }
  export type PlaceFavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }
  export type PlaceFavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }

  export type $PlaceFavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaceFavorite"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      place: Prisma.$PlacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      userId: string
      placeId: string
    }, ExtArgs["result"]["placeFavorite"]>
    composites: {}
  }

  type PlaceFavoriteGetPayload<S extends boolean | null | undefined | PlaceFavoriteDefaultArgs> = $Result.GetResult<Prisma.$PlaceFavoritePayload, S>

  type PlaceFavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaceFavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaceFavoriteCountAggregateInputType | true
    }

  export interface PlaceFavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaceFavorite'], meta: { name: 'PlaceFavorite' } }
    /**
     * Find zero or one PlaceFavorite that matches the filter.
     * @param {PlaceFavoriteFindUniqueArgs} args - Arguments to find a PlaceFavorite
     * @example
     * // Get one PlaceFavorite
     * const placeFavorite = await prisma.placeFavorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaceFavoriteFindUniqueArgs>(args: SelectSubset<T, PlaceFavoriteFindUniqueArgs<ExtArgs>>): Prisma__PlaceFavoriteClient<$Result.GetResult<Prisma.$PlaceFavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaceFavorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaceFavoriteFindUniqueOrThrowArgs} args - Arguments to find a PlaceFavorite
     * @example
     * // Get one PlaceFavorite
     * const placeFavorite = await prisma.placeFavorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaceFavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaceFavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaceFavoriteClient<$Result.GetResult<Prisma.$PlaceFavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaceFavorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFavoriteFindFirstArgs} args - Arguments to find a PlaceFavorite
     * @example
     * // Get one PlaceFavorite
     * const placeFavorite = await prisma.placeFavorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaceFavoriteFindFirstArgs>(args?: SelectSubset<T, PlaceFavoriteFindFirstArgs<ExtArgs>>): Prisma__PlaceFavoriteClient<$Result.GetResult<Prisma.$PlaceFavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaceFavorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFavoriteFindFirstOrThrowArgs} args - Arguments to find a PlaceFavorite
     * @example
     * // Get one PlaceFavorite
     * const placeFavorite = await prisma.placeFavorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaceFavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaceFavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaceFavoriteClient<$Result.GetResult<Prisma.$PlaceFavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaceFavorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaceFavorites
     * const placeFavorites = await prisma.placeFavorite.findMany()
     * 
     * // Get first 10 PlaceFavorites
     * const placeFavorites = await prisma.placeFavorite.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const placeFavoriteWithCreatedAtOnly = await prisma.placeFavorite.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends PlaceFavoriteFindManyArgs>(args?: SelectSubset<T, PlaceFavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaceFavorite.
     * @param {PlaceFavoriteCreateArgs} args - Arguments to create a PlaceFavorite.
     * @example
     * // Create one PlaceFavorite
     * const PlaceFavorite = await prisma.placeFavorite.create({
     *   data: {
     *     // ... data to create a PlaceFavorite
     *   }
     * })
     * 
     */
    create<T extends PlaceFavoriteCreateArgs>(args: SelectSubset<T, PlaceFavoriteCreateArgs<ExtArgs>>): Prisma__PlaceFavoriteClient<$Result.GetResult<Prisma.$PlaceFavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaceFavorites.
     * @param {PlaceFavoriteCreateManyArgs} args - Arguments to create many PlaceFavorites.
     * @example
     * // Create many PlaceFavorites
     * const placeFavorite = await prisma.placeFavorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaceFavoriteCreateManyArgs>(args?: SelectSubset<T, PlaceFavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaceFavorites and returns the data saved in the database.
     * @param {PlaceFavoriteCreateManyAndReturnArgs} args - Arguments to create many PlaceFavorites.
     * @example
     * // Create many PlaceFavorites
     * const placeFavorite = await prisma.placeFavorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaceFavorites and only return the `createdAt`
     * const placeFavoriteWithCreatedAtOnly = await prisma.placeFavorite.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaceFavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaceFavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceFavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaceFavorite.
     * @param {PlaceFavoriteDeleteArgs} args - Arguments to delete one PlaceFavorite.
     * @example
     * // Delete one PlaceFavorite
     * const PlaceFavorite = await prisma.placeFavorite.delete({
     *   where: {
     *     // ... filter to delete one PlaceFavorite
     *   }
     * })
     * 
     */
    delete<T extends PlaceFavoriteDeleteArgs>(args: SelectSubset<T, PlaceFavoriteDeleteArgs<ExtArgs>>): Prisma__PlaceFavoriteClient<$Result.GetResult<Prisma.$PlaceFavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaceFavorite.
     * @param {PlaceFavoriteUpdateArgs} args - Arguments to update one PlaceFavorite.
     * @example
     * // Update one PlaceFavorite
     * const placeFavorite = await prisma.placeFavorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaceFavoriteUpdateArgs>(args: SelectSubset<T, PlaceFavoriteUpdateArgs<ExtArgs>>): Prisma__PlaceFavoriteClient<$Result.GetResult<Prisma.$PlaceFavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaceFavorites.
     * @param {PlaceFavoriteDeleteManyArgs} args - Arguments to filter PlaceFavorites to delete.
     * @example
     * // Delete a few PlaceFavorites
     * const { count } = await prisma.placeFavorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaceFavoriteDeleteManyArgs>(args?: SelectSubset<T, PlaceFavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaceFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaceFavorites
     * const placeFavorite = await prisma.placeFavorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaceFavoriteUpdateManyArgs>(args: SelectSubset<T, PlaceFavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaceFavorites and returns the data updated in the database.
     * @param {PlaceFavoriteUpdateManyAndReturnArgs} args - Arguments to update many PlaceFavorites.
     * @example
     * // Update many PlaceFavorites
     * const placeFavorite = await prisma.placeFavorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaceFavorites and only return the `createdAt`
     * const placeFavoriteWithCreatedAtOnly = await prisma.placeFavorite.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaceFavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaceFavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceFavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaceFavorite.
     * @param {PlaceFavoriteUpsertArgs} args - Arguments to update or create a PlaceFavorite.
     * @example
     * // Update or create a PlaceFavorite
     * const placeFavorite = await prisma.placeFavorite.upsert({
     *   create: {
     *     // ... data to create a PlaceFavorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaceFavorite we want to update
     *   }
     * })
     */
    upsert<T extends PlaceFavoriteUpsertArgs>(args: SelectSubset<T, PlaceFavoriteUpsertArgs<ExtArgs>>): Prisma__PlaceFavoriteClient<$Result.GetResult<Prisma.$PlaceFavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaceFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFavoriteCountArgs} args - Arguments to filter PlaceFavorites to count.
     * @example
     * // Count the number of PlaceFavorites
     * const count = await prisma.placeFavorite.count({
     *   where: {
     *     // ... the filter for the PlaceFavorites we want to count
     *   }
     * })
    **/
    count<T extends PlaceFavoriteCountArgs>(
      args?: Subset<T, PlaceFavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaceFavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaceFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaceFavoriteAggregateArgs>(args: Subset<T, PlaceFavoriteAggregateArgs>): Prisma.PrismaPromise<GetPlaceFavoriteAggregateType<T>>

    /**
     * Group by PlaceFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaceFavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaceFavoriteGroupByArgs['orderBy'] }
        : { orderBy?: PlaceFavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaceFavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaceFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaceFavorite model
   */
  readonly fields: PlaceFavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaceFavorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaceFavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    place<T extends PlaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceDefaultArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaceFavorite model
   */
  interface PlaceFavoriteFieldRefs {
    readonly createdAt: FieldRef<"PlaceFavorite", 'DateTime'>
    readonly userId: FieldRef<"PlaceFavorite", 'String'>
    readonly placeId: FieldRef<"PlaceFavorite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlaceFavorite findUnique
   */
  export type PlaceFavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceFavorite
     */
    select?: PlaceFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceFavorite
     */
    omit?: PlaceFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which PlaceFavorite to fetch.
     */
    where: PlaceFavoriteWhereUniqueInput
  }

  /**
   * PlaceFavorite findUniqueOrThrow
   */
  export type PlaceFavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceFavorite
     */
    select?: PlaceFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceFavorite
     */
    omit?: PlaceFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which PlaceFavorite to fetch.
     */
    where: PlaceFavoriteWhereUniqueInput
  }

  /**
   * PlaceFavorite findFirst
   */
  export type PlaceFavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceFavorite
     */
    select?: PlaceFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceFavorite
     */
    omit?: PlaceFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which PlaceFavorite to fetch.
     */
    where?: PlaceFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceFavorites to fetch.
     */
    orderBy?: PlaceFavoriteOrderByWithRelationInput | PlaceFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaceFavorites.
     */
    cursor?: PlaceFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaceFavorites.
     */
    distinct?: PlaceFavoriteScalarFieldEnum | PlaceFavoriteScalarFieldEnum[]
  }

  /**
   * PlaceFavorite findFirstOrThrow
   */
  export type PlaceFavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceFavorite
     */
    select?: PlaceFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceFavorite
     */
    omit?: PlaceFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which PlaceFavorite to fetch.
     */
    where?: PlaceFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceFavorites to fetch.
     */
    orderBy?: PlaceFavoriteOrderByWithRelationInput | PlaceFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaceFavorites.
     */
    cursor?: PlaceFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaceFavorites.
     */
    distinct?: PlaceFavoriteScalarFieldEnum | PlaceFavoriteScalarFieldEnum[]
  }

  /**
   * PlaceFavorite findMany
   */
  export type PlaceFavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceFavorite
     */
    select?: PlaceFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceFavorite
     */
    omit?: PlaceFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which PlaceFavorites to fetch.
     */
    where?: PlaceFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceFavorites to fetch.
     */
    orderBy?: PlaceFavoriteOrderByWithRelationInput | PlaceFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaceFavorites.
     */
    cursor?: PlaceFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceFavorites.
     */
    skip?: number
    distinct?: PlaceFavoriteScalarFieldEnum | PlaceFavoriteScalarFieldEnum[]
  }

  /**
   * PlaceFavorite create
   */
  export type PlaceFavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceFavorite
     */
    select?: PlaceFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceFavorite
     */
    omit?: PlaceFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaceFavorite.
     */
    data: XOR<PlaceFavoriteCreateInput, PlaceFavoriteUncheckedCreateInput>
  }

  /**
   * PlaceFavorite createMany
   */
  export type PlaceFavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaceFavorites.
     */
    data: PlaceFavoriteCreateManyInput | PlaceFavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlaceFavorite createManyAndReturn
   */
  export type PlaceFavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceFavorite
     */
    select?: PlaceFavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceFavorite
     */
    omit?: PlaceFavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many PlaceFavorites.
     */
    data: PlaceFavoriteCreateManyInput | PlaceFavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceFavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaceFavorite update
   */
  export type PlaceFavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceFavorite
     */
    select?: PlaceFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceFavorite
     */
    omit?: PlaceFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaceFavorite.
     */
    data: XOR<PlaceFavoriteUpdateInput, PlaceFavoriteUncheckedUpdateInput>
    /**
     * Choose, which PlaceFavorite to update.
     */
    where: PlaceFavoriteWhereUniqueInput
  }

  /**
   * PlaceFavorite updateMany
   */
  export type PlaceFavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaceFavorites.
     */
    data: XOR<PlaceFavoriteUpdateManyMutationInput, PlaceFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which PlaceFavorites to update
     */
    where?: PlaceFavoriteWhereInput
    /**
     * Limit how many PlaceFavorites to update.
     */
    limit?: number
  }

  /**
   * PlaceFavorite updateManyAndReturn
   */
  export type PlaceFavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceFavorite
     */
    select?: PlaceFavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceFavorite
     */
    omit?: PlaceFavoriteOmit<ExtArgs> | null
    /**
     * The data used to update PlaceFavorites.
     */
    data: XOR<PlaceFavoriteUpdateManyMutationInput, PlaceFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which PlaceFavorites to update
     */
    where?: PlaceFavoriteWhereInput
    /**
     * Limit how many PlaceFavorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceFavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaceFavorite upsert
   */
  export type PlaceFavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceFavorite
     */
    select?: PlaceFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceFavorite
     */
    omit?: PlaceFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceFavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaceFavorite to update in case it exists.
     */
    where: PlaceFavoriteWhereUniqueInput
    /**
     * In case the PlaceFavorite found by the `where` argument doesn't exist, create a new PlaceFavorite with this data.
     */
    create: XOR<PlaceFavoriteCreateInput, PlaceFavoriteUncheckedCreateInput>
    /**
     * In case the PlaceFavorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaceFavoriteUpdateInput, PlaceFavoriteUncheckedUpdateInput>
  }

  /**
   * PlaceFavorite delete
   */
  export type PlaceFavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceFavorite
     */
    select?: PlaceFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceFavorite
     */
    omit?: PlaceFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceFavoriteInclude<ExtArgs> | null
    /**
     * Filter which PlaceFavorite to delete.
     */
    where: PlaceFavoriteWhereUniqueInput
  }

  /**
   * PlaceFavorite deleteMany
   */
  export type PlaceFavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaceFavorites to delete
     */
    where?: PlaceFavoriteWhereInput
    /**
     * Limit how many PlaceFavorites to delete.
     */
    limit?: number
  }

  /**
   * PlaceFavorite without action
   */
  export type PlaceFavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceFavorite
     */
    select?: PlaceFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceFavorite
     */
    omit?: PlaceFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceFavoriteInclude<ExtArgs> | null
  }


  /**
   * Model PlaceCovers
   */

  export type AggregatePlaceCovers = {
    _count: PlaceCoversCountAggregateOutputType | null
    _avg: PlaceCoversAvgAggregateOutputType | null
    _sum: PlaceCoversSumAggregateOutputType | null
    _min: PlaceCoversMinAggregateOutputType | null
    _max: PlaceCoversMaxAggregateOutputType | null
  }

  export type PlaceCoversAvgAggregateOutputType = {
    order: number | null
  }

  export type PlaceCoversSumAggregateOutputType = {
    order: number | null
  }

  export type PlaceCoversMinAggregateOutputType = {
    id: string | null
    order: number | null
    placeId: string | null
    createdAt: Date | null
  }

  export type PlaceCoversMaxAggregateOutputType = {
    id: string | null
    order: number | null
    placeId: string | null
    createdAt: Date | null
  }

  export type PlaceCoversCountAggregateOutputType = {
    id: number
    order: number
    placeId: number
    createdAt: number
    _all: number
  }


  export type PlaceCoversAvgAggregateInputType = {
    order?: true
  }

  export type PlaceCoversSumAggregateInputType = {
    order?: true
  }

  export type PlaceCoversMinAggregateInputType = {
    id?: true
    order?: true
    placeId?: true
    createdAt?: true
  }

  export type PlaceCoversMaxAggregateInputType = {
    id?: true
    order?: true
    placeId?: true
    createdAt?: true
  }

  export type PlaceCoversCountAggregateInputType = {
    id?: true
    order?: true
    placeId?: true
    createdAt?: true
    _all?: true
  }

  export type PlaceCoversAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaceCovers to aggregate.
     */
    where?: PlaceCoversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceCovers to fetch.
     */
    orderBy?: PlaceCoversOrderByWithRelationInput | PlaceCoversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaceCoversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceCovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceCovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaceCovers
    **/
    _count?: true | PlaceCoversCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaceCoversAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaceCoversSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaceCoversMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaceCoversMaxAggregateInputType
  }

  export type GetPlaceCoversAggregateType<T extends PlaceCoversAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaceCovers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaceCovers[P]>
      : GetScalarType<T[P], AggregatePlaceCovers[P]>
  }




  export type PlaceCoversGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceCoversWhereInput
    orderBy?: PlaceCoversOrderByWithAggregationInput | PlaceCoversOrderByWithAggregationInput[]
    by: PlaceCoversScalarFieldEnum[] | PlaceCoversScalarFieldEnum
    having?: PlaceCoversScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaceCoversCountAggregateInputType | true
    _avg?: PlaceCoversAvgAggregateInputType
    _sum?: PlaceCoversSumAggregateInputType
    _min?: PlaceCoversMinAggregateInputType
    _max?: PlaceCoversMaxAggregateInputType
  }

  export type PlaceCoversGroupByOutputType = {
    id: string
    order: number
    placeId: string
    createdAt: Date
    _count: PlaceCoversCountAggregateOutputType | null
    _avg: PlaceCoversAvgAggregateOutputType | null
    _sum: PlaceCoversSumAggregateOutputType | null
    _min: PlaceCoversMinAggregateOutputType | null
    _max: PlaceCoversMaxAggregateOutputType | null
  }

  type GetPlaceCoversGroupByPayload<T extends PlaceCoversGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaceCoversGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaceCoversGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaceCoversGroupByOutputType[P]>
            : GetScalarType<T[P], PlaceCoversGroupByOutputType[P]>
        }
      >
    >


  export type PlaceCoversSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    placeId?: boolean
    createdAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeCovers"]>

  export type PlaceCoversSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    placeId?: boolean
    createdAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeCovers"]>

  export type PlaceCoversSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order?: boolean
    placeId?: boolean
    createdAt?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeCovers"]>

  export type PlaceCoversSelectScalar = {
    id?: boolean
    order?: boolean
    placeId?: boolean
    createdAt?: boolean
  }

  export type PlaceCoversOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "order" | "placeId" | "createdAt", ExtArgs["result"]["placeCovers"]>
  export type PlaceCoversInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }
  export type PlaceCoversIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }
  export type PlaceCoversIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }

  export type $PlaceCoversPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaceCovers"
    objects: {
      place: Prisma.$PlacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      order: number
      placeId: string
      createdAt: Date
    }, ExtArgs["result"]["placeCovers"]>
    composites: {}
  }

  type PlaceCoversGetPayload<S extends boolean | null | undefined | PlaceCoversDefaultArgs> = $Result.GetResult<Prisma.$PlaceCoversPayload, S>

  type PlaceCoversCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaceCoversFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaceCoversCountAggregateInputType | true
    }

  export interface PlaceCoversDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaceCovers'], meta: { name: 'PlaceCovers' } }
    /**
     * Find zero or one PlaceCovers that matches the filter.
     * @param {PlaceCoversFindUniqueArgs} args - Arguments to find a PlaceCovers
     * @example
     * // Get one PlaceCovers
     * const placeCovers = await prisma.placeCovers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaceCoversFindUniqueArgs>(args: SelectSubset<T, PlaceCoversFindUniqueArgs<ExtArgs>>): Prisma__PlaceCoversClient<$Result.GetResult<Prisma.$PlaceCoversPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaceCovers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaceCoversFindUniqueOrThrowArgs} args - Arguments to find a PlaceCovers
     * @example
     * // Get one PlaceCovers
     * const placeCovers = await prisma.placeCovers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaceCoversFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaceCoversFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaceCoversClient<$Result.GetResult<Prisma.$PlaceCoversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaceCovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceCoversFindFirstArgs} args - Arguments to find a PlaceCovers
     * @example
     * // Get one PlaceCovers
     * const placeCovers = await prisma.placeCovers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaceCoversFindFirstArgs>(args?: SelectSubset<T, PlaceCoversFindFirstArgs<ExtArgs>>): Prisma__PlaceCoversClient<$Result.GetResult<Prisma.$PlaceCoversPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaceCovers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceCoversFindFirstOrThrowArgs} args - Arguments to find a PlaceCovers
     * @example
     * // Get one PlaceCovers
     * const placeCovers = await prisma.placeCovers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaceCoversFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaceCoversFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaceCoversClient<$Result.GetResult<Prisma.$PlaceCoversPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaceCovers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceCoversFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaceCovers
     * const placeCovers = await prisma.placeCovers.findMany()
     * 
     * // Get first 10 PlaceCovers
     * const placeCovers = await prisma.placeCovers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const placeCoversWithIdOnly = await prisma.placeCovers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaceCoversFindManyArgs>(args?: SelectSubset<T, PlaceCoversFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceCoversPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaceCovers.
     * @param {PlaceCoversCreateArgs} args - Arguments to create a PlaceCovers.
     * @example
     * // Create one PlaceCovers
     * const PlaceCovers = await prisma.placeCovers.create({
     *   data: {
     *     // ... data to create a PlaceCovers
     *   }
     * })
     * 
     */
    create<T extends PlaceCoversCreateArgs>(args: SelectSubset<T, PlaceCoversCreateArgs<ExtArgs>>): Prisma__PlaceCoversClient<$Result.GetResult<Prisma.$PlaceCoversPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaceCovers.
     * @param {PlaceCoversCreateManyArgs} args - Arguments to create many PlaceCovers.
     * @example
     * // Create many PlaceCovers
     * const placeCovers = await prisma.placeCovers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaceCoversCreateManyArgs>(args?: SelectSubset<T, PlaceCoversCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaceCovers and returns the data saved in the database.
     * @param {PlaceCoversCreateManyAndReturnArgs} args - Arguments to create many PlaceCovers.
     * @example
     * // Create many PlaceCovers
     * const placeCovers = await prisma.placeCovers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaceCovers and only return the `id`
     * const placeCoversWithIdOnly = await prisma.placeCovers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaceCoversCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaceCoversCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceCoversPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaceCovers.
     * @param {PlaceCoversDeleteArgs} args - Arguments to delete one PlaceCovers.
     * @example
     * // Delete one PlaceCovers
     * const PlaceCovers = await prisma.placeCovers.delete({
     *   where: {
     *     // ... filter to delete one PlaceCovers
     *   }
     * })
     * 
     */
    delete<T extends PlaceCoversDeleteArgs>(args: SelectSubset<T, PlaceCoversDeleteArgs<ExtArgs>>): Prisma__PlaceCoversClient<$Result.GetResult<Prisma.$PlaceCoversPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaceCovers.
     * @param {PlaceCoversUpdateArgs} args - Arguments to update one PlaceCovers.
     * @example
     * // Update one PlaceCovers
     * const placeCovers = await prisma.placeCovers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaceCoversUpdateArgs>(args: SelectSubset<T, PlaceCoversUpdateArgs<ExtArgs>>): Prisma__PlaceCoversClient<$Result.GetResult<Prisma.$PlaceCoversPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaceCovers.
     * @param {PlaceCoversDeleteManyArgs} args - Arguments to filter PlaceCovers to delete.
     * @example
     * // Delete a few PlaceCovers
     * const { count } = await prisma.placeCovers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaceCoversDeleteManyArgs>(args?: SelectSubset<T, PlaceCoversDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaceCovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceCoversUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaceCovers
     * const placeCovers = await prisma.placeCovers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaceCoversUpdateManyArgs>(args: SelectSubset<T, PlaceCoversUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaceCovers and returns the data updated in the database.
     * @param {PlaceCoversUpdateManyAndReturnArgs} args - Arguments to update many PlaceCovers.
     * @example
     * // Update many PlaceCovers
     * const placeCovers = await prisma.placeCovers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaceCovers and only return the `id`
     * const placeCoversWithIdOnly = await prisma.placeCovers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaceCoversUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaceCoversUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceCoversPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaceCovers.
     * @param {PlaceCoversUpsertArgs} args - Arguments to update or create a PlaceCovers.
     * @example
     * // Update or create a PlaceCovers
     * const placeCovers = await prisma.placeCovers.upsert({
     *   create: {
     *     // ... data to create a PlaceCovers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaceCovers we want to update
     *   }
     * })
     */
    upsert<T extends PlaceCoversUpsertArgs>(args: SelectSubset<T, PlaceCoversUpsertArgs<ExtArgs>>): Prisma__PlaceCoversClient<$Result.GetResult<Prisma.$PlaceCoversPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaceCovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceCoversCountArgs} args - Arguments to filter PlaceCovers to count.
     * @example
     * // Count the number of PlaceCovers
     * const count = await prisma.placeCovers.count({
     *   where: {
     *     // ... the filter for the PlaceCovers we want to count
     *   }
     * })
    **/
    count<T extends PlaceCoversCountArgs>(
      args?: Subset<T, PlaceCoversCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaceCoversCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaceCovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceCoversAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaceCoversAggregateArgs>(args: Subset<T, PlaceCoversAggregateArgs>): Prisma.PrismaPromise<GetPlaceCoversAggregateType<T>>

    /**
     * Group by PlaceCovers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceCoversGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaceCoversGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaceCoversGroupByArgs['orderBy'] }
        : { orderBy?: PlaceCoversGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaceCoversGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaceCoversGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaceCovers model
   */
  readonly fields: PlaceCoversFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaceCovers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaceCoversClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    place<T extends PlaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceDefaultArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaceCovers model
   */
  interface PlaceCoversFieldRefs {
    readonly id: FieldRef<"PlaceCovers", 'String'>
    readonly order: FieldRef<"PlaceCovers", 'Int'>
    readonly placeId: FieldRef<"PlaceCovers", 'String'>
    readonly createdAt: FieldRef<"PlaceCovers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlaceCovers findUnique
   */
  export type PlaceCoversFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCovers
     */
    select?: PlaceCoversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceCovers
     */
    omit?: PlaceCoversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceCoversInclude<ExtArgs> | null
    /**
     * Filter, which PlaceCovers to fetch.
     */
    where: PlaceCoversWhereUniqueInput
  }

  /**
   * PlaceCovers findUniqueOrThrow
   */
  export type PlaceCoversFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCovers
     */
    select?: PlaceCoversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceCovers
     */
    omit?: PlaceCoversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceCoversInclude<ExtArgs> | null
    /**
     * Filter, which PlaceCovers to fetch.
     */
    where: PlaceCoversWhereUniqueInput
  }

  /**
   * PlaceCovers findFirst
   */
  export type PlaceCoversFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCovers
     */
    select?: PlaceCoversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceCovers
     */
    omit?: PlaceCoversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceCoversInclude<ExtArgs> | null
    /**
     * Filter, which PlaceCovers to fetch.
     */
    where?: PlaceCoversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceCovers to fetch.
     */
    orderBy?: PlaceCoversOrderByWithRelationInput | PlaceCoversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaceCovers.
     */
    cursor?: PlaceCoversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceCovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceCovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaceCovers.
     */
    distinct?: PlaceCoversScalarFieldEnum | PlaceCoversScalarFieldEnum[]
  }

  /**
   * PlaceCovers findFirstOrThrow
   */
  export type PlaceCoversFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCovers
     */
    select?: PlaceCoversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceCovers
     */
    omit?: PlaceCoversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceCoversInclude<ExtArgs> | null
    /**
     * Filter, which PlaceCovers to fetch.
     */
    where?: PlaceCoversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceCovers to fetch.
     */
    orderBy?: PlaceCoversOrderByWithRelationInput | PlaceCoversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaceCovers.
     */
    cursor?: PlaceCoversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceCovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceCovers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaceCovers.
     */
    distinct?: PlaceCoversScalarFieldEnum | PlaceCoversScalarFieldEnum[]
  }

  /**
   * PlaceCovers findMany
   */
  export type PlaceCoversFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCovers
     */
    select?: PlaceCoversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceCovers
     */
    omit?: PlaceCoversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceCoversInclude<ExtArgs> | null
    /**
     * Filter, which PlaceCovers to fetch.
     */
    where?: PlaceCoversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceCovers to fetch.
     */
    orderBy?: PlaceCoversOrderByWithRelationInput | PlaceCoversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaceCovers.
     */
    cursor?: PlaceCoversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceCovers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceCovers.
     */
    skip?: number
    distinct?: PlaceCoversScalarFieldEnum | PlaceCoversScalarFieldEnum[]
  }

  /**
   * PlaceCovers create
   */
  export type PlaceCoversCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCovers
     */
    select?: PlaceCoversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceCovers
     */
    omit?: PlaceCoversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceCoversInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaceCovers.
     */
    data: XOR<PlaceCoversCreateInput, PlaceCoversUncheckedCreateInput>
  }

  /**
   * PlaceCovers createMany
   */
  export type PlaceCoversCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaceCovers.
     */
    data: PlaceCoversCreateManyInput | PlaceCoversCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlaceCovers createManyAndReturn
   */
  export type PlaceCoversCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCovers
     */
    select?: PlaceCoversSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceCovers
     */
    omit?: PlaceCoversOmit<ExtArgs> | null
    /**
     * The data used to create many PlaceCovers.
     */
    data: PlaceCoversCreateManyInput | PlaceCoversCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceCoversIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaceCovers update
   */
  export type PlaceCoversUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCovers
     */
    select?: PlaceCoversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceCovers
     */
    omit?: PlaceCoversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceCoversInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaceCovers.
     */
    data: XOR<PlaceCoversUpdateInput, PlaceCoversUncheckedUpdateInput>
    /**
     * Choose, which PlaceCovers to update.
     */
    where: PlaceCoversWhereUniqueInput
  }

  /**
   * PlaceCovers updateMany
   */
  export type PlaceCoversUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaceCovers.
     */
    data: XOR<PlaceCoversUpdateManyMutationInput, PlaceCoversUncheckedUpdateManyInput>
    /**
     * Filter which PlaceCovers to update
     */
    where?: PlaceCoversWhereInput
    /**
     * Limit how many PlaceCovers to update.
     */
    limit?: number
  }

  /**
   * PlaceCovers updateManyAndReturn
   */
  export type PlaceCoversUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCovers
     */
    select?: PlaceCoversSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceCovers
     */
    omit?: PlaceCoversOmit<ExtArgs> | null
    /**
     * The data used to update PlaceCovers.
     */
    data: XOR<PlaceCoversUpdateManyMutationInput, PlaceCoversUncheckedUpdateManyInput>
    /**
     * Filter which PlaceCovers to update
     */
    where?: PlaceCoversWhereInput
    /**
     * Limit how many PlaceCovers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceCoversIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaceCovers upsert
   */
  export type PlaceCoversUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCovers
     */
    select?: PlaceCoversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceCovers
     */
    omit?: PlaceCoversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceCoversInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaceCovers to update in case it exists.
     */
    where: PlaceCoversWhereUniqueInput
    /**
     * In case the PlaceCovers found by the `where` argument doesn't exist, create a new PlaceCovers with this data.
     */
    create: XOR<PlaceCoversCreateInput, PlaceCoversUncheckedCreateInput>
    /**
     * In case the PlaceCovers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaceCoversUpdateInput, PlaceCoversUncheckedUpdateInput>
  }

  /**
   * PlaceCovers delete
   */
  export type PlaceCoversDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCovers
     */
    select?: PlaceCoversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceCovers
     */
    omit?: PlaceCoversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceCoversInclude<ExtArgs> | null
    /**
     * Filter which PlaceCovers to delete.
     */
    where: PlaceCoversWhereUniqueInput
  }

  /**
   * PlaceCovers deleteMany
   */
  export type PlaceCoversDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaceCovers to delete
     */
    where?: PlaceCoversWhereInput
    /**
     * Limit how many PlaceCovers to delete.
     */
    limit?: number
  }

  /**
   * PlaceCovers without action
   */
  export type PlaceCoversDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCovers
     */
    select?: PlaceCoversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceCovers
     */
    omit?: PlaceCoversOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceCoversInclude<ExtArgs> | null
  }


  /**
   * Model PlaceSport
   */

  export type AggregatePlaceSport = {
    _count: PlaceSportCountAggregateOutputType | null
    _min: PlaceSportMinAggregateOutputType | null
    _max: PlaceSportMaxAggregateOutputType | null
  }

  export type PlaceSportMinAggregateOutputType = {
    createdAt: Date | null
    sportId: string | null
    placeId: string | null
  }

  export type PlaceSportMaxAggregateOutputType = {
    createdAt: Date | null
    sportId: string | null
    placeId: string | null
  }

  export type PlaceSportCountAggregateOutputType = {
    createdAt: number
    sportId: number
    placeId: number
    _all: number
  }


  export type PlaceSportMinAggregateInputType = {
    createdAt?: true
    sportId?: true
    placeId?: true
  }

  export type PlaceSportMaxAggregateInputType = {
    createdAt?: true
    sportId?: true
    placeId?: true
  }

  export type PlaceSportCountAggregateInputType = {
    createdAt?: true
    sportId?: true
    placeId?: true
    _all?: true
  }

  export type PlaceSportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaceSport to aggregate.
     */
    where?: PlaceSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceSports to fetch.
     */
    orderBy?: PlaceSportOrderByWithRelationInput | PlaceSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaceSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceSports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaceSports
    **/
    _count?: true | PlaceSportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaceSportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaceSportMaxAggregateInputType
  }

  export type GetPlaceSportAggregateType<T extends PlaceSportAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaceSport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaceSport[P]>
      : GetScalarType<T[P], AggregatePlaceSport[P]>
  }




  export type PlaceSportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceSportWhereInput
    orderBy?: PlaceSportOrderByWithAggregationInput | PlaceSportOrderByWithAggregationInput[]
    by: PlaceSportScalarFieldEnum[] | PlaceSportScalarFieldEnum
    having?: PlaceSportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaceSportCountAggregateInputType | true
    _min?: PlaceSportMinAggregateInputType
    _max?: PlaceSportMaxAggregateInputType
  }

  export type PlaceSportGroupByOutputType = {
    createdAt: Date
    sportId: string
    placeId: string
    _count: PlaceSportCountAggregateOutputType | null
    _min: PlaceSportMinAggregateOutputType | null
    _max: PlaceSportMaxAggregateOutputType | null
  }

  type GetPlaceSportGroupByPayload<T extends PlaceSportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaceSportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaceSportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaceSportGroupByOutputType[P]>
            : GetScalarType<T[P], PlaceSportGroupByOutputType[P]>
        }
      >
    >


  export type PlaceSportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    sportId?: boolean
    placeId?: boolean
    sport?: boolean | SportDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeSport"]>

  export type PlaceSportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    sportId?: boolean
    placeId?: boolean
    sport?: boolean | SportDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeSport"]>

  export type PlaceSportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    sportId?: boolean
    placeId?: boolean
    sport?: boolean | SportDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeSport"]>

  export type PlaceSportSelectScalar = {
    createdAt?: boolean
    sportId?: boolean
    placeId?: boolean
  }

  export type PlaceSportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "sportId" | "placeId", ExtArgs["result"]["placeSport"]>
  export type PlaceSportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sport?: boolean | SportDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }
  export type PlaceSportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sport?: boolean | SportDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }
  export type PlaceSportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sport?: boolean | SportDefaultArgs<ExtArgs>
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }

  export type $PlaceSportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaceSport"
    objects: {
      sport: Prisma.$SportPayload<ExtArgs>
      place: Prisma.$PlacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      sportId: string
      placeId: string
    }, ExtArgs["result"]["placeSport"]>
    composites: {}
  }

  type PlaceSportGetPayload<S extends boolean | null | undefined | PlaceSportDefaultArgs> = $Result.GetResult<Prisma.$PlaceSportPayload, S>

  type PlaceSportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaceSportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaceSportCountAggregateInputType | true
    }

  export interface PlaceSportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaceSport'], meta: { name: 'PlaceSport' } }
    /**
     * Find zero or one PlaceSport that matches the filter.
     * @param {PlaceSportFindUniqueArgs} args - Arguments to find a PlaceSport
     * @example
     * // Get one PlaceSport
     * const placeSport = await prisma.placeSport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaceSportFindUniqueArgs>(args: SelectSubset<T, PlaceSportFindUniqueArgs<ExtArgs>>): Prisma__PlaceSportClient<$Result.GetResult<Prisma.$PlaceSportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaceSport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaceSportFindUniqueOrThrowArgs} args - Arguments to find a PlaceSport
     * @example
     * // Get one PlaceSport
     * const placeSport = await prisma.placeSport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaceSportFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaceSportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaceSportClient<$Result.GetResult<Prisma.$PlaceSportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaceSport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceSportFindFirstArgs} args - Arguments to find a PlaceSport
     * @example
     * // Get one PlaceSport
     * const placeSport = await prisma.placeSport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaceSportFindFirstArgs>(args?: SelectSubset<T, PlaceSportFindFirstArgs<ExtArgs>>): Prisma__PlaceSportClient<$Result.GetResult<Prisma.$PlaceSportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaceSport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceSportFindFirstOrThrowArgs} args - Arguments to find a PlaceSport
     * @example
     * // Get one PlaceSport
     * const placeSport = await prisma.placeSport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaceSportFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaceSportFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaceSportClient<$Result.GetResult<Prisma.$PlaceSportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaceSports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceSportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaceSports
     * const placeSports = await prisma.placeSport.findMany()
     * 
     * // Get first 10 PlaceSports
     * const placeSports = await prisma.placeSport.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const placeSportWithCreatedAtOnly = await prisma.placeSport.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends PlaceSportFindManyArgs>(args?: SelectSubset<T, PlaceSportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceSportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaceSport.
     * @param {PlaceSportCreateArgs} args - Arguments to create a PlaceSport.
     * @example
     * // Create one PlaceSport
     * const PlaceSport = await prisma.placeSport.create({
     *   data: {
     *     // ... data to create a PlaceSport
     *   }
     * })
     * 
     */
    create<T extends PlaceSportCreateArgs>(args: SelectSubset<T, PlaceSportCreateArgs<ExtArgs>>): Prisma__PlaceSportClient<$Result.GetResult<Prisma.$PlaceSportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaceSports.
     * @param {PlaceSportCreateManyArgs} args - Arguments to create many PlaceSports.
     * @example
     * // Create many PlaceSports
     * const placeSport = await prisma.placeSport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaceSportCreateManyArgs>(args?: SelectSubset<T, PlaceSportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlaceSports and returns the data saved in the database.
     * @param {PlaceSportCreateManyAndReturnArgs} args - Arguments to create many PlaceSports.
     * @example
     * // Create many PlaceSports
     * const placeSport = await prisma.placeSport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlaceSports and only return the `createdAt`
     * const placeSportWithCreatedAtOnly = await prisma.placeSport.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaceSportCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaceSportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceSportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlaceSport.
     * @param {PlaceSportDeleteArgs} args - Arguments to delete one PlaceSport.
     * @example
     * // Delete one PlaceSport
     * const PlaceSport = await prisma.placeSport.delete({
     *   where: {
     *     // ... filter to delete one PlaceSport
     *   }
     * })
     * 
     */
    delete<T extends PlaceSportDeleteArgs>(args: SelectSubset<T, PlaceSportDeleteArgs<ExtArgs>>): Prisma__PlaceSportClient<$Result.GetResult<Prisma.$PlaceSportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaceSport.
     * @param {PlaceSportUpdateArgs} args - Arguments to update one PlaceSport.
     * @example
     * // Update one PlaceSport
     * const placeSport = await prisma.placeSport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaceSportUpdateArgs>(args: SelectSubset<T, PlaceSportUpdateArgs<ExtArgs>>): Prisma__PlaceSportClient<$Result.GetResult<Prisma.$PlaceSportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaceSports.
     * @param {PlaceSportDeleteManyArgs} args - Arguments to filter PlaceSports to delete.
     * @example
     * // Delete a few PlaceSports
     * const { count } = await prisma.placeSport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaceSportDeleteManyArgs>(args?: SelectSubset<T, PlaceSportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaceSports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceSportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaceSports
     * const placeSport = await prisma.placeSport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaceSportUpdateManyArgs>(args: SelectSubset<T, PlaceSportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaceSports and returns the data updated in the database.
     * @param {PlaceSportUpdateManyAndReturnArgs} args - Arguments to update many PlaceSports.
     * @example
     * // Update many PlaceSports
     * const placeSport = await prisma.placeSport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlaceSports and only return the `createdAt`
     * const placeSportWithCreatedAtOnly = await prisma.placeSport.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaceSportUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaceSportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceSportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlaceSport.
     * @param {PlaceSportUpsertArgs} args - Arguments to update or create a PlaceSport.
     * @example
     * // Update or create a PlaceSport
     * const placeSport = await prisma.placeSport.upsert({
     *   create: {
     *     // ... data to create a PlaceSport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaceSport we want to update
     *   }
     * })
     */
    upsert<T extends PlaceSportUpsertArgs>(args: SelectSubset<T, PlaceSportUpsertArgs<ExtArgs>>): Prisma__PlaceSportClient<$Result.GetResult<Prisma.$PlaceSportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaceSports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceSportCountArgs} args - Arguments to filter PlaceSports to count.
     * @example
     * // Count the number of PlaceSports
     * const count = await prisma.placeSport.count({
     *   where: {
     *     // ... the filter for the PlaceSports we want to count
     *   }
     * })
    **/
    count<T extends PlaceSportCountArgs>(
      args?: Subset<T, PlaceSportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaceSportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaceSport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceSportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaceSportAggregateArgs>(args: Subset<T, PlaceSportAggregateArgs>): Prisma.PrismaPromise<GetPlaceSportAggregateType<T>>

    /**
     * Group by PlaceSport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceSportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaceSportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaceSportGroupByArgs['orderBy'] }
        : { orderBy?: PlaceSportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaceSportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaceSportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaceSport model
   */
  readonly fields: PlaceSportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaceSport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaceSportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sport<T extends SportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SportDefaultArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    place<T extends PlaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceDefaultArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaceSport model
   */
  interface PlaceSportFieldRefs {
    readonly createdAt: FieldRef<"PlaceSport", 'DateTime'>
    readonly sportId: FieldRef<"PlaceSport", 'String'>
    readonly placeId: FieldRef<"PlaceSport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlaceSport findUnique
   */
  export type PlaceSportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceSport
     */
    select?: PlaceSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceSport
     */
    omit?: PlaceSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceSportInclude<ExtArgs> | null
    /**
     * Filter, which PlaceSport to fetch.
     */
    where: PlaceSportWhereUniqueInput
  }

  /**
   * PlaceSport findUniqueOrThrow
   */
  export type PlaceSportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceSport
     */
    select?: PlaceSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceSport
     */
    omit?: PlaceSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceSportInclude<ExtArgs> | null
    /**
     * Filter, which PlaceSport to fetch.
     */
    where: PlaceSportWhereUniqueInput
  }

  /**
   * PlaceSport findFirst
   */
  export type PlaceSportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceSport
     */
    select?: PlaceSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceSport
     */
    omit?: PlaceSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceSportInclude<ExtArgs> | null
    /**
     * Filter, which PlaceSport to fetch.
     */
    where?: PlaceSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceSports to fetch.
     */
    orderBy?: PlaceSportOrderByWithRelationInput | PlaceSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaceSports.
     */
    cursor?: PlaceSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceSports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaceSports.
     */
    distinct?: PlaceSportScalarFieldEnum | PlaceSportScalarFieldEnum[]
  }

  /**
   * PlaceSport findFirstOrThrow
   */
  export type PlaceSportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceSport
     */
    select?: PlaceSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceSport
     */
    omit?: PlaceSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceSportInclude<ExtArgs> | null
    /**
     * Filter, which PlaceSport to fetch.
     */
    where?: PlaceSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceSports to fetch.
     */
    orderBy?: PlaceSportOrderByWithRelationInput | PlaceSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaceSports.
     */
    cursor?: PlaceSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceSports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaceSports.
     */
    distinct?: PlaceSportScalarFieldEnum | PlaceSportScalarFieldEnum[]
  }

  /**
   * PlaceSport findMany
   */
  export type PlaceSportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceSport
     */
    select?: PlaceSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceSport
     */
    omit?: PlaceSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceSportInclude<ExtArgs> | null
    /**
     * Filter, which PlaceSports to fetch.
     */
    where?: PlaceSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceSports to fetch.
     */
    orderBy?: PlaceSportOrderByWithRelationInput | PlaceSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaceSports.
     */
    cursor?: PlaceSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceSports.
     */
    skip?: number
    distinct?: PlaceSportScalarFieldEnum | PlaceSportScalarFieldEnum[]
  }

  /**
   * PlaceSport create
   */
  export type PlaceSportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceSport
     */
    select?: PlaceSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceSport
     */
    omit?: PlaceSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceSportInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaceSport.
     */
    data: XOR<PlaceSportCreateInput, PlaceSportUncheckedCreateInput>
  }

  /**
   * PlaceSport createMany
   */
  export type PlaceSportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaceSports.
     */
    data: PlaceSportCreateManyInput | PlaceSportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlaceSport createManyAndReturn
   */
  export type PlaceSportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceSport
     */
    select?: PlaceSportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceSport
     */
    omit?: PlaceSportOmit<ExtArgs> | null
    /**
     * The data used to create many PlaceSports.
     */
    data: PlaceSportCreateManyInput | PlaceSportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceSportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaceSport update
   */
  export type PlaceSportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceSport
     */
    select?: PlaceSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceSport
     */
    omit?: PlaceSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceSportInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaceSport.
     */
    data: XOR<PlaceSportUpdateInput, PlaceSportUncheckedUpdateInput>
    /**
     * Choose, which PlaceSport to update.
     */
    where: PlaceSportWhereUniqueInput
  }

  /**
   * PlaceSport updateMany
   */
  export type PlaceSportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaceSports.
     */
    data: XOR<PlaceSportUpdateManyMutationInput, PlaceSportUncheckedUpdateManyInput>
    /**
     * Filter which PlaceSports to update
     */
    where?: PlaceSportWhereInput
    /**
     * Limit how many PlaceSports to update.
     */
    limit?: number
  }

  /**
   * PlaceSport updateManyAndReturn
   */
  export type PlaceSportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceSport
     */
    select?: PlaceSportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceSport
     */
    omit?: PlaceSportOmit<ExtArgs> | null
    /**
     * The data used to update PlaceSports.
     */
    data: XOR<PlaceSportUpdateManyMutationInput, PlaceSportUncheckedUpdateManyInput>
    /**
     * Filter which PlaceSports to update
     */
    where?: PlaceSportWhereInput
    /**
     * Limit how many PlaceSports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceSportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlaceSport upsert
   */
  export type PlaceSportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceSport
     */
    select?: PlaceSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceSport
     */
    omit?: PlaceSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceSportInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaceSport to update in case it exists.
     */
    where: PlaceSportWhereUniqueInput
    /**
     * In case the PlaceSport found by the `where` argument doesn't exist, create a new PlaceSport with this data.
     */
    create: XOR<PlaceSportCreateInput, PlaceSportUncheckedCreateInput>
    /**
     * In case the PlaceSport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaceSportUpdateInput, PlaceSportUncheckedUpdateInput>
  }

  /**
   * PlaceSport delete
   */
  export type PlaceSportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceSport
     */
    select?: PlaceSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceSport
     */
    omit?: PlaceSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceSportInclude<ExtArgs> | null
    /**
     * Filter which PlaceSport to delete.
     */
    where: PlaceSportWhereUniqueInput
  }

  /**
   * PlaceSport deleteMany
   */
  export type PlaceSportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaceSports to delete
     */
    where?: PlaceSportWhereInput
    /**
     * Limit how many PlaceSports to delete.
     */
    limit?: number
  }

  /**
   * PlaceSport without action
   */
  export type PlaceSportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceSport
     */
    select?: PlaceSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceSport
     */
    omit?: PlaceSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceSportInclude<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleAvgAggregateOutputType = {
    repeatStep: number | null
    minDurationHours: number | null
    minDurationMinutes: number | null
    maxDurationHours: number | null
    maxDurationMinutes: number | null
    timeStart: number | null
    rank: number | null
  }

  export type ScheduleSumAggregateOutputType = {
    repeatStep: number | null
    minDurationHours: number | null
    minDurationMinutes: number | null
    maxDurationHours: number | null
    maxDurationMinutes: number | null
    timeStart: number | null
    rank: number | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    placeId: string | null
    startDate: Date | null
    stopDate: Date | null
    name: string | null
    repeatMode: $Enums.CalendarRepeatMode | null
    repeatStep: number | null
    m1: boolean | null
    m2: boolean | null
    m3: boolean | null
    m4: boolean | null
    m5: boolean | null
    m6: boolean | null
    m7: boolean | null
    m8: boolean | null
    m9: boolean | null
    m10: boolean | null
    m11: boolean | null
    m12: boolean | null
    w1: boolean | null
    w2: boolean | null
    w3: boolean | null
    w4: boolean | null
    wLast: boolean | null
    wd1: boolean | null
    wd2: boolean | null
    wd3: boolean | null
    wd4: boolean | null
    wd5: boolean | null
    wd6: boolean | null
    wd7: boolean | null
    d1: boolean | null
    d2: boolean | null
    d3: boolean | null
    d4: boolean | null
    d5: boolean | null
    d6: boolean | null
    d7: boolean | null
    d8: boolean | null
    d9: boolean | null
    d10: boolean | null
    d11: boolean | null
    d12: boolean | null
    d13: boolean | null
    d14: boolean | null
    d15: boolean | null
    d16: boolean | null
    d17: boolean | null
    d18: boolean | null
    d19: boolean | null
    d20: boolean | null
    d21: boolean | null
    d22: boolean | null
    d23: boolean | null
    d24: boolean | null
    d25: boolean | null
    d26: boolean | null
    d27: boolean | null
    d28: boolean | null
    d29: boolean | null
    d30: boolean | null
    d31: boolean | null
    dLast: boolean | null
    workTimeMode: $Enums.WorkTimeMode | null
    minDurationHours: number | null
    minDurationMinutes: number | null
    maxDurationHours: number | null
    maxDurationMinutes: number | null
    timeStart: number | null
    rank: number | null
    status: $Enums.ScheduleStatus | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    placeId: string | null
    startDate: Date | null
    stopDate: Date | null
    name: string | null
    repeatMode: $Enums.CalendarRepeatMode | null
    repeatStep: number | null
    m1: boolean | null
    m2: boolean | null
    m3: boolean | null
    m4: boolean | null
    m5: boolean | null
    m6: boolean | null
    m7: boolean | null
    m8: boolean | null
    m9: boolean | null
    m10: boolean | null
    m11: boolean | null
    m12: boolean | null
    w1: boolean | null
    w2: boolean | null
    w3: boolean | null
    w4: boolean | null
    wLast: boolean | null
    wd1: boolean | null
    wd2: boolean | null
    wd3: boolean | null
    wd4: boolean | null
    wd5: boolean | null
    wd6: boolean | null
    wd7: boolean | null
    d1: boolean | null
    d2: boolean | null
    d3: boolean | null
    d4: boolean | null
    d5: boolean | null
    d6: boolean | null
    d7: boolean | null
    d8: boolean | null
    d9: boolean | null
    d10: boolean | null
    d11: boolean | null
    d12: boolean | null
    d13: boolean | null
    d14: boolean | null
    d15: boolean | null
    d16: boolean | null
    d17: boolean | null
    d18: boolean | null
    d19: boolean | null
    d20: boolean | null
    d21: boolean | null
    d22: boolean | null
    d23: boolean | null
    d24: boolean | null
    d25: boolean | null
    d26: boolean | null
    d27: boolean | null
    d28: boolean | null
    d29: boolean | null
    d30: boolean | null
    d31: boolean | null
    dLast: boolean | null
    workTimeMode: $Enums.WorkTimeMode | null
    minDurationHours: number | null
    minDurationMinutes: number | null
    maxDurationHours: number | null
    maxDurationMinutes: number | null
    timeStart: number | null
    rank: number | null
    status: $Enums.ScheduleStatus | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    placeId: number
    startDate: number
    stopDate: number
    name: number
    repeatMode: number
    repeatStep: number
    m1: number
    m2: number
    m3: number
    m4: number
    m5: number
    m6: number
    m7: number
    m8: number
    m9: number
    m10: number
    m11: number
    m12: number
    w1: number
    w2: number
    w3: number
    w4: number
    wLast: number
    wd1: number
    wd2: number
    wd3: number
    wd4: number
    wd5: number
    wd6: number
    wd7: number
    d1: number
    d2: number
    d3: number
    d4: number
    d5: number
    d6: number
    d7: number
    d8: number
    d9: number
    d10: number
    d11: number
    d12: number
    d13: number
    d14: number
    d15: number
    d16: number
    d17: number
    d18: number
    d19: number
    d20: number
    d21: number
    d22: number
    d23: number
    d24: number
    d25: number
    d26: number
    d27: number
    d28: number
    d29: number
    d30: number
    d31: number
    dLast: number
    workTimeMode: number
    minDurationHours: number
    minDurationMinutes: number
    maxDurationHours: number
    maxDurationMinutes: number
    timeStart: number
    rank: number
    status: number
    _all: number
  }


  export type ScheduleAvgAggregateInputType = {
    repeatStep?: true
    minDurationHours?: true
    minDurationMinutes?: true
    maxDurationHours?: true
    maxDurationMinutes?: true
    timeStart?: true
    rank?: true
  }

  export type ScheduleSumAggregateInputType = {
    repeatStep?: true
    minDurationHours?: true
    minDurationMinutes?: true
    maxDurationHours?: true
    maxDurationMinutes?: true
    timeStart?: true
    rank?: true
  }

  export type ScheduleMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    placeId?: true
    startDate?: true
    stopDate?: true
    name?: true
    repeatMode?: true
    repeatStep?: true
    m1?: true
    m2?: true
    m3?: true
    m4?: true
    m5?: true
    m6?: true
    m7?: true
    m8?: true
    m9?: true
    m10?: true
    m11?: true
    m12?: true
    w1?: true
    w2?: true
    w3?: true
    w4?: true
    wLast?: true
    wd1?: true
    wd2?: true
    wd3?: true
    wd4?: true
    wd5?: true
    wd6?: true
    wd7?: true
    d1?: true
    d2?: true
    d3?: true
    d4?: true
    d5?: true
    d6?: true
    d7?: true
    d8?: true
    d9?: true
    d10?: true
    d11?: true
    d12?: true
    d13?: true
    d14?: true
    d15?: true
    d16?: true
    d17?: true
    d18?: true
    d19?: true
    d20?: true
    d21?: true
    d22?: true
    d23?: true
    d24?: true
    d25?: true
    d26?: true
    d27?: true
    d28?: true
    d29?: true
    d30?: true
    d31?: true
    dLast?: true
    workTimeMode?: true
    minDurationHours?: true
    minDurationMinutes?: true
    maxDurationHours?: true
    maxDurationMinutes?: true
    timeStart?: true
    rank?: true
    status?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    placeId?: true
    startDate?: true
    stopDate?: true
    name?: true
    repeatMode?: true
    repeatStep?: true
    m1?: true
    m2?: true
    m3?: true
    m4?: true
    m5?: true
    m6?: true
    m7?: true
    m8?: true
    m9?: true
    m10?: true
    m11?: true
    m12?: true
    w1?: true
    w2?: true
    w3?: true
    w4?: true
    wLast?: true
    wd1?: true
    wd2?: true
    wd3?: true
    wd4?: true
    wd5?: true
    wd6?: true
    wd7?: true
    d1?: true
    d2?: true
    d3?: true
    d4?: true
    d5?: true
    d6?: true
    d7?: true
    d8?: true
    d9?: true
    d10?: true
    d11?: true
    d12?: true
    d13?: true
    d14?: true
    d15?: true
    d16?: true
    d17?: true
    d18?: true
    d19?: true
    d20?: true
    d21?: true
    d22?: true
    d23?: true
    d24?: true
    d25?: true
    d26?: true
    d27?: true
    d28?: true
    d29?: true
    d30?: true
    d31?: true
    dLast?: true
    workTimeMode?: true
    minDurationHours?: true
    minDurationMinutes?: true
    maxDurationHours?: true
    maxDurationMinutes?: true
    timeStart?: true
    rank?: true
    status?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    placeId?: true
    startDate?: true
    stopDate?: true
    name?: true
    repeatMode?: true
    repeatStep?: true
    m1?: true
    m2?: true
    m3?: true
    m4?: true
    m5?: true
    m6?: true
    m7?: true
    m8?: true
    m9?: true
    m10?: true
    m11?: true
    m12?: true
    w1?: true
    w2?: true
    w3?: true
    w4?: true
    wLast?: true
    wd1?: true
    wd2?: true
    wd3?: true
    wd4?: true
    wd5?: true
    wd6?: true
    wd7?: true
    d1?: true
    d2?: true
    d3?: true
    d4?: true
    d5?: true
    d6?: true
    d7?: true
    d8?: true
    d9?: true
    d10?: true
    d11?: true
    d12?: true
    d13?: true
    d14?: true
    d15?: true
    d16?: true
    d17?: true
    d18?: true
    d19?: true
    d20?: true
    d21?: true
    d22?: true
    d23?: true
    d24?: true
    d25?: true
    d26?: true
    d27?: true
    d28?: true
    d29?: true
    d30?: true
    d31?: true
    dLast?: true
    workTimeMode?: true
    minDurationHours?: true
    minDurationMinutes?: true
    maxDurationHours?: true
    maxDurationMinutes?: true
    timeStart?: true
    rank?: true
    status?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _avg?: ScheduleAvgAggregateInputType
    _sum?: ScheduleSumAggregateInputType
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    placeId: string
    startDate: Date | null
    stopDate: Date | null
    name: string
    repeatMode: $Enums.CalendarRepeatMode
    repeatStep: number
    m1: boolean | null
    m2: boolean | null
    m3: boolean | null
    m4: boolean | null
    m5: boolean | null
    m6: boolean | null
    m7: boolean | null
    m8: boolean | null
    m9: boolean | null
    m10: boolean | null
    m11: boolean | null
    m12: boolean | null
    w1: boolean | null
    w2: boolean | null
    w3: boolean | null
    w4: boolean | null
    wLast: boolean | null
    wd1: boolean | null
    wd2: boolean | null
    wd3: boolean | null
    wd4: boolean | null
    wd5: boolean | null
    wd6: boolean | null
    wd7: boolean | null
    d1: boolean | null
    d2: boolean | null
    d3: boolean | null
    d4: boolean | null
    d5: boolean | null
    d6: boolean | null
    d7: boolean | null
    d8: boolean | null
    d9: boolean | null
    d10: boolean | null
    d11: boolean | null
    d12: boolean | null
    d13: boolean | null
    d14: boolean | null
    d15: boolean | null
    d16: boolean | null
    d17: boolean | null
    d18: boolean | null
    d19: boolean | null
    d20: boolean | null
    d21: boolean | null
    d22: boolean | null
    d23: boolean | null
    d24: boolean | null
    d25: boolean | null
    d26: boolean | null
    d27: boolean | null
    d28: boolean | null
    d29: boolean | null
    d30: boolean | null
    d31: boolean | null
    dLast: boolean | null
    workTimeMode: $Enums.WorkTimeMode
    minDurationHours: number
    minDurationMinutes: number
    maxDurationHours: number
    maxDurationMinutes: number
    timeStart: number
    rank: number
    status: $Enums.ScheduleStatus
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    placeId?: boolean
    startDate?: boolean
    stopDate?: boolean
    name?: boolean
    repeatMode?: boolean
    repeatStep?: boolean
    m1?: boolean
    m2?: boolean
    m3?: boolean
    m4?: boolean
    m5?: boolean
    m6?: boolean
    m7?: boolean
    m8?: boolean
    m9?: boolean
    m10?: boolean
    m11?: boolean
    m12?: boolean
    w1?: boolean
    w2?: boolean
    w3?: boolean
    w4?: boolean
    wLast?: boolean
    wd1?: boolean
    wd2?: boolean
    wd3?: boolean
    wd4?: boolean
    wd5?: boolean
    wd6?: boolean
    wd7?: boolean
    d1?: boolean
    d2?: boolean
    d3?: boolean
    d4?: boolean
    d5?: boolean
    d6?: boolean
    d7?: boolean
    d8?: boolean
    d9?: boolean
    d10?: boolean
    d11?: boolean
    d12?: boolean
    d13?: boolean
    d14?: boolean
    d15?: boolean
    d16?: boolean
    d17?: boolean
    d18?: boolean
    d19?: boolean
    d20?: boolean
    d21?: boolean
    d22?: boolean
    d23?: boolean
    d24?: boolean
    d25?: boolean
    d26?: boolean
    d27?: boolean
    d28?: boolean
    d29?: boolean
    d30?: boolean
    d31?: boolean
    dLast?: boolean
    workTimeMode?: boolean
    minDurationHours?: boolean
    minDurationMinutes?: boolean
    maxDurationHours?: boolean
    maxDurationMinutes?: boolean
    timeStart?: boolean
    rank?: boolean
    status?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    timeSlots?: boolean | Schedule$timeSlotsArgs<ExtArgs>
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    placeId?: boolean
    startDate?: boolean
    stopDate?: boolean
    name?: boolean
    repeatMode?: boolean
    repeatStep?: boolean
    m1?: boolean
    m2?: boolean
    m3?: boolean
    m4?: boolean
    m5?: boolean
    m6?: boolean
    m7?: boolean
    m8?: boolean
    m9?: boolean
    m10?: boolean
    m11?: boolean
    m12?: boolean
    w1?: boolean
    w2?: boolean
    w3?: boolean
    w4?: boolean
    wLast?: boolean
    wd1?: boolean
    wd2?: boolean
    wd3?: boolean
    wd4?: boolean
    wd5?: boolean
    wd6?: boolean
    wd7?: boolean
    d1?: boolean
    d2?: boolean
    d3?: boolean
    d4?: boolean
    d5?: boolean
    d6?: boolean
    d7?: boolean
    d8?: boolean
    d9?: boolean
    d10?: boolean
    d11?: boolean
    d12?: boolean
    d13?: boolean
    d14?: boolean
    d15?: boolean
    d16?: boolean
    d17?: boolean
    d18?: boolean
    d19?: boolean
    d20?: boolean
    d21?: boolean
    d22?: boolean
    d23?: boolean
    d24?: boolean
    d25?: boolean
    d26?: boolean
    d27?: boolean
    d28?: boolean
    d29?: boolean
    d30?: boolean
    d31?: boolean
    dLast?: boolean
    workTimeMode?: boolean
    minDurationHours?: boolean
    minDurationMinutes?: boolean
    maxDurationHours?: boolean
    maxDurationMinutes?: boolean
    timeStart?: boolean
    rank?: boolean
    status?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    placeId?: boolean
    startDate?: boolean
    stopDate?: boolean
    name?: boolean
    repeatMode?: boolean
    repeatStep?: boolean
    m1?: boolean
    m2?: boolean
    m3?: boolean
    m4?: boolean
    m5?: boolean
    m6?: boolean
    m7?: boolean
    m8?: boolean
    m9?: boolean
    m10?: boolean
    m11?: boolean
    m12?: boolean
    w1?: boolean
    w2?: boolean
    w3?: boolean
    w4?: boolean
    wLast?: boolean
    wd1?: boolean
    wd2?: boolean
    wd3?: boolean
    wd4?: boolean
    wd5?: boolean
    wd6?: boolean
    wd7?: boolean
    d1?: boolean
    d2?: boolean
    d3?: boolean
    d4?: boolean
    d5?: boolean
    d6?: boolean
    d7?: boolean
    d8?: boolean
    d9?: boolean
    d10?: boolean
    d11?: boolean
    d12?: boolean
    d13?: boolean
    d14?: boolean
    d15?: boolean
    d16?: boolean
    d17?: boolean
    d18?: boolean
    d19?: boolean
    d20?: boolean
    d21?: boolean
    d22?: boolean
    d23?: boolean
    d24?: boolean
    d25?: boolean
    d26?: boolean
    d27?: boolean
    d28?: boolean
    d29?: boolean
    d30?: boolean
    d31?: boolean
    dLast?: boolean
    workTimeMode?: boolean
    minDurationHours?: boolean
    minDurationMinutes?: boolean
    maxDurationHours?: boolean
    maxDurationMinutes?: boolean
    timeStart?: boolean
    rank?: boolean
    status?: boolean
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    placeId?: boolean
    startDate?: boolean
    stopDate?: boolean
    name?: boolean
    repeatMode?: boolean
    repeatStep?: boolean
    m1?: boolean
    m2?: boolean
    m3?: boolean
    m4?: boolean
    m5?: boolean
    m6?: boolean
    m7?: boolean
    m8?: boolean
    m9?: boolean
    m10?: boolean
    m11?: boolean
    m12?: boolean
    w1?: boolean
    w2?: boolean
    w3?: boolean
    w4?: boolean
    wLast?: boolean
    wd1?: boolean
    wd2?: boolean
    wd3?: boolean
    wd4?: boolean
    wd5?: boolean
    wd6?: boolean
    wd7?: boolean
    d1?: boolean
    d2?: boolean
    d3?: boolean
    d4?: boolean
    d5?: boolean
    d6?: boolean
    d7?: boolean
    d8?: boolean
    d9?: boolean
    d10?: boolean
    d11?: boolean
    d12?: boolean
    d13?: boolean
    d14?: boolean
    d15?: boolean
    d16?: boolean
    d17?: boolean
    d18?: boolean
    d19?: boolean
    d20?: boolean
    d21?: boolean
    d22?: boolean
    d23?: boolean
    d24?: boolean
    d25?: boolean
    d26?: boolean
    d27?: boolean
    d28?: boolean
    d29?: boolean
    d30?: boolean
    d31?: boolean
    dLast?: boolean
    workTimeMode?: boolean
    minDurationHours?: boolean
    minDurationMinutes?: boolean
    maxDurationHours?: boolean
    maxDurationMinutes?: boolean
    timeStart?: boolean
    rank?: boolean
    status?: boolean
  }

  export type ScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "placeId" | "startDate" | "stopDate" | "name" | "repeatMode" | "repeatStep" | "m1" | "m2" | "m3" | "m4" | "m5" | "m6" | "m7" | "m8" | "m9" | "m10" | "m11" | "m12" | "w1" | "w2" | "w3" | "w4" | "wLast" | "wd1" | "wd2" | "wd3" | "wd4" | "wd5" | "wd6" | "wd7" | "d1" | "d2" | "d3" | "d4" | "d5" | "d6" | "d7" | "d8" | "d9" | "d10" | "d11" | "d12" | "d13" | "d14" | "d15" | "d16" | "d17" | "d18" | "d19" | "d20" | "d21" | "d22" | "d23" | "d24" | "d25" | "d26" | "d27" | "d28" | "d29" | "d30" | "d31" | "dLast" | "workTimeMode" | "minDurationHours" | "minDurationMinutes" | "maxDurationHours" | "maxDurationMinutes" | "timeStart" | "rank" | "status", ExtArgs["result"]["schedule"]>
  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
    timeSlots?: boolean | Schedule$timeSlotsArgs<ExtArgs>
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | PlaceDefaultArgs<ExtArgs>
  }

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      place: Prisma.$PlacePayload<ExtArgs>
      timeSlots: Prisma.$TimeSlotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      placeId: string
      startDate: Date | null
      stopDate: Date | null
      name: string
      repeatMode: $Enums.CalendarRepeatMode
      repeatStep: number
      m1: boolean | null
      m2: boolean | null
      m3: boolean | null
      m4: boolean | null
      m5: boolean | null
      m6: boolean | null
      m7: boolean | null
      m8: boolean | null
      m9: boolean | null
      m10: boolean | null
      m11: boolean | null
      m12: boolean | null
      w1: boolean | null
      w2: boolean | null
      w3: boolean | null
      w4: boolean | null
      wLast: boolean | null
      wd1: boolean | null
      wd2: boolean | null
      wd3: boolean | null
      wd4: boolean | null
      wd5: boolean | null
      wd6: boolean | null
      wd7: boolean | null
      d1: boolean | null
      d2: boolean | null
      d3: boolean | null
      d4: boolean | null
      d5: boolean | null
      d6: boolean | null
      d7: boolean | null
      d8: boolean | null
      d9: boolean | null
      d10: boolean | null
      d11: boolean | null
      d12: boolean | null
      d13: boolean | null
      d14: boolean | null
      d15: boolean | null
      d16: boolean | null
      d17: boolean | null
      d18: boolean | null
      d19: boolean | null
      d20: boolean | null
      d21: boolean | null
      d22: boolean | null
      d23: boolean | null
      d24: boolean | null
      d25: boolean | null
      d26: boolean | null
      d27: boolean | null
      d28: boolean | null
      d29: boolean | null
      d30: boolean | null
      d31: boolean | null
      dLast: boolean | null
      workTimeMode: $Enums.WorkTimeMode
      minDurationHours: number
      minDurationMinutes: number
      maxDurationHours: number
      maxDurationMinutes: number
      timeStart: number
      rank: number
      status: $Enums.ScheduleStatus
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {ScheduleCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules and returns the data updated in the database.
     * @param {ScheduleUpdateManyAndReturnArgs} args - Arguments to update many Schedules.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    place<T extends PlaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceDefaultArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    timeSlots<T extends Schedule$timeSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$timeSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'String'>
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>
    readonly placeId: FieldRef<"Schedule", 'String'>
    readonly startDate: FieldRef<"Schedule", 'DateTime'>
    readonly stopDate: FieldRef<"Schedule", 'DateTime'>
    readonly name: FieldRef<"Schedule", 'String'>
    readonly repeatMode: FieldRef<"Schedule", 'CalendarRepeatMode'>
    readonly repeatStep: FieldRef<"Schedule", 'Int'>
    readonly m1: FieldRef<"Schedule", 'Boolean'>
    readonly m2: FieldRef<"Schedule", 'Boolean'>
    readonly m3: FieldRef<"Schedule", 'Boolean'>
    readonly m4: FieldRef<"Schedule", 'Boolean'>
    readonly m5: FieldRef<"Schedule", 'Boolean'>
    readonly m6: FieldRef<"Schedule", 'Boolean'>
    readonly m7: FieldRef<"Schedule", 'Boolean'>
    readonly m8: FieldRef<"Schedule", 'Boolean'>
    readonly m9: FieldRef<"Schedule", 'Boolean'>
    readonly m10: FieldRef<"Schedule", 'Boolean'>
    readonly m11: FieldRef<"Schedule", 'Boolean'>
    readonly m12: FieldRef<"Schedule", 'Boolean'>
    readonly w1: FieldRef<"Schedule", 'Boolean'>
    readonly w2: FieldRef<"Schedule", 'Boolean'>
    readonly w3: FieldRef<"Schedule", 'Boolean'>
    readonly w4: FieldRef<"Schedule", 'Boolean'>
    readonly wLast: FieldRef<"Schedule", 'Boolean'>
    readonly wd1: FieldRef<"Schedule", 'Boolean'>
    readonly wd2: FieldRef<"Schedule", 'Boolean'>
    readonly wd3: FieldRef<"Schedule", 'Boolean'>
    readonly wd4: FieldRef<"Schedule", 'Boolean'>
    readonly wd5: FieldRef<"Schedule", 'Boolean'>
    readonly wd6: FieldRef<"Schedule", 'Boolean'>
    readonly wd7: FieldRef<"Schedule", 'Boolean'>
    readonly d1: FieldRef<"Schedule", 'Boolean'>
    readonly d2: FieldRef<"Schedule", 'Boolean'>
    readonly d3: FieldRef<"Schedule", 'Boolean'>
    readonly d4: FieldRef<"Schedule", 'Boolean'>
    readonly d5: FieldRef<"Schedule", 'Boolean'>
    readonly d6: FieldRef<"Schedule", 'Boolean'>
    readonly d7: FieldRef<"Schedule", 'Boolean'>
    readonly d8: FieldRef<"Schedule", 'Boolean'>
    readonly d9: FieldRef<"Schedule", 'Boolean'>
    readonly d10: FieldRef<"Schedule", 'Boolean'>
    readonly d11: FieldRef<"Schedule", 'Boolean'>
    readonly d12: FieldRef<"Schedule", 'Boolean'>
    readonly d13: FieldRef<"Schedule", 'Boolean'>
    readonly d14: FieldRef<"Schedule", 'Boolean'>
    readonly d15: FieldRef<"Schedule", 'Boolean'>
    readonly d16: FieldRef<"Schedule", 'Boolean'>
    readonly d17: FieldRef<"Schedule", 'Boolean'>
    readonly d18: FieldRef<"Schedule", 'Boolean'>
    readonly d19: FieldRef<"Schedule", 'Boolean'>
    readonly d20: FieldRef<"Schedule", 'Boolean'>
    readonly d21: FieldRef<"Schedule", 'Boolean'>
    readonly d22: FieldRef<"Schedule", 'Boolean'>
    readonly d23: FieldRef<"Schedule", 'Boolean'>
    readonly d24: FieldRef<"Schedule", 'Boolean'>
    readonly d25: FieldRef<"Schedule", 'Boolean'>
    readonly d26: FieldRef<"Schedule", 'Boolean'>
    readonly d27: FieldRef<"Schedule", 'Boolean'>
    readonly d28: FieldRef<"Schedule", 'Boolean'>
    readonly d29: FieldRef<"Schedule", 'Boolean'>
    readonly d30: FieldRef<"Schedule", 'Boolean'>
    readonly d31: FieldRef<"Schedule", 'Boolean'>
    readonly dLast: FieldRef<"Schedule", 'Boolean'>
    readonly workTimeMode: FieldRef<"Schedule", 'WorkTimeMode'>
    readonly minDurationHours: FieldRef<"Schedule", 'Int'>
    readonly minDurationMinutes: FieldRef<"Schedule", 'Int'>
    readonly maxDurationHours: FieldRef<"Schedule", 'Int'>
    readonly maxDurationMinutes: FieldRef<"Schedule", 'Int'>
    readonly timeStart: FieldRef<"Schedule", 'Int'>
    readonly rank: FieldRef<"Schedule", 'Int'>
    readonly status: FieldRef<"Schedule", 'ScheduleStatus'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Schedule createManyAndReturn
   */
  export type ScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedule updateManyAndReturn
   */
  export type ScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number
  }

  /**
   * Schedule.timeSlots
   */
  export type Schedule$timeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    where?: TimeSlotWhereInput
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    cursor?: TimeSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Model TimeSlot
   */

  export type AggregateTimeSlot = {
    _count: TimeSlotCountAggregateOutputType | null
    _avg: TimeSlotAvgAggregateOutputType | null
    _sum: TimeSlotSumAggregateOutputType | null
    _min: TimeSlotMinAggregateOutputType | null
    _max: TimeSlotMaxAggregateOutputType | null
  }

  export type TimeSlotAvgAggregateOutputType = {
    timeStart: number | null
    timeEnd: number | null
  }

  export type TimeSlotSumAggregateOutputType = {
    timeStart: number | null
    timeEnd: number | null
  }

  export type TimeSlotMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    timeStart: number | null
    timeEnd: number | null
    scheduleId: string | null
  }

  export type TimeSlotMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    timeStart: number | null
    timeEnd: number | null
    scheduleId: string | null
  }

  export type TimeSlotCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    timeStart: number
    timeEnd: number
    scheduleId: number
    _all: number
  }


  export type TimeSlotAvgAggregateInputType = {
    timeStart?: true
    timeEnd?: true
  }

  export type TimeSlotSumAggregateInputType = {
    timeStart?: true
    timeEnd?: true
  }

  export type TimeSlotMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    timeStart?: true
    timeEnd?: true
    scheduleId?: true
  }

  export type TimeSlotMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    timeStart?: true
    timeEnd?: true
    scheduleId?: true
  }

  export type TimeSlotCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    timeStart?: true
    timeEnd?: true
    scheduleId?: true
    _all?: true
  }

  export type TimeSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSlot to aggregate.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeSlots
    **/
    _count?: true | TimeSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeSlotMaxAggregateInputType
  }

  export type GetTimeSlotAggregateType<T extends TimeSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeSlot[P]>
      : GetScalarType<T[P], AggregateTimeSlot[P]>
  }




  export type TimeSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSlotWhereInput
    orderBy?: TimeSlotOrderByWithAggregationInput | TimeSlotOrderByWithAggregationInput[]
    by: TimeSlotScalarFieldEnum[] | TimeSlotScalarFieldEnum
    having?: TimeSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeSlotCountAggregateInputType | true
    _avg?: TimeSlotAvgAggregateInputType
    _sum?: TimeSlotSumAggregateInputType
    _min?: TimeSlotMinAggregateInputType
    _max?: TimeSlotMaxAggregateInputType
  }

  export type TimeSlotGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    timeStart: number
    timeEnd: number
    scheduleId: string
    _count: TimeSlotCountAggregateOutputType | null
    _avg: TimeSlotAvgAggregateOutputType | null
    _sum: TimeSlotSumAggregateOutputType | null
    _min: TimeSlotMinAggregateOutputType | null
    _max: TimeSlotMaxAggregateOutputType | null
  }

  type GetTimeSlotGroupByPayload<T extends TimeSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeSlotGroupByOutputType[P]>
            : GetScalarType<T[P], TimeSlotGroupByOutputType[P]>
        }
      >
    >


  export type TimeSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timeStart?: boolean
    timeEnd?: boolean
    scheduleId?: boolean
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlot"]>

  export type TimeSlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timeStart?: boolean
    timeEnd?: boolean
    scheduleId?: boolean
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlot"]>

  export type TimeSlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timeStart?: boolean
    timeEnd?: boolean
    scheduleId?: boolean
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlot"]>

  export type TimeSlotSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    timeStart?: boolean
    timeEnd?: boolean
    scheduleId?: boolean
  }

  export type TimeSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "timeStart" | "timeEnd" | "scheduleId", ExtArgs["result"]["timeSlot"]>
  export type TimeSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }
  export type TimeSlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }
  export type TimeSlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }

  export type $TimeSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeSlot"
    objects: {
      schedule: Prisma.$SchedulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      timeStart: number
      timeEnd: number
      scheduleId: string
    }, ExtArgs["result"]["timeSlot"]>
    composites: {}
  }

  type TimeSlotGetPayload<S extends boolean | null | undefined | TimeSlotDefaultArgs> = $Result.GetResult<Prisma.$TimeSlotPayload, S>

  type TimeSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimeSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeSlotCountAggregateInputType | true
    }

  export interface TimeSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeSlot'], meta: { name: 'TimeSlot' } }
    /**
     * Find zero or one TimeSlot that matches the filter.
     * @param {TimeSlotFindUniqueArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeSlotFindUniqueArgs>(args: SelectSubset<T, TimeSlotFindUniqueArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimeSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimeSlotFindUniqueOrThrowArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindFirstArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeSlotFindFirstArgs>(args?: SelectSubset<T, TimeSlotFindFirstArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindFirstOrThrowArgs} args - Arguments to find a TimeSlot
     * @example
     * // Get one TimeSlot
     * const timeSlot = await prisma.timeSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimeSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeSlots
     * const timeSlots = await prisma.timeSlot.findMany()
     * 
     * // Get first 10 TimeSlots
     * const timeSlots = await prisma.timeSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeSlotWithIdOnly = await prisma.timeSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeSlotFindManyArgs>(args?: SelectSubset<T, TimeSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimeSlot.
     * @param {TimeSlotCreateArgs} args - Arguments to create a TimeSlot.
     * @example
     * // Create one TimeSlot
     * const TimeSlot = await prisma.timeSlot.create({
     *   data: {
     *     // ... data to create a TimeSlot
     *   }
     * })
     * 
     */
    create<T extends TimeSlotCreateArgs>(args: SelectSubset<T, TimeSlotCreateArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimeSlots.
     * @param {TimeSlotCreateManyArgs} args - Arguments to create many TimeSlots.
     * @example
     * // Create many TimeSlots
     * const timeSlot = await prisma.timeSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeSlotCreateManyArgs>(args?: SelectSubset<T, TimeSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeSlots and returns the data saved in the database.
     * @param {TimeSlotCreateManyAndReturnArgs} args - Arguments to create many TimeSlots.
     * @example
     * // Create many TimeSlots
     * const timeSlot = await prisma.timeSlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeSlots and only return the `id`
     * const timeSlotWithIdOnly = await prisma.timeSlot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeSlotCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeSlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimeSlot.
     * @param {TimeSlotDeleteArgs} args - Arguments to delete one TimeSlot.
     * @example
     * // Delete one TimeSlot
     * const TimeSlot = await prisma.timeSlot.delete({
     *   where: {
     *     // ... filter to delete one TimeSlot
     *   }
     * })
     * 
     */
    delete<T extends TimeSlotDeleteArgs>(args: SelectSubset<T, TimeSlotDeleteArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimeSlot.
     * @param {TimeSlotUpdateArgs} args - Arguments to update one TimeSlot.
     * @example
     * // Update one TimeSlot
     * const timeSlot = await prisma.timeSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeSlotUpdateArgs>(args: SelectSubset<T, TimeSlotUpdateArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimeSlots.
     * @param {TimeSlotDeleteManyArgs} args - Arguments to filter TimeSlots to delete.
     * @example
     * // Delete a few TimeSlots
     * const { count } = await prisma.timeSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeSlotDeleteManyArgs>(args?: SelectSubset<T, TimeSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeSlots
     * const timeSlot = await prisma.timeSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeSlotUpdateManyArgs>(args: SelectSubset<T, TimeSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSlots and returns the data updated in the database.
     * @param {TimeSlotUpdateManyAndReturnArgs} args - Arguments to update many TimeSlots.
     * @example
     * // Update many TimeSlots
     * const timeSlot = await prisma.timeSlot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimeSlots and only return the `id`
     * const timeSlotWithIdOnly = await prisma.timeSlot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimeSlotUpdateManyAndReturnArgs>(args: SelectSubset<T, TimeSlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimeSlot.
     * @param {TimeSlotUpsertArgs} args - Arguments to update or create a TimeSlot.
     * @example
     * // Update or create a TimeSlot
     * const timeSlot = await prisma.timeSlot.upsert({
     *   create: {
     *     // ... data to create a TimeSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeSlot we want to update
     *   }
     * })
     */
    upsert<T extends TimeSlotUpsertArgs>(args: SelectSubset<T, TimeSlotUpsertArgs<ExtArgs>>): Prisma__TimeSlotClient<$Result.GetResult<Prisma.$TimeSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotCountArgs} args - Arguments to filter TimeSlots to count.
     * @example
     * // Count the number of TimeSlots
     * const count = await prisma.timeSlot.count({
     *   where: {
     *     // ... the filter for the TimeSlots we want to count
     *   }
     * })
    **/
    count<T extends TimeSlotCountArgs>(
      args?: Subset<T, TimeSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeSlotAggregateArgs>(args: Subset<T, TimeSlotAggregateArgs>): Prisma.PrismaPromise<GetTimeSlotAggregateType<T>>

    /**
     * Group by TimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeSlotGroupByArgs['orderBy'] }
        : { orderBy?: TimeSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeSlot model
   */
  readonly fields: TimeSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedule<T extends ScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleDefaultArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeSlot model
   */
  interface TimeSlotFieldRefs {
    readonly id: FieldRef<"TimeSlot", 'String'>
    readonly createdAt: FieldRef<"TimeSlot", 'DateTime'>
    readonly updatedAt: FieldRef<"TimeSlot", 'DateTime'>
    readonly timeStart: FieldRef<"TimeSlot", 'Int'>
    readonly timeEnd: FieldRef<"TimeSlot", 'Int'>
    readonly scheduleId: FieldRef<"TimeSlot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TimeSlot findUnique
   */
  export type TimeSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot findUniqueOrThrow
   */
  export type TimeSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot findFirst
   */
  export type TimeSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSlots.
     */
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot findFirstOrThrow
   */
  export type TimeSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlot to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSlots.
     */
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot findMany
   */
  export type TimeSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlots to fetch.
     */
    where?: TimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotOrderByWithRelationInput | TimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeSlots.
     */
    cursor?: TimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    distinct?: TimeSlotScalarFieldEnum | TimeSlotScalarFieldEnum[]
  }

  /**
   * TimeSlot create
   */
  export type TimeSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeSlot.
     */
    data: XOR<TimeSlotCreateInput, TimeSlotUncheckedCreateInput>
  }

  /**
   * TimeSlot createMany
   */
  export type TimeSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeSlots.
     */
    data: TimeSlotCreateManyInput | TimeSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeSlot createManyAndReturn
   */
  export type TimeSlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * The data used to create many TimeSlots.
     */
    data: TimeSlotCreateManyInput | TimeSlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSlot update
   */
  export type TimeSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeSlot.
     */
    data: XOR<TimeSlotUpdateInput, TimeSlotUncheckedUpdateInput>
    /**
     * Choose, which TimeSlot to update.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot updateMany
   */
  export type TimeSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeSlots.
     */
    data: XOR<TimeSlotUpdateManyMutationInput, TimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which TimeSlots to update
     */
    where?: TimeSlotWhereInput
    /**
     * Limit how many TimeSlots to update.
     */
    limit?: number
  }

  /**
   * TimeSlot updateManyAndReturn
   */
  export type TimeSlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * The data used to update TimeSlots.
     */
    data: XOR<TimeSlotUpdateManyMutationInput, TimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which TimeSlots to update
     */
    where?: TimeSlotWhereInput
    /**
     * Limit how many TimeSlots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSlot upsert
   */
  export type TimeSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeSlot to update in case it exists.
     */
    where: TimeSlotWhereUniqueInput
    /**
     * In case the TimeSlot found by the `where` argument doesn't exist, create a new TimeSlot with this data.
     */
    create: XOR<TimeSlotCreateInput, TimeSlotUncheckedCreateInput>
    /**
     * In case the TimeSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeSlotUpdateInput, TimeSlotUncheckedUpdateInput>
  }

  /**
   * TimeSlot delete
   */
  export type TimeSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
    /**
     * Filter which TimeSlot to delete.
     */
    where: TimeSlotWhereUniqueInput
  }

  /**
   * TimeSlot deleteMany
   */
  export type TimeSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSlots to delete
     */
    where?: TimeSlotWhereInput
    /**
     * Limit how many TimeSlots to delete.
     */
    limit?: number
  }

  /**
   * TimeSlot without action
   */
  export type TimeSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlot
     */
    select?: TimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSlot
     */
    omit?: TimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotInclude<ExtArgs> | null
  }


  /**
   * Model Sport
   */

  export type AggregateSport = {
    _count: SportCountAggregateOutputType | null
    _min: SportMinAggregateOutputType | null
    _max: SportMaxAggregateOutputType | null
  }

  export type SportMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type SportMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
  }

  export type SportCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type SportMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type SportMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type SportCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type SportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sport to aggregate.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sports
    **/
    _count?: true | SportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SportMaxAggregateInputType
  }

  export type GetSportAggregateType<T extends SportAggregateArgs> = {
        [P in keyof T & keyof AggregateSport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSport[P]>
      : GetScalarType<T[P], AggregateSport[P]>
  }




  export type SportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SportWhereInput
    orderBy?: SportOrderByWithAggregationInput | SportOrderByWithAggregationInput[]
    by: SportScalarFieldEnum[] | SportScalarFieldEnum
    having?: SportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SportCountAggregateInputType | true
    _min?: SportMinAggregateInputType
    _max?: SportMaxAggregateInputType
  }

  export type SportGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    _count: SportCountAggregateOutputType | null
    _min: SportMinAggregateOutputType | null
    _max: SportMaxAggregateOutputType | null
  }

  type GetSportGroupByPayload<T extends SportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SportGroupByOutputType[P]>
            : GetScalarType<T[P], SportGroupByOutputType[P]>
        }
      >
    >


  export type SportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    places?: boolean | Sport$placesArgs<ExtArgs>
    games?: boolean | Sport$gamesArgs<ExtArgs>
    users?: boolean | Sport$usersArgs<ExtArgs>
    _count?: boolean | SportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sport"]>

  export type SportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sport"]>

  export type SportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["sport"]>

  export type SportSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type SportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt", ExtArgs["result"]["sport"]>
  export type SportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    places?: boolean | Sport$placesArgs<ExtArgs>
    games?: boolean | Sport$gamesArgs<ExtArgs>
    users?: boolean | Sport$usersArgs<ExtArgs>
    _count?: boolean | SportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sport"
    objects: {
      places: Prisma.$PlaceSportPayload<ExtArgs>[]
      games: Prisma.$GamePayload<ExtArgs>[]
      users: Prisma.$UserSportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
    }, ExtArgs["result"]["sport"]>
    composites: {}
  }

  type SportGetPayload<S extends boolean | null | undefined | SportDefaultArgs> = $Result.GetResult<Prisma.$SportPayload, S>

  type SportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SportCountAggregateInputType | true
    }

  export interface SportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sport'], meta: { name: 'Sport' } }
    /**
     * Find zero or one Sport that matches the filter.
     * @param {SportFindUniqueArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SportFindUniqueArgs>(args: SelectSubset<T, SportFindUniqueArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SportFindUniqueOrThrowArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SportFindUniqueOrThrowArgs>(args: SelectSubset<T, SportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportFindFirstArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SportFindFirstArgs>(args?: SelectSubset<T, SportFindFirstArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportFindFirstOrThrowArgs} args - Arguments to find a Sport
     * @example
     * // Get one Sport
     * const sport = await prisma.sport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SportFindFirstOrThrowArgs>(args?: SelectSubset<T, SportFindFirstOrThrowArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sports
     * const sports = await prisma.sport.findMany()
     * 
     * // Get first 10 Sports
     * const sports = await prisma.sport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sportWithIdOnly = await prisma.sport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SportFindManyArgs>(args?: SelectSubset<T, SportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sport.
     * @param {SportCreateArgs} args - Arguments to create a Sport.
     * @example
     * // Create one Sport
     * const Sport = await prisma.sport.create({
     *   data: {
     *     // ... data to create a Sport
     *   }
     * })
     * 
     */
    create<T extends SportCreateArgs>(args: SelectSubset<T, SportCreateArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sports.
     * @param {SportCreateManyArgs} args - Arguments to create many Sports.
     * @example
     * // Create many Sports
     * const sport = await prisma.sport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SportCreateManyArgs>(args?: SelectSubset<T, SportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sports and returns the data saved in the database.
     * @param {SportCreateManyAndReturnArgs} args - Arguments to create many Sports.
     * @example
     * // Create many Sports
     * const sport = await prisma.sport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sports and only return the `id`
     * const sportWithIdOnly = await prisma.sport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SportCreateManyAndReturnArgs>(args?: SelectSubset<T, SportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sport.
     * @param {SportDeleteArgs} args - Arguments to delete one Sport.
     * @example
     * // Delete one Sport
     * const Sport = await prisma.sport.delete({
     *   where: {
     *     // ... filter to delete one Sport
     *   }
     * })
     * 
     */
    delete<T extends SportDeleteArgs>(args: SelectSubset<T, SportDeleteArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sport.
     * @param {SportUpdateArgs} args - Arguments to update one Sport.
     * @example
     * // Update one Sport
     * const sport = await prisma.sport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SportUpdateArgs>(args: SelectSubset<T, SportUpdateArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sports.
     * @param {SportDeleteManyArgs} args - Arguments to filter Sports to delete.
     * @example
     * // Delete a few Sports
     * const { count } = await prisma.sport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SportDeleteManyArgs>(args?: SelectSubset<T, SportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sports
     * const sport = await prisma.sport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SportUpdateManyArgs>(args: SelectSubset<T, SportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sports and returns the data updated in the database.
     * @param {SportUpdateManyAndReturnArgs} args - Arguments to update many Sports.
     * @example
     * // Update many Sports
     * const sport = await prisma.sport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sports and only return the `id`
     * const sportWithIdOnly = await prisma.sport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SportUpdateManyAndReturnArgs>(args: SelectSubset<T, SportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sport.
     * @param {SportUpsertArgs} args - Arguments to update or create a Sport.
     * @example
     * // Update or create a Sport
     * const sport = await prisma.sport.upsert({
     *   create: {
     *     // ... data to create a Sport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sport we want to update
     *   }
     * })
     */
    upsert<T extends SportUpsertArgs>(args: SelectSubset<T, SportUpsertArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportCountArgs} args - Arguments to filter Sports to count.
     * @example
     * // Count the number of Sports
     * const count = await prisma.sport.count({
     *   where: {
     *     // ... the filter for the Sports we want to count
     *   }
     * })
    **/
    count<T extends SportCountArgs>(
      args?: Subset<T, SportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SportAggregateArgs>(args: Subset<T, SportAggregateArgs>): Prisma.PrismaPromise<GetSportAggregateType<T>>

    /**
     * Group by Sport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SportGroupByArgs['orderBy'] }
        : { orderBy?: SportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sport model
   */
  readonly fields: SportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    places<T extends Sport$placesArgs<ExtArgs> = {}>(args?: Subset<T, Sport$placesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceSportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    games<T extends Sport$gamesArgs<ExtArgs> = {}>(args?: Subset<T, Sport$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Sport$usersArgs<ExtArgs> = {}>(args?: Subset<T, Sport$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sport model
   */
  interface SportFieldRefs {
    readonly id: FieldRef<"Sport", 'String'>
    readonly name: FieldRef<"Sport", 'String'>
    readonly createdAt: FieldRef<"Sport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sport findUnique
   */
  export type SportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where: SportWhereUniqueInput
  }

  /**
   * Sport findUniqueOrThrow
   */
  export type SportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where: SportWhereUniqueInput
  }

  /**
   * Sport findFirst
   */
  export type SportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sports.
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sports.
     */
    distinct?: SportScalarFieldEnum | SportScalarFieldEnum[]
  }

  /**
   * Sport findFirstOrThrow
   */
  export type SportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sport to fetch.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sports.
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sports.
     */
    distinct?: SportScalarFieldEnum | SportScalarFieldEnum[]
  }

  /**
   * Sport findMany
   */
  export type SportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter, which Sports to fetch.
     */
    where?: SportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sports to fetch.
     */
    orderBy?: SportOrderByWithRelationInput | SportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sports.
     */
    cursor?: SportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sports.
     */
    skip?: number
    distinct?: SportScalarFieldEnum | SportScalarFieldEnum[]
  }

  /**
   * Sport create
   */
  export type SportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * The data needed to create a Sport.
     */
    data: XOR<SportCreateInput, SportUncheckedCreateInput>
  }

  /**
   * Sport createMany
   */
  export type SportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sports.
     */
    data: SportCreateManyInput | SportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sport createManyAndReturn
   */
  export type SportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * The data used to create many Sports.
     */
    data: SportCreateManyInput | SportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sport update
   */
  export type SportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * The data needed to update a Sport.
     */
    data: XOR<SportUpdateInput, SportUncheckedUpdateInput>
    /**
     * Choose, which Sport to update.
     */
    where: SportWhereUniqueInput
  }

  /**
   * Sport updateMany
   */
  export type SportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sports.
     */
    data: XOR<SportUpdateManyMutationInput, SportUncheckedUpdateManyInput>
    /**
     * Filter which Sports to update
     */
    where?: SportWhereInput
    /**
     * Limit how many Sports to update.
     */
    limit?: number
  }

  /**
   * Sport updateManyAndReturn
   */
  export type SportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * The data used to update Sports.
     */
    data: XOR<SportUpdateManyMutationInput, SportUncheckedUpdateManyInput>
    /**
     * Filter which Sports to update
     */
    where?: SportWhereInput
    /**
     * Limit how many Sports to update.
     */
    limit?: number
  }

  /**
   * Sport upsert
   */
  export type SportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * The filter to search for the Sport to update in case it exists.
     */
    where: SportWhereUniqueInput
    /**
     * In case the Sport found by the `where` argument doesn't exist, create a new Sport with this data.
     */
    create: XOR<SportCreateInput, SportUncheckedCreateInput>
    /**
     * In case the Sport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SportUpdateInput, SportUncheckedUpdateInput>
  }

  /**
   * Sport delete
   */
  export type SportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
    /**
     * Filter which Sport to delete.
     */
    where: SportWhereUniqueInput
  }

  /**
   * Sport deleteMany
   */
  export type SportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sports to delete
     */
    where?: SportWhereInput
    /**
     * Limit how many Sports to delete.
     */
    limit?: number
  }

  /**
   * Sport.places
   */
  export type Sport$placesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceSport
     */
    select?: PlaceSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceSport
     */
    omit?: PlaceSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceSportInclude<ExtArgs> | null
    where?: PlaceSportWhereInput
    orderBy?: PlaceSportOrderByWithRelationInput | PlaceSportOrderByWithRelationInput[]
    cursor?: PlaceSportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceSportScalarFieldEnum | PlaceSportScalarFieldEnum[]
  }

  /**
   * Sport.games
   */
  export type Sport$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game
     */
    select?: GameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Game
     */
    omit?: GameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameInclude<ExtArgs> | null
    where?: GameWhereInput
    orderBy?: GameOrderByWithRelationInput | GameOrderByWithRelationInput[]
    cursor?: GameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameScalarFieldEnum | GameScalarFieldEnum[]
  }

  /**
   * Sport.users
   */
  export type Sport$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSport
     */
    select?: UserSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSport
     */
    omit?: UserSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSportInclude<ExtArgs> | null
    where?: UserSportWhereInput
    orderBy?: UserSportOrderByWithRelationInput | UserSportOrderByWithRelationInput[]
    cursor?: UserSportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSportScalarFieldEnum | UserSportScalarFieldEnum[]
  }

  /**
   * Sport without action
   */
  export type SportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sport
     */
    select?: SportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sport
     */
    omit?: SportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SportInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    idx: number | null
  }

  export type UserSumAggregateOutputType = {
    idx: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    idx: number | null
    email: string | null
    keycloakId: string | null
    telegramId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    avatar: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    idx: number | null
    email: string | null
    keycloakId: string | null
    telegramId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    username: string | null
    avatar: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    idx: number
    email: number
    keycloakId: number
    telegramId: number
    createdAt: number
    updatedAt: number
    username: number
    avatar: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    idx?: true
  }

  export type UserSumAggregateInputType = {
    idx?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    idx?: true
    email?: true
    keycloakId?: true
    telegramId?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    avatar?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    idx?: true
    email?: true
    keycloakId?: true
    telegramId?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    avatar?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    idx?: true
    email?: true
    keycloakId?: true
    telegramId?: true
    createdAt?: true
    updatedAt?: true
    username?: true
    avatar?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    idx: number
    email: string | null
    keycloakId: string
    telegramId: string | null
    createdAt: Date
    updatedAt: Date
    username: string | null
    avatar: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idx?: boolean
    email?: boolean
    keycloakId?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    avatar?: boolean
    games?: boolean | User$gamesArgs<ExtArgs>
    places?: boolean | User$placesArgs<ExtArgs>
    favoritePlaces?: boolean | User$favoritePlacesArgs<ExtArgs>
    sports?: boolean | User$sportsArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    favoritedBy?: boolean | User$favoritedByArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idx?: boolean
    email?: boolean
    keycloakId?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    avatar?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idx?: boolean
    email?: boolean
    keycloakId?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    avatar?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    idx?: boolean
    email?: boolean
    keycloakId?: boolean
    telegramId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    username?: boolean
    avatar?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "idx" | "email" | "keycloakId" | "telegramId" | "createdAt" | "updatedAt" | "username" | "avatar", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    games?: boolean | User$gamesArgs<ExtArgs>
    places?: boolean | User$placesArgs<ExtArgs>
    favoritePlaces?: boolean | User$favoritePlacesArgs<ExtArgs>
    sports?: boolean | User$sportsArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    favoritedBy?: boolean | User$favoritedByArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      games: Prisma.$GameUserPayload<ExtArgs>[]
      places: Prisma.$PlacePayload<ExtArgs>[]
      favoritePlaces: Prisma.$PlaceFavoritePayload<ExtArgs>[]
      sports: Prisma.$UserSportPayload<ExtArgs>[]
      favorites: Prisma.$UserFavoritePayload<ExtArgs>[]
      favoritedBy: Prisma.$UserFavoritePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      idx: number
      email: string | null
      keycloakId: string
      telegramId: string | null
      createdAt: Date
      updatedAt: Date
      username: string | null
      avatar: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    games<T extends User$gamesArgs<ExtArgs> = {}>(args?: Subset<T, User$gamesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GameUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    places<T extends User$placesArgs<ExtArgs> = {}>(args?: Subset<T, User$placesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favoritePlaces<T extends User$favoritePlacesArgs<ExtArgs> = {}>(args?: Subset<T, User$favoritePlacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sports<T extends User$sportsArgs<ExtArgs> = {}>(args?: Subset<T, User$sportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends User$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, User$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favoritedBy<T extends User$favoritedByArgs<ExtArgs> = {}>(args?: Subset<T, User$favoritedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly idx: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly keycloakId: FieldRef<"User", 'String'>
    readonly telegramId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly username: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.games
   */
  export type User$gamesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GameUser
     */
    select?: GameUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GameUser
     */
    omit?: GameUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GameUserInclude<ExtArgs> | null
    where?: GameUserWhereInput
    orderBy?: GameUserOrderByWithRelationInput | GameUserOrderByWithRelationInput[]
    cursor?: GameUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GameUserScalarFieldEnum | GameUserScalarFieldEnum[]
  }

  /**
   * User.places
   */
  export type User$placesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    where?: PlaceWhereInput
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    cursor?: PlaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * User.favoritePlaces
   */
  export type User$favoritePlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceFavorite
     */
    select?: PlaceFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceFavorite
     */
    omit?: PlaceFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceFavoriteInclude<ExtArgs> | null
    where?: PlaceFavoriteWhereInput
    orderBy?: PlaceFavoriteOrderByWithRelationInput | PlaceFavoriteOrderByWithRelationInput[]
    cursor?: PlaceFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceFavoriteScalarFieldEnum | PlaceFavoriteScalarFieldEnum[]
  }

  /**
   * User.sports
   */
  export type User$sportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSport
     */
    select?: UserSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSport
     */
    omit?: UserSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSportInclude<ExtArgs> | null
    where?: UserSportWhereInput
    orderBy?: UserSportOrderByWithRelationInput | UserSportOrderByWithRelationInput[]
    cursor?: UserSportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSportScalarFieldEnum | UserSportScalarFieldEnum[]
  }

  /**
   * User.favorites
   */
  export type User$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    cursor?: UserFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * User.favoritedBy
   */
  export type User$favoritedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    cursor?: UserFavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserFavorite
   */

  export type AggregateUserFavorite = {
    _count: UserFavoriteCountAggregateOutputType | null
    _min: UserFavoriteMinAggregateOutputType | null
    _max: UserFavoriteMaxAggregateOutputType | null
  }

  export type UserFavoriteMinAggregateOutputType = {
    userId: string | null
    favoriteId: string | null
    createdAt: Date | null
  }

  export type UserFavoriteMaxAggregateOutputType = {
    userId: string | null
    favoriteId: string | null
    createdAt: Date | null
  }

  export type UserFavoriteCountAggregateOutputType = {
    userId: number
    favoriteId: number
    createdAt: number
    _all: number
  }


  export type UserFavoriteMinAggregateInputType = {
    userId?: true
    favoriteId?: true
    createdAt?: true
  }

  export type UserFavoriteMaxAggregateInputType = {
    userId?: true
    favoriteId?: true
    createdAt?: true
  }

  export type UserFavoriteCountAggregateInputType = {
    userId?: true
    favoriteId?: true
    createdAt?: true
    _all?: true
  }

  export type UserFavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavorite to aggregate.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFavorites
    **/
    _count?: true | UserFavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFavoriteMaxAggregateInputType
  }

  export type GetUserFavoriteAggregateType<T extends UserFavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFavorite[P]>
      : GetScalarType<T[P], AggregateUserFavorite[P]>
  }




  export type UserFavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavoriteWhereInput
    orderBy?: UserFavoriteOrderByWithAggregationInput | UserFavoriteOrderByWithAggregationInput[]
    by: UserFavoriteScalarFieldEnum[] | UserFavoriteScalarFieldEnum
    having?: UserFavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFavoriteCountAggregateInputType | true
    _min?: UserFavoriteMinAggregateInputType
    _max?: UserFavoriteMaxAggregateInputType
  }

  export type UserFavoriteGroupByOutputType = {
    userId: string
    favoriteId: string
    createdAt: Date
    _count: UserFavoriteCountAggregateOutputType | null
    _min: UserFavoriteMinAggregateOutputType | null
    _max: UserFavoriteMaxAggregateOutputType | null
  }

  type GetUserFavoriteGroupByPayload<T extends UserFavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], UserFavoriteGroupByOutputType[P]>
        }
      >
    >


  export type UserFavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    favoriteId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    favorite?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    favoriteId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    favorite?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    favoriteId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    favorite?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorite"]>

  export type UserFavoriteSelectScalar = {
    userId?: boolean
    favoriteId?: boolean
    createdAt?: boolean
  }

  export type UserFavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "favoriteId" | "createdAt", ExtArgs["result"]["userFavorite"]>
  export type UserFavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    favorite?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    favorite?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserFavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    favorite?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserFavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFavorite"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      favorite: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      favoriteId: string
      createdAt: Date
    }, ExtArgs["result"]["userFavorite"]>
    composites: {}
  }

  type UserFavoriteGetPayload<S extends boolean | null | undefined | UserFavoriteDefaultArgs> = $Result.GetResult<Prisma.$UserFavoritePayload, S>

  type UserFavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFavoriteCountAggregateInputType | true
    }

  export interface UserFavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFavorite'], meta: { name: 'UserFavorite' } }
    /**
     * Find zero or one UserFavorite that matches the filter.
     * @param {UserFavoriteFindUniqueArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFavoriteFindUniqueArgs>(args: SelectSubset<T, UserFavoriteFindUniqueArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFavorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFavoriteFindUniqueOrThrowArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindFirstArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFavoriteFindFirstArgs>(args?: SelectSubset<T, UserFavoriteFindFirstArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindFirstOrThrowArgs} args - Arguments to find a UserFavorite
     * @example
     * // Get one UserFavorite
     * const userFavorite = await prisma.userFavorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFavorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFavorites
     * const userFavorites = await prisma.userFavorite.findMany()
     * 
     * // Get first 10 UserFavorites
     * const userFavorites = await prisma.userFavorite.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userFavoriteWithUserIdOnly = await prisma.userFavorite.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserFavoriteFindManyArgs>(args?: SelectSubset<T, UserFavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFavorite.
     * @param {UserFavoriteCreateArgs} args - Arguments to create a UserFavorite.
     * @example
     * // Create one UserFavorite
     * const UserFavorite = await prisma.userFavorite.create({
     *   data: {
     *     // ... data to create a UserFavorite
     *   }
     * })
     * 
     */
    create<T extends UserFavoriteCreateArgs>(args: SelectSubset<T, UserFavoriteCreateArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFavorites.
     * @param {UserFavoriteCreateManyArgs} args - Arguments to create many UserFavorites.
     * @example
     * // Create many UserFavorites
     * const userFavorite = await prisma.userFavorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFavoriteCreateManyArgs>(args?: SelectSubset<T, UserFavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFavorites and returns the data saved in the database.
     * @param {UserFavoriteCreateManyAndReturnArgs} args - Arguments to create many UserFavorites.
     * @example
     * // Create many UserFavorites
     * const userFavorite = await prisma.userFavorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFavorites and only return the `userId`
     * const userFavoriteWithUserIdOnly = await prisma.userFavorite.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserFavorite.
     * @param {UserFavoriteDeleteArgs} args - Arguments to delete one UserFavorite.
     * @example
     * // Delete one UserFavorite
     * const UserFavorite = await prisma.userFavorite.delete({
     *   where: {
     *     // ... filter to delete one UserFavorite
     *   }
     * })
     * 
     */
    delete<T extends UserFavoriteDeleteArgs>(args: SelectSubset<T, UserFavoriteDeleteArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFavorite.
     * @param {UserFavoriteUpdateArgs} args - Arguments to update one UserFavorite.
     * @example
     * // Update one UserFavorite
     * const userFavorite = await prisma.userFavorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFavoriteUpdateArgs>(args: SelectSubset<T, UserFavoriteUpdateArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFavorites.
     * @param {UserFavoriteDeleteManyArgs} args - Arguments to filter UserFavorites to delete.
     * @example
     * // Delete a few UserFavorites
     * const { count } = await prisma.userFavorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFavoriteDeleteManyArgs>(args?: SelectSubset<T, UserFavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFavorites
     * const userFavorite = await prisma.userFavorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFavoriteUpdateManyArgs>(args: SelectSubset<T, UserFavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavorites and returns the data updated in the database.
     * @param {UserFavoriteUpdateManyAndReturnArgs} args - Arguments to update many UserFavorites.
     * @example
     * // Update many UserFavorites
     * const userFavorite = await prisma.userFavorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserFavorites and only return the `userId`
     * const userFavoriteWithUserIdOnly = await prisma.userFavorite.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserFavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, UserFavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserFavorite.
     * @param {UserFavoriteUpsertArgs} args - Arguments to update or create a UserFavorite.
     * @example
     * // Update or create a UserFavorite
     * const userFavorite = await prisma.userFavorite.upsert({
     *   create: {
     *     // ... data to create a UserFavorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFavorite we want to update
     *   }
     * })
     */
    upsert<T extends UserFavoriteUpsertArgs>(args: SelectSubset<T, UserFavoriteUpsertArgs<ExtArgs>>): Prisma__UserFavoriteClient<$Result.GetResult<Prisma.$UserFavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFavorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteCountArgs} args - Arguments to filter UserFavorites to count.
     * @example
     * // Count the number of UserFavorites
     * const count = await prisma.userFavorite.count({
     *   where: {
     *     // ... the filter for the UserFavorites we want to count
     *   }
     * })
    **/
    count<T extends UserFavoriteCountArgs>(
      args?: Subset<T, UserFavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFavoriteAggregateArgs>(args: Subset<T, UserFavoriteAggregateArgs>): Prisma.PrismaPromise<GetUserFavoriteAggregateType<T>>

    /**
     * Group by UserFavorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFavoriteGroupByArgs['orderBy'] }
        : { orderBy?: UserFavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFavorite model
   */
  readonly fields: UserFavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFavorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    favorite<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFavorite model
   */
  interface UserFavoriteFieldRefs {
    readonly userId: FieldRef<"UserFavorite", 'String'>
    readonly favoriteId: FieldRef<"UserFavorite", 'String'>
    readonly createdAt: FieldRef<"UserFavorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFavorite findUnique
   */
  export type UserFavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite findUniqueOrThrow
   */
  export type UserFavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite findFirst
   */
  export type UserFavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavorites.
     */
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite findFirstOrThrow
   */
  export type UserFavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorite to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavorites.
     */
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite findMany
   */
  export type UserFavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorites to fetch.
     */
    where?: UserFavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorites to fetch.
     */
    orderBy?: UserFavoriteOrderByWithRelationInput | UserFavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFavorites.
     */
    cursor?: UserFavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorites.
     */
    skip?: number
    distinct?: UserFavoriteScalarFieldEnum | UserFavoriteScalarFieldEnum[]
  }

  /**
   * UserFavorite create
   */
  export type UserFavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFavorite.
     */
    data: XOR<UserFavoriteCreateInput, UserFavoriteUncheckedCreateInput>
  }

  /**
   * UserFavorite createMany
   */
  export type UserFavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFavorites.
     */
    data: UserFavoriteCreateManyInput | UserFavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFavorite createManyAndReturn
   */
  export type UserFavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many UserFavorites.
     */
    data: UserFavoriteCreateManyInput | UserFavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFavorite update
   */
  export type UserFavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFavorite.
     */
    data: XOR<UserFavoriteUpdateInput, UserFavoriteUncheckedUpdateInput>
    /**
     * Choose, which UserFavorite to update.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite updateMany
   */
  export type UserFavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFavorites.
     */
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which UserFavorites to update
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to update.
     */
    limit?: number
  }

  /**
   * UserFavorite updateManyAndReturn
   */
  export type UserFavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * The data used to update UserFavorites.
     */
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyInput>
    /**
     * Filter which UserFavorites to update
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFavorite upsert
   */
  export type UserFavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFavorite to update in case it exists.
     */
    where: UserFavoriteWhereUniqueInput
    /**
     * In case the UserFavorite found by the `where` argument doesn't exist, create a new UserFavorite with this data.
     */
    create: XOR<UserFavoriteCreateInput, UserFavoriteUncheckedCreateInput>
    /**
     * In case the UserFavorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFavoriteUpdateInput, UserFavoriteUncheckedUpdateInput>
  }

  /**
   * UserFavorite delete
   */
  export type UserFavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
    /**
     * Filter which UserFavorite to delete.
     */
    where: UserFavoriteWhereUniqueInput
  }

  /**
   * UserFavorite deleteMany
   */
  export type UserFavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavorites to delete
     */
    where?: UserFavoriteWhereInput
    /**
     * Limit how many UserFavorites to delete.
     */
    limit?: number
  }

  /**
   * UserFavorite without action
   */
  export type UserFavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorite
     */
    select?: UserFavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorite
     */
    omit?: UserFavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavoriteInclude<ExtArgs> | null
  }


  /**
   * Model UserSport
   */

  export type AggregateUserSport = {
    _count: UserSportCountAggregateOutputType | null
    _min: UserSportMinAggregateOutputType | null
    _max: UserSportMaxAggregateOutputType | null
  }

  export type UserSportMinAggregateOutputType = {
    createdAt: Date | null
    sportId: string | null
    userId: string | null
  }

  export type UserSportMaxAggregateOutputType = {
    createdAt: Date | null
    sportId: string | null
    userId: string | null
  }

  export type UserSportCountAggregateOutputType = {
    createdAt: number
    sportId: number
    userId: number
    _all: number
  }


  export type UserSportMinAggregateInputType = {
    createdAt?: true
    sportId?: true
    userId?: true
  }

  export type UserSportMaxAggregateInputType = {
    createdAt?: true
    sportId?: true
    userId?: true
  }

  export type UserSportCountAggregateInputType = {
    createdAt?: true
    sportId?: true
    userId?: true
    _all?: true
  }

  export type UserSportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSport to aggregate.
     */
    where?: UserSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSports to fetch.
     */
    orderBy?: UserSportOrderByWithRelationInput | UserSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSports
    **/
    _count?: true | UserSportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSportMaxAggregateInputType
  }

  export type GetUserSportAggregateType<T extends UserSportAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSport[P]>
      : GetScalarType<T[P], AggregateUserSport[P]>
  }




  export type UserSportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSportWhereInput
    orderBy?: UserSportOrderByWithAggregationInput | UserSportOrderByWithAggregationInput[]
    by: UserSportScalarFieldEnum[] | UserSportScalarFieldEnum
    having?: UserSportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSportCountAggregateInputType | true
    _min?: UserSportMinAggregateInputType
    _max?: UserSportMaxAggregateInputType
  }

  export type UserSportGroupByOutputType = {
    createdAt: Date
    sportId: string
    userId: string
    _count: UserSportCountAggregateOutputType | null
    _min: UserSportMinAggregateOutputType | null
    _max: UserSportMaxAggregateOutputType | null
  }

  type GetUserSportGroupByPayload<T extends UserSportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSportGroupByOutputType[P]>
            : GetScalarType<T[P], UserSportGroupByOutputType[P]>
        }
      >
    >


  export type UserSportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    sportId?: boolean
    userId?: boolean
    sport?: boolean | SportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSport"]>

  export type UserSportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    sportId?: boolean
    userId?: boolean
    sport?: boolean | SportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSport"]>

  export type UserSportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    createdAt?: boolean
    sportId?: boolean
    userId?: boolean
    sport?: boolean | SportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSport"]>

  export type UserSportSelectScalar = {
    createdAt?: boolean
    sportId?: boolean
    userId?: boolean
  }

  export type UserSportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"createdAt" | "sportId" | "userId", ExtArgs["result"]["userSport"]>
  export type UserSportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sport?: boolean | SportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sport?: boolean | SportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sport?: boolean | SportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSport"
    objects: {
      sport: Prisma.$SportPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      createdAt: Date
      sportId: string
      userId: string
    }, ExtArgs["result"]["userSport"]>
    composites: {}
  }

  type UserSportGetPayload<S extends boolean | null | undefined | UserSportDefaultArgs> = $Result.GetResult<Prisma.$UserSportPayload, S>

  type UserSportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSportCountAggregateInputType | true
    }

  export interface UserSportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSport'], meta: { name: 'UserSport' } }
    /**
     * Find zero or one UserSport that matches the filter.
     * @param {UserSportFindUniqueArgs} args - Arguments to find a UserSport
     * @example
     * // Get one UserSport
     * const userSport = await prisma.userSport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSportFindUniqueArgs>(args: SelectSubset<T, UserSportFindUniqueArgs<ExtArgs>>): Prisma__UserSportClient<$Result.GetResult<Prisma.$UserSportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSportFindUniqueOrThrowArgs} args - Arguments to find a UserSport
     * @example
     * // Get one UserSport
     * const userSport = await prisma.userSport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSportFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSportClient<$Result.GetResult<Prisma.$UserSportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSportFindFirstArgs} args - Arguments to find a UserSport
     * @example
     * // Get one UserSport
     * const userSport = await prisma.userSport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSportFindFirstArgs>(args?: SelectSubset<T, UserSportFindFirstArgs<ExtArgs>>): Prisma__UserSportClient<$Result.GetResult<Prisma.$UserSportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSportFindFirstOrThrowArgs} args - Arguments to find a UserSport
     * @example
     * // Get one UserSport
     * const userSport = await prisma.userSport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSportFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSportFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSportClient<$Result.GetResult<Prisma.$UserSportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSports
     * const userSports = await prisma.userSport.findMany()
     * 
     * // Get first 10 UserSports
     * const userSports = await prisma.userSport.findMany({ take: 10 })
     * 
     * // Only select the `createdAt`
     * const userSportWithCreatedAtOnly = await prisma.userSport.findMany({ select: { createdAt: true } })
     * 
     */
    findMany<T extends UserSportFindManyArgs>(args?: SelectSubset<T, UserSportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSport.
     * @param {UserSportCreateArgs} args - Arguments to create a UserSport.
     * @example
     * // Create one UserSport
     * const UserSport = await prisma.userSport.create({
     *   data: {
     *     // ... data to create a UserSport
     *   }
     * })
     * 
     */
    create<T extends UserSportCreateArgs>(args: SelectSubset<T, UserSportCreateArgs<ExtArgs>>): Prisma__UserSportClient<$Result.GetResult<Prisma.$UserSportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSports.
     * @param {UserSportCreateManyArgs} args - Arguments to create many UserSports.
     * @example
     * // Create many UserSports
     * const userSport = await prisma.userSport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSportCreateManyArgs>(args?: SelectSubset<T, UserSportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSports and returns the data saved in the database.
     * @param {UserSportCreateManyAndReturnArgs} args - Arguments to create many UserSports.
     * @example
     * // Create many UserSports
     * const userSport = await prisma.userSport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSports and only return the `createdAt`
     * const userSportWithCreatedAtOnly = await prisma.userSport.createManyAndReturn({
     *   select: { createdAt: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSportCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSport.
     * @param {UserSportDeleteArgs} args - Arguments to delete one UserSport.
     * @example
     * // Delete one UserSport
     * const UserSport = await prisma.userSport.delete({
     *   where: {
     *     // ... filter to delete one UserSport
     *   }
     * })
     * 
     */
    delete<T extends UserSportDeleteArgs>(args: SelectSubset<T, UserSportDeleteArgs<ExtArgs>>): Prisma__UserSportClient<$Result.GetResult<Prisma.$UserSportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSport.
     * @param {UserSportUpdateArgs} args - Arguments to update one UserSport.
     * @example
     * // Update one UserSport
     * const userSport = await prisma.userSport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSportUpdateArgs>(args: SelectSubset<T, UserSportUpdateArgs<ExtArgs>>): Prisma__UserSportClient<$Result.GetResult<Prisma.$UserSportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSports.
     * @param {UserSportDeleteManyArgs} args - Arguments to filter UserSports to delete.
     * @example
     * // Delete a few UserSports
     * const { count } = await prisma.userSport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSportDeleteManyArgs>(args?: SelectSubset<T, UserSportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSports
     * const userSport = await prisma.userSport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSportUpdateManyArgs>(args: SelectSubset<T, UserSportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSports and returns the data updated in the database.
     * @param {UserSportUpdateManyAndReturnArgs} args - Arguments to update many UserSports.
     * @example
     * // Update many UserSports
     * const userSport = await prisma.userSport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSports and only return the `createdAt`
     * const userSportWithCreatedAtOnly = await prisma.userSport.updateManyAndReturn({
     *   select: { createdAt: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSportUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSport.
     * @param {UserSportUpsertArgs} args - Arguments to update or create a UserSport.
     * @example
     * // Update or create a UserSport
     * const userSport = await prisma.userSport.upsert({
     *   create: {
     *     // ... data to create a UserSport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSport we want to update
     *   }
     * })
     */
    upsert<T extends UserSportUpsertArgs>(args: SelectSubset<T, UserSportUpsertArgs<ExtArgs>>): Prisma__UserSportClient<$Result.GetResult<Prisma.$UserSportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSportCountArgs} args - Arguments to filter UserSports to count.
     * @example
     * // Count the number of UserSports
     * const count = await prisma.userSport.count({
     *   where: {
     *     // ... the filter for the UserSports we want to count
     *   }
     * })
    **/
    count<T extends UserSportCountArgs>(
      args?: Subset<T, UserSportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSportAggregateArgs>(args: Subset<T, UserSportAggregateArgs>): Prisma.PrismaPromise<GetUserSportAggregateType<T>>

    /**
     * Group by UserSport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSportGroupByArgs['orderBy'] }
        : { orderBy?: UserSportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSport model
   */
  readonly fields: UserSportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sport<T extends SportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SportDefaultArgs<ExtArgs>>): Prisma__SportClient<$Result.GetResult<Prisma.$SportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSport model
   */
  interface UserSportFieldRefs {
    readonly createdAt: FieldRef<"UserSport", 'DateTime'>
    readonly sportId: FieldRef<"UserSport", 'String'>
    readonly userId: FieldRef<"UserSport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserSport findUnique
   */
  export type UserSportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSport
     */
    select?: UserSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSport
     */
    omit?: UserSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSportInclude<ExtArgs> | null
    /**
     * Filter, which UserSport to fetch.
     */
    where: UserSportWhereUniqueInput
  }

  /**
   * UserSport findUniqueOrThrow
   */
  export type UserSportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSport
     */
    select?: UserSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSport
     */
    omit?: UserSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSportInclude<ExtArgs> | null
    /**
     * Filter, which UserSport to fetch.
     */
    where: UserSportWhereUniqueInput
  }

  /**
   * UserSport findFirst
   */
  export type UserSportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSport
     */
    select?: UserSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSport
     */
    omit?: UserSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSportInclude<ExtArgs> | null
    /**
     * Filter, which UserSport to fetch.
     */
    where?: UserSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSports to fetch.
     */
    orderBy?: UserSportOrderByWithRelationInput | UserSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSports.
     */
    cursor?: UserSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSports.
     */
    distinct?: UserSportScalarFieldEnum | UserSportScalarFieldEnum[]
  }

  /**
   * UserSport findFirstOrThrow
   */
  export type UserSportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSport
     */
    select?: UserSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSport
     */
    omit?: UserSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSportInclude<ExtArgs> | null
    /**
     * Filter, which UserSport to fetch.
     */
    where?: UserSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSports to fetch.
     */
    orderBy?: UserSportOrderByWithRelationInput | UserSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSports.
     */
    cursor?: UserSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSports.
     */
    distinct?: UserSportScalarFieldEnum | UserSportScalarFieldEnum[]
  }

  /**
   * UserSport findMany
   */
  export type UserSportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSport
     */
    select?: UserSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSport
     */
    omit?: UserSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSportInclude<ExtArgs> | null
    /**
     * Filter, which UserSports to fetch.
     */
    where?: UserSportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSports to fetch.
     */
    orderBy?: UserSportOrderByWithRelationInput | UserSportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSports.
     */
    cursor?: UserSportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSports.
     */
    skip?: number
    distinct?: UserSportScalarFieldEnum | UserSportScalarFieldEnum[]
  }

  /**
   * UserSport create
   */
  export type UserSportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSport
     */
    select?: UserSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSport
     */
    omit?: UserSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSportInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSport.
     */
    data: XOR<UserSportCreateInput, UserSportUncheckedCreateInput>
  }

  /**
   * UserSport createMany
   */
  export type UserSportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSports.
     */
    data: UserSportCreateManyInput | UserSportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSport createManyAndReturn
   */
  export type UserSportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSport
     */
    select?: UserSportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSport
     */
    omit?: UserSportOmit<ExtArgs> | null
    /**
     * The data used to create many UserSports.
     */
    data: UserSportCreateManyInput | UserSportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSport update
   */
  export type UserSportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSport
     */
    select?: UserSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSport
     */
    omit?: UserSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSportInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSport.
     */
    data: XOR<UserSportUpdateInput, UserSportUncheckedUpdateInput>
    /**
     * Choose, which UserSport to update.
     */
    where: UserSportWhereUniqueInput
  }

  /**
   * UserSport updateMany
   */
  export type UserSportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSports.
     */
    data: XOR<UserSportUpdateManyMutationInput, UserSportUncheckedUpdateManyInput>
    /**
     * Filter which UserSports to update
     */
    where?: UserSportWhereInput
    /**
     * Limit how many UserSports to update.
     */
    limit?: number
  }

  /**
   * UserSport updateManyAndReturn
   */
  export type UserSportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSport
     */
    select?: UserSportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSport
     */
    omit?: UserSportOmit<ExtArgs> | null
    /**
     * The data used to update UserSports.
     */
    data: XOR<UserSportUpdateManyMutationInput, UserSportUncheckedUpdateManyInput>
    /**
     * Filter which UserSports to update
     */
    where?: UserSportWhereInput
    /**
     * Limit how many UserSports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSport upsert
   */
  export type UserSportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSport
     */
    select?: UserSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSport
     */
    omit?: UserSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSportInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSport to update in case it exists.
     */
    where: UserSportWhereUniqueInput
    /**
     * In case the UserSport found by the `where` argument doesn't exist, create a new UserSport with this data.
     */
    create: XOR<UserSportCreateInput, UserSportUncheckedCreateInput>
    /**
     * In case the UserSport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSportUpdateInput, UserSportUncheckedUpdateInput>
  }

  /**
   * UserSport delete
   */
  export type UserSportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSport
     */
    select?: UserSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSport
     */
    omit?: UserSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSportInclude<ExtArgs> | null
    /**
     * Filter which UserSport to delete.
     */
    where: UserSportWhereUniqueInput
  }

  /**
   * UserSport deleteMany
   */
  export type UserSportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSports to delete
     */
    where?: UserSportWhereInput
    /**
     * Limit how many UserSports to delete.
     */
    limit?: number
  }

  /**
   * UserSport without action
   */
  export type UserSportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSport
     */
    select?: UserSportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSport
     */
    omit?: UserSportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSportInclude<ExtArgs> | null
  }


  /**
   * Model UserTgLinker
   */

  export type AggregateUserTgLinker = {
    _count: UserTgLinkerCountAggregateOutputType | null
    _min: UserTgLinkerMinAggregateOutputType | null
    _max: UserTgLinkerMaxAggregateOutputType | null
  }

  export type UserTgLinkerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type UserTgLinkerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type UserTgLinkerCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    _all: number
  }


  export type UserTgLinkerMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
  }

  export type UserTgLinkerMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
  }

  export type UserTgLinkerCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type UserTgLinkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTgLinker to aggregate.
     */
    where?: UserTgLinkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTgLinkers to fetch.
     */
    orderBy?: UserTgLinkerOrderByWithRelationInput | UserTgLinkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTgLinkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTgLinkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTgLinkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTgLinkers
    **/
    _count?: true | UserTgLinkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTgLinkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTgLinkerMaxAggregateInputType
  }

  export type GetUserTgLinkerAggregateType<T extends UserTgLinkerAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTgLinker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTgLinker[P]>
      : GetScalarType<T[P], AggregateUserTgLinker[P]>
  }




  export type UserTgLinkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTgLinkerWhereInput
    orderBy?: UserTgLinkerOrderByWithAggregationInput | UserTgLinkerOrderByWithAggregationInput[]
    by: UserTgLinkerScalarFieldEnum[] | UserTgLinkerScalarFieldEnum
    having?: UserTgLinkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTgLinkerCountAggregateInputType | true
    _min?: UserTgLinkerMinAggregateInputType
    _max?: UserTgLinkerMaxAggregateInputType
  }

  export type UserTgLinkerGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    _count: UserTgLinkerCountAggregateOutputType | null
    _min: UserTgLinkerMinAggregateOutputType | null
    _max: UserTgLinkerMaxAggregateOutputType | null
  }

  type GetUserTgLinkerGroupByPayload<T extends UserTgLinkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTgLinkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTgLinkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTgLinkerGroupByOutputType[P]>
            : GetScalarType<T[P], UserTgLinkerGroupByOutputType[P]>
        }
      >
    >


  export type UserTgLinkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userTgLinker"]>

  export type UserTgLinkerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userTgLinker"]>

  export type UserTgLinkerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["userTgLinker"]>

  export type UserTgLinkerSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type UserTgLinkerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "createdAt", ExtArgs["result"]["userTgLinker"]>

  export type $UserTgLinkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTgLinker"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["userTgLinker"]>
    composites: {}
  }

  type UserTgLinkerGetPayload<S extends boolean | null | undefined | UserTgLinkerDefaultArgs> = $Result.GetResult<Prisma.$UserTgLinkerPayload, S>

  type UserTgLinkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTgLinkerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTgLinkerCountAggregateInputType | true
    }

  export interface UserTgLinkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTgLinker'], meta: { name: 'UserTgLinker' } }
    /**
     * Find zero or one UserTgLinker that matches the filter.
     * @param {UserTgLinkerFindUniqueArgs} args - Arguments to find a UserTgLinker
     * @example
     * // Get one UserTgLinker
     * const userTgLinker = await prisma.userTgLinker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTgLinkerFindUniqueArgs>(args: SelectSubset<T, UserTgLinkerFindUniqueArgs<ExtArgs>>): Prisma__UserTgLinkerClient<$Result.GetResult<Prisma.$UserTgLinkerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTgLinker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTgLinkerFindUniqueOrThrowArgs} args - Arguments to find a UserTgLinker
     * @example
     * // Get one UserTgLinker
     * const userTgLinker = await prisma.userTgLinker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTgLinkerFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTgLinkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTgLinkerClient<$Result.GetResult<Prisma.$UserTgLinkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTgLinker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTgLinkerFindFirstArgs} args - Arguments to find a UserTgLinker
     * @example
     * // Get one UserTgLinker
     * const userTgLinker = await prisma.userTgLinker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTgLinkerFindFirstArgs>(args?: SelectSubset<T, UserTgLinkerFindFirstArgs<ExtArgs>>): Prisma__UserTgLinkerClient<$Result.GetResult<Prisma.$UserTgLinkerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTgLinker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTgLinkerFindFirstOrThrowArgs} args - Arguments to find a UserTgLinker
     * @example
     * // Get one UserTgLinker
     * const userTgLinker = await prisma.userTgLinker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTgLinkerFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTgLinkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTgLinkerClient<$Result.GetResult<Prisma.$UserTgLinkerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTgLinkers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTgLinkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTgLinkers
     * const userTgLinkers = await prisma.userTgLinker.findMany()
     * 
     * // Get first 10 UserTgLinkers
     * const userTgLinkers = await prisma.userTgLinker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTgLinkerWithIdOnly = await prisma.userTgLinker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTgLinkerFindManyArgs>(args?: SelectSubset<T, UserTgLinkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTgLinkerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTgLinker.
     * @param {UserTgLinkerCreateArgs} args - Arguments to create a UserTgLinker.
     * @example
     * // Create one UserTgLinker
     * const UserTgLinker = await prisma.userTgLinker.create({
     *   data: {
     *     // ... data to create a UserTgLinker
     *   }
     * })
     * 
     */
    create<T extends UserTgLinkerCreateArgs>(args: SelectSubset<T, UserTgLinkerCreateArgs<ExtArgs>>): Prisma__UserTgLinkerClient<$Result.GetResult<Prisma.$UserTgLinkerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTgLinkers.
     * @param {UserTgLinkerCreateManyArgs} args - Arguments to create many UserTgLinkers.
     * @example
     * // Create many UserTgLinkers
     * const userTgLinker = await prisma.userTgLinker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTgLinkerCreateManyArgs>(args?: SelectSubset<T, UserTgLinkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTgLinkers and returns the data saved in the database.
     * @param {UserTgLinkerCreateManyAndReturnArgs} args - Arguments to create many UserTgLinkers.
     * @example
     * // Create many UserTgLinkers
     * const userTgLinker = await prisma.userTgLinker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTgLinkers and only return the `id`
     * const userTgLinkerWithIdOnly = await prisma.userTgLinker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTgLinkerCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTgLinkerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTgLinkerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserTgLinker.
     * @param {UserTgLinkerDeleteArgs} args - Arguments to delete one UserTgLinker.
     * @example
     * // Delete one UserTgLinker
     * const UserTgLinker = await prisma.userTgLinker.delete({
     *   where: {
     *     // ... filter to delete one UserTgLinker
     *   }
     * })
     * 
     */
    delete<T extends UserTgLinkerDeleteArgs>(args: SelectSubset<T, UserTgLinkerDeleteArgs<ExtArgs>>): Prisma__UserTgLinkerClient<$Result.GetResult<Prisma.$UserTgLinkerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTgLinker.
     * @param {UserTgLinkerUpdateArgs} args - Arguments to update one UserTgLinker.
     * @example
     * // Update one UserTgLinker
     * const userTgLinker = await prisma.userTgLinker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTgLinkerUpdateArgs>(args: SelectSubset<T, UserTgLinkerUpdateArgs<ExtArgs>>): Prisma__UserTgLinkerClient<$Result.GetResult<Prisma.$UserTgLinkerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTgLinkers.
     * @param {UserTgLinkerDeleteManyArgs} args - Arguments to filter UserTgLinkers to delete.
     * @example
     * // Delete a few UserTgLinkers
     * const { count } = await prisma.userTgLinker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTgLinkerDeleteManyArgs>(args?: SelectSubset<T, UserTgLinkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTgLinkers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTgLinkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTgLinkers
     * const userTgLinker = await prisma.userTgLinker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTgLinkerUpdateManyArgs>(args: SelectSubset<T, UserTgLinkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTgLinkers and returns the data updated in the database.
     * @param {UserTgLinkerUpdateManyAndReturnArgs} args - Arguments to update many UserTgLinkers.
     * @example
     * // Update many UserTgLinkers
     * const userTgLinker = await prisma.userTgLinker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserTgLinkers and only return the `id`
     * const userTgLinkerWithIdOnly = await prisma.userTgLinker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserTgLinkerUpdateManyAndReturnArgs>(args: SelectSubset<T, UserTgLinkerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTgLinkerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserTgLinker.
     * @param {UserTgLinkerUpsertArgs} args - Arguments to update or create a UserTgLinker.
     * @example
     * // Update or create a UserTgLinker
     * const userTgLinker = await prisma.userTgLinker.upsert({
     *   create: {
     *     // ... data to create a UserTgLinker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTgLinker we want to update
     *   }
     * })
     */
    upsert<T extends UserTgLinkerUpsertArgs>(args: SelectSubset<T, UserTgLinkerUpsertArgs<ExtArgs>>): Prisma__UserTgLinkerClient<$Result.GetResult<Prisma.$UserTgLinkerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserTgLinkers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTgLinkerCountArgs} args - Arguments to filter UserTgLinkers to count.
     * @example
     * // Count the number of UserTgLinkers
     * const count = await prisma.userTgLinker.count({
     *   where: {
     *     // ... the filter for the UserTgLinkers we want to count
     *   }
     * })
    **/
    count<T extends UserTgLinkerCountArgs>(
      args?: Subset<T, UserTgLinkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTgLinkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTgLinker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTgLinkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTgLinkerAggregateArgs>(args: Subset<T, UserTgLinkerAggregateArgs>): Prisma.PrismaPromise<GetUserTgLinkerAggregateType<T>>

    /**
     * Group by UserTgLinker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTgLinkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTgLinkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTgLinkerGroupByArgs['orderBy'] }
        : { orderBy?: UserTgLinkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTgLinkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTgLinkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTgLinker model
   */
  readonly fields: UserTgLinkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTgLinker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTgLinkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTgLinker model
   */
  interface UserTgLinkerFieldRefs {
    readonly id: FieldRef<"UserTgLinker", 'String'>
    readonly userId: FieldRef<"UserTgLinker", 'String'>
    readonly createdAt: FieldRef<"UserTgLinker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTgLinker findUnique
   */
  export type UserTgLinkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTgLinker
     */
    select?: UserTgLinkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTgLinker
     */
    omit?: UserTgLinkerOmit<ExtArgs> | null
    /**
     * Filter, which UserTgLinker to fetch.
     */
    where: UserTgLinkerWhereUniqueInput
  }

  /**
   * UserTgLinker findUniqueOrThrow
   */
  export type UserTgLinkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTgLinker
     */
    select?: UserTgLinkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTgLinker
     */
    omit?: UserTgLinkerOmit<ExtArgs> | null
    /**
     * Filter, which UserTgLinker to fetch.
     */
    where: UserTgLinkerWhereUniqueInput
  }

  /**
   * UserTgLinker findFirst
   */
  export type UserTgLinkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTgLinker
     */
    select?: UserTgLinkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTgLinker
     */
    omit?: UserTgLinkerOmit<ExtArgs> | null
    /**
     * Filter, which UserTgLinker to fetch.
     */
    where?: UserTgLinkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTgLinkers to fetch.
     */
    orderBy?: UserTgLinkerOrderByWithRelationInput | UserTgLinkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTgLinkers.
     */
    cursor?: UserTgLinkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTgLinkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTgLinkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTgLinkers.
     */
    distinct?: UserTgLinkerScalarFieldEnum | UserTgLinkerScalarFieldEnum[]
  }

  /**
   * UserTgLinker findFirstOrThrow
   */
  export type UserTgLinkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTgLinker
     */
    select?: UserTgLinkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTgLinker
     */
    omit?: UserTgLinkerOmit<ExtArgs> | null
    /**
     * Filter, which UserTgLinker to fetch.
     */
    where?: UserTgLinkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTgLinkers to fetch.
     */
    orderBy?: UserTgLinkerOrderByWithRelationInput | UserTgLinkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTgLinkers.
     */
    cursor?: UserTgLinkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTgLinkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTgLinkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTgLinkers.
     */
    distinct?: UserTgLinkerScalarFieldEnum | UserTgLinkerScalarFieldEnum[]
  }

  /**
   * UserTgLinker findMany
   */
  export type UserTgLinkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTgLinker
     */
    select?: UserTgLinkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTgLinker
     */
    omit?: UserTgLinkerOmit<ExtArgs> | null
    /**
     * Filter, which UserTgLinkers to fetch.
     */
    where?: UserTgLinkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTgLinkers to fetch.
     */
    orderBy?: UserTgLinkerOrderByWithRelationInput | UserTgLinkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTgLinkers.
     */
    cursor?: UserTgLinkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTgLinkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTgLinkers.
     */
    skip?: number
    distinct?: UserTgLinkerScalarFieldEnum | UserTgLinkerScalarFieldEnum[]
  }

  /**
   * UserTgLinker create
   */
  export type UserTgLinkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTgLinker
     */
    select?: UserTgLinkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTgLinker
     */
    omit?: UserTgLinkerOmit<ExtArgs> | null
    /**
     * The data needed to create a UserTgLinker.
     */
    data: XOR<UserTgLinkerCreateInput, UserTgLinkerUncheckedCreateInput>
  }

  /**
   * UserTgLinker createMany
   */
  export type UserTgLinkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTgLinkers.
     */
    data: UserTgLinkerCreateManyInput | UserTgLinkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTgLinker createManyAndReturn
   */
  export type UserTgLinkerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTgLinker
     */
    select?: UserTgLinkerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTgLinker
     */
    omit?: UserTgLinkerOmit<ExtArgs> | null
    /**
     * The data used to create many UserTgLinkers.
     */
    data: UserTgLinkerCreateManyInput | UserTgLinkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTgLinker update
   */
  export type UserTgLinkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTgLinker
     */
    select?: UserTgLinkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTgLinker
     */
    omit?: UserTgLinkerOmit<ExtArgs> | null
    /**
     * The data needed to update a UserTgLinker.
     */
    data: XOR<UserTgLinkerUpdateInput, UserTgLinkerUncheckedUpdateInput>
    /**
     * Choose, which UserTgLinker to update.
     */
    where: UserTgLinkerWhereUniqueInput
  }

  /**
   * UserTgLinker updateMany
   */
  export type UserTgLinkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTgLinkers.
     */
    data: XOR<UserTgLinkerUpdateManyMutationInput, UserTgLinkerUncheckedUpdateManyInput>
    /**
     * Filter which UserTgLinkers to update
     */
    where?: UserTgLinkerWhereInput
    /**
     * Limit how many UserTgLinkers to update.
     */
    limit?: number
  }

  /**
   * UserTgLinker updateManyAndReturn
   */
  export type UserTgLinkerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTgLinker
     */
    select?: UserTgLinkerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserTgLinker
     */
    omit?: UserTgLinkerOmit<ExtArgs> | null
    /**
     * The data used to update UserTgLinkers.
     */
    data: XOR<UserTgLinkerUpdateManyMutationInput, UserTgLinkerUncheckedUpdateManyInput>
    /**
     * Filter which UserTgLinkers to update
     */
    where?: UserTgLinkerWhereInput
    /**
     * Limit how many UserTgLinkers to update.
     */
    limit?: number
  }

  /**
   * UserTgLinker upsert
   */
  export type UserTgLinkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTgLinker
     */
    select?: UserTgLinkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTgLinker
     */
    omit?: UserTgLinkerOmit<ExtArgs> | null
    /**
     * The filter to search for the UserTgLinker to update in case it exists.
     */
    where: UserTgLinkerWhereUniqueInput
    /**
     * In case the UserTgLinker found by the `where` argument doesn't exist, create a new UserTgLinker with this data.
     */
    create: XOR<UserTgLinkerCreateInput, UserTgLinkerUncheckedCreateInput>
    /**
     * In case the UserTgLinker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTgLinkerUpdateInput, UserTgLinkerUncheckedUpdateInput>
  }

  /**
   * UserTgLinker delete
   */
  export type UserTgLinkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTgLinker
     */
    select?: UserTgLinkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTgLinker
     */
    omit?: UserTgLinkerOmit<ExtArgs> | null
    /**
     * Filter which UserTgLinker to delete.
     */
    where: UserTgLinkerWhereUniqueInput
  }

  /**
   * UserTgLinker deleteMany
   */
  export type UserTgLinkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTgLinkers to delete
     */
    where?: UserTgLinkerWhereInput
    /**
     * Limit how many UserTgLinkers to delete.
     */
    limit?: number
  }

  /**
   * UserTgLinker without action
   */
  export type UserTgLinkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTgLinker
     */
    select?: UserTgLinkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTgLinker
     */
    omit?: UserTgLinkerOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CityScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    region: 'region'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const GameScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    timeStart: 'timeStart',
    timeEnd: 'timeEnd',
    date: 'date',
    status: 'status',
    level: 'level',
    countMembersMin: 'countMembersMin',
    countMembersMax: 'countMembersMax',
    description: 'description',
    requestMode: 'requestMode',
    placeId: 'placeId',
    sportId: 'sportId'
  };

  export type GameScalarFieldEnum = (typeof GameScalarFieldEnum)[keyof typeof GameScalarFieldEnum]


  export const GameUserScalarFieldEnum: {
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    gameId: 'gameId',
    userId: 'userId',
    role: 'role',
    status: 'status'
  };

  export type GameUserScalarFieldEnum = (typeof GameUserScalarFieldEnum)[keyof typeof GameUserScalarFieldEnum]


  export const PlaceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    description: 'description',
    ownerId: 'ownerId',
    isIndoor: 'isIndoor',
    isFree: 'isFree',
    cityId: 'cityId',
    latitude: 'latitude',
    longitude: 'longitude'
  };

  export type PlaceScalarFieldEnum = (typeof PlaceScalarFieldEnum)[keyof typeof PlaceScalarFieldEnum]


  export const PlaceFavoriteScalarFieldEnum: {
    createdAt: 'createdAt',
    userId: 'userId',
    placeId: 'placeId'
  };

  export type PlaceFavoriteScalarFieldEnum = (typeof PlaceFavoriteScalarFieldEnum)[keyof typeof PlaceFavoriteScalarFieldEnum]


  export const PlaceCoversScalarFieldEnum: {
    id: 'id',
    order: 'order',
    placeId: 'placeId',
    createdAt: 'createdAt'
  };

  export type PlaceCoversScalarFieldEnum = (typeof PlaceCoversScalarFieldEnum)[keyof typeof PlaceCoversScalarFieldEnum]


  export const PlaceSportScalarFieldEnum: {
    createdAt: 'createdAt',
    sportId: 'sportId',
    placeId: 'placeId'
  };

  export type PlaceSportScalarFieldEnum = (typeof PlaceSportScalarFieldEnum)[keyof typeof PlaceSportScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    placeId: 'placeId',
    startDate: 'startDate',
    stopDate: 'stopDate',
    name: 'name',
    repeatMode: 'repeatMode',
    repeatStep: 'repeatStep',
    m1: 'm1',
    m2: 'm2',
    m3: 'm3',
    m4: 'm4',
    m5: 'm5',
    m6: 'm6',
    m7: 'm7',
    m8: 'm8',
    m9: 'm9',
    m10: 'm10',
    m11: 'm11',
    m12: 'm12',
    w1: 'w1',
    w2: 'w2',
    w3: 'w3',
    w4: 'w4',
    wLast: 'wLast',
    wd1: 'wd1',
    wd2: 'wd2',
    wd3: 'wd3',
    wd4: 'wd4',
    wd5: 'wd5',
    wd6: 'wd6',
    wd7: 'wd7',
    d1: 'd1',
    d2: 'd2',
    d3: 'd3',
    d4: 'd4',
    d5: 'd5',
    d6: 'd6',
    d7: 'd7',
    d8: 'd8',
    d9: 'd9',
    d10: 'd10',
    d11: 'd11',
    d12: 'd12',
    d13: 'd13',
    d14: 'd14',
    d15: 'd15',
    d16: 'd16',
    d17: 'd17',
    d18: 'd18',
    d19: 'd19',
    d20: 'd20',
    d21: 'd21',
    d22: 'd22',
    d23: 'd23',
    d24: 'd24',
    d25: 'd25',
    d26: 'd26',
    d27: 'd27',
    d28: 'd28',
    d29: 'd29',
    d30: 'd30',
    d31: 'd31',
    dLast: 'dLast',
    workTimeMode: 'workTimeMode',
    minDurationHours: 'minDurationHours',
    minDurationMinutes: 'minDurationMinutes',
    maxDurationHours: 'maxDurationHours',
    maxDurationMinutes: 'maxDurationMinutes',
    timeStart: 'timeStart',
    rank: 'rank',
    status: 'status'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const TimeSlotScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    timeStart: 'timeStart',
    timeEnd: 'timeEnd',
    scheduleId: 'scheduleId'
  };

  export type TimeSlotScalarFieldEnum = (typeof TimeSlotScalarFieldEnum)[keyof typeof TimeSlotScalarFieldEnum]


  export const SportScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type SportScalarFieldEnum = (typeof SportScalarFieldEnum)[keyof typeof SportScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    idx: 'idx',
    email: 'email',
    keycloakId: 'keycloakId',
    telegramId: 'telegramId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    username: 'username',
    avatar: 'avatar'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserFavoriteScalarFieldEnum: {
    userId: 'userId',
    favoriteId: 'favoriteId',
    createdAt: 'createdAt'
  };

  export type UserFavoriteScalarFieldEnum = (typeof UserFavoriteScalarFieldEnum)[keyof typeof UserFavoriteScalarFieldEnum]


  export const UserSportScalarFieldEnum: {
    createdAt: 'createdAt',
    sportId: 'sportId',
    userId: 'userId'
  };

  export type UserSportScalarFieldEnum = (typeof UserSportScalarFieldEnum)[keyof typeof UserSportScalarFieldEnum]


  export const UserTgLinkerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type UserTgLinkerScalarFieldEnum = (typeof UserTgLinkerScalarFieldEnum)[keyof typeof UserTgLinkerScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'GameStatus'
   */
  export type EnumGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameStatus'>
    


  /**
   * Reference to a field of type 'GameStatus[]'
   */
  export type ListEnumGameStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameStatus[]'>
    


  /**
   * Reference to a field of type 'GameLevel'
   */
  export type EnumGameLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameLevel'>
    


  /**
   * Reference to a field of type 'GameLevel[]'
   */
  export type ListEnumGameLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameLevel[]'>
    


  /**
   * Reference to a field of type 'RequestMode'
   */
  export type EnumRequestModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestMode'>
    


  /**
   * Reference to a field of type 'RequestMode[]'
   */
  export type ListEnumRequestModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestMode[]'>
    


  /**
   * Reference to a field of type 'GameUserRole'
   */
  export type EnumGameUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameUserRole'>
    


  /**
   * Reference to a field of type 'GameUserRole[]'
   */
  export type ListEnumGameUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameUserRole[]'>
    


  /**
   * Reference to a field of type 'GameUserStatus'
   */
  export type EnumGameUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameUserStatus'>
    


  /**
   * Reference to a field of type 'GameUserStatus[]'
   */
  export type ListEnumGameUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GameUserStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CalendarRepeatMode'
   */
  export type EnumCalendarRepeatModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalendarRepeatMode'>
    


  /**
   * Reference to a field of type 'CalendarRepeatMode[]'
   */
  export type ListEnumCalendarRepeatModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalendarRepeatMode[]'>
    


  /**
   * Reference to a field of type 'WorkTimeMode'
   */
  export type EnumWorkTimeModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkTimeMode'>
    


  /**
   * Reference to a field of type 'WorkTimeMode[]'
   */
  export type ListEnumWorkTimeModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkTimeMode[]'>
    


  /**
   * Reference to a field of type 'ScheduleStatus'
   */
  export type EnumScheduleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleStatus'>
    


  /**
   * Reference to a field of type 'ScheduleStatus[]'
   */
  export type ListEnumScheduleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    name?: StringFilter<"City"> | string
    region?: IntFilter<"City"> | number
    places?: PlaceListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    region?: SortOrder
    places?: PlaceOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    name?: StringFilter<"City"> | string
    region?: IntFilter<"City"> | number
    places?: PlaceListRelationFilter
  }, "id">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    region?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"City"> | string
    createdAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    name?: StringWithAggregatesFilter<"City"> | string
    region?: IntWithAggregatesFilter<"City"> | number
  }

  export type GameWhereInput = {
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    id?: StringFilter<"Game"> | string
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    timeStart?: IntFilter<"Game"> | number
    timeEnd?: IntFilter<"Game"> | number
    date?: DateTimeFilter<"Game"> | Date | string
    status?: EnumGameStatusFilter<"Game"> | $Enums.GameStatus
    level?: EnumGameLevelFilter<"Game"> | $Enums.GameLevel
    countMembersMin?: IntFilter<"Game"> | number
    countMembersMax?: IntFilter<"Game"> | number
    description?: StringNullableFilter<"Game"> | string | null
    requestMode?: EnumRequestModeFilter<"Game"> | $Enums.RequestMode
    placeId?: StringFilter<"Game"> | string
    sportId?: StringNullableFilter<"Game"> | string | null
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
    users?: GameUserListRelationFilter
    sport?: XOR<SportNullableScalarRelationFilter, SportWhereInput> | null
  }

  export type GameOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timeStart?: SortOrder
    timeEnd?: SortOrder
    date?: SortOrder
    status?: SortOrder
    level?: SortOrder
    countMembersMin?: SortOrder
    countMembersMax?: SortOrder
    description?: SortOrderInput | SortOrder
    requestMode?: SortOrder
    placeId?: SortOrder
    sportId?: SortOrderInput | SortOrder
    place?: PlaceOrderByWithRelationInput
    users?: GameUserOrderByRelationAggregateInput
    sport?: SportOrderByWithRelationInput
  }

  export type GameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GameWhereInput | GameWhereInput[]
    OR?: GameWhereInput[]
    NOT?: GameWhereInput | GameWhereInput[]
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    timeStart?: IntFilter<"Game"> | number
    timeEnd?: IntFilter<"Game"> | number
    date?: DateTimeFilter<"Game"> | Date | string
    status?: EnumGameStatusFilter<"Game"> | $Enums.GameStatus
    level?: EnumGameLevelFilter<"Game"> | $Enums.GameLevel
    countMembersMin?: IntFilter<"Game"> | number
    countMembersMax?: IntFilter<"Game"> | number
    description?: StringNullableFilter<"Game"> | string | null
    requestMode?: EnumRequestModeFilter<"Game"> | $Enums.RequestMode
    placeId?: StringFilter<"Game"> | string
    sportId?: StringNullableFilter<"Game"> | string | null
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
    users?: GameUserListRelationFilter
    sport?: XOR<SportNullableScalarRelationFilter, SportWhereInput> | null
  }, "id">

  export type GameOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timeStart?: SortOrder
    timeEnd?: SortOrder
    date?: SortOrder
    status?: SortOrder
    level?: SortOrder
    countMembersMin?: SortOrder
    countMembersMax?: SortOrder
    description?: SortOrderInput | SortOrder
    requestMode?: SortOrder
    placeId?: SortOrder
    sportId?: SortOrderInput | SortOrder
    _count?: GameCountOrderByAggregateInput
    _avg?: GameAvgOrderByAggregateInput
    _max?: GameMaxOrderByAggregateInput
    _min?: GameMinOrderByAggregateInput
    _sum?: GameSumOrderByAggregateInput
  }

  export type GameScalarWhereWithAggregatesInput = {
    AND?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    OR?: GameScalarWhereWithAggregatesInput[]
    NOT?: GameScalarWhereWithAggregatesInput | GameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Game"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    timeStart?: IntWithAggregatesFilter<"Game"> | number
    timeEnd?: IntWithAggregatesFilter<"Game"> | number
    date?: DateTimeWithAggregatesFilter<"Game"> | Date | string
    status?: EnumGameStatusWithAggregatesFilter<"Game"> | $Enums.GameStatus
    level?: EnumGameLevelWithAggregatesFilter<"Game"> | $Enums.GameLevel
    countMembersMin?: IntWithAggregatesFilter<"Game"> | number
    countMembersMax?: IntWithAggregatesFilter<"Game"> | number
    description?: StringNullableWithAggregatesFilter<"Game"> | string | null
    requestMode?: EnumRequestModeWithAggregatesFilter<"Game"> | $Enums.RequestMode
    placeId?: StringWithAggregatesFilter<"Game"> | string
    sportId?: StringNullableWithAggregatesFilter<"Game"> | string | null
  }

  export type GameUserWhereInput = {
    AND?: GameUserWhereInput | GameUserWhereInput[]
    OR?: GameUserWhereInput[]
    NOT?: GameUserWhereInput | GameUserWhereInput[]
    createdAt?: DateTimeFilter<"GameUser"> | Date | string
    updatedAt?: DateTimeFilter<"GameUser"> | Date | string
    gameId?: StringFilter<"GameUser"> | string
    userId?: StringFilter<"GameUser"> | string
    role?: EnumGameUserRoleFilter<"GameUser"> | $Enums.GameUserRole
    status?: EnumGameUserStatusFilter<"GameUser"> | $Enums.GameUserStatus
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GameUserOrderByWithRelationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    game?: GameOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type GameUserWhereUniqueInput = Prisma.AtLeast<{
    gameId_userId?: GameUserGameIdUserIdCompoundUniqueInput
    AND?: GameUserWhereInput | GameUserWhereInput[]
    OR?: GameUserWhereInput[]
    NOT?: GameUserWhereInput | GameUserWhereInput[]
    createdAt?: DateTimeFilter<"GameUser"> | Date | string
    updatedAt?: DateTimeFilter<"GameUser"> | Date | string
    gameId?: StringFilter<"GameUser"> | string
    userId?: StringFilter<"GameUser"> | string
    role?: EnumGameUserRoleFilter<"GameUser"> | $Enums.GameUserRole
    status?: EnumGameUserStatusFilter<"GameUser"> | $Enums.GameUserStatus
    game?: XOR<GameScalarRelationFilter, GameWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "gameId_userId">

  export type GameUserOrderByWithAggregationInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    _count?: GameUserCountOrderByAggregateInput
    _max?: GameUserMaxOrderByAggregateInput
    _min?: GameUserMinOrderByAggregateInput
  }

  export type GameUserScalarWhereWithAggregatesInput = {
    AND?: GameUserScalarWhereWithAggregatesInput | GameUserScalarWhereWithAggregatesInput[]
    OR?: GameUserScalarWhereWithAggregatesInput[]
    NOT?: GameUserScalarWhereWithAggregatesInput | GameUserScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"GameUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GameUser"> | Date | string
    gameId?: StringWithAggregatesFilter<"GameUser"> | string
    userId?: StringWithAggregatesFilter<"GameUser"> | string
    role?: EnumGameUserRoleWithAggregatesFilter<"GameUser"> | $Enums.GameUserRole
    status?: EnumGameUserStatusWithAggregatesFilter<"GameUser"> | $Enums.GameUserStatus
  }

  export type PlaceWhereInput = {
    AND?: PlaceWhereInput | PlaceWhereInput[]
    OR?: PlaceWhereInput[]
    NOT?: PlaceWhereInput | PlaceWhereInput[]
    id?: StringFilter<"Place"> | string
    createdAt?: DateTimeFilter<"Place"> | Date | string
    updatedAt?: DateTimeFilter<"Place"> | Date | string
    name?: StringFilter<"Place"> | string
    description?: StringFilter<"Place"> | string
    ownerId?: StringFilter<"Place"> | string
    isIndoor?: BoolNullableFilter<"Place"> | boolean | null
    isFree?: BoolNullableFilter<"Place"> | boolean | null
    cityId?: StringFilter<"Place"> | string
    latitude?: FloatFilter<"Place"> | number
    longitude?: FloatFilter<"Place"> | number
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    schedules?: ScheduleListRelationFilter
    games?: GameListRelationFilter
    covers?: PlaceCoversListRelationFilter
    sports?: PlaceSportListRelationFilter
    favoritedUsers?: PlaceFavoriteListRelationFilter
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }

  export type PlaceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    isIndoor?: SortOrderInput | SortOrder
    isFree?: SortOrderInput | SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    owner?: UserOrderByWithRelationInput
    schedules?: ScheduleOrderByRelationAggregateInput
    games?: GameOrderByRelationAggregateInput
    covers?: PlaceCoversOrderByRelationAggregateInput
    sports?: PlaceSportOrderByRelationAggregateInput
    favoritedUsers?: PlaceFavoriteOrderByRelationAggregateInput
    city?: CityOrderByWithRelationInput
  }

  export type PlaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlaceWhereInput | PlaceWhereInput[]
    OR?: PlaceWhereInput[]
    NOT?: PlaceWhereInput | PlaceWhereInput[]
    createdAt?: DateTimeFilter<"Place"> | Date | string
    updatedAt?: DateTimeFilter<"Place"> | Date | string
    name?: StringFilter<"Place"> | string
    description?: StringFilter<"Place"> | string
    ownerId?: StringFilter<"Place"> | string
    isIndoor?: BoolNullableFilter<"Place"> | boolean | null
    isFree?: BoolNullableFilter<"Place"> | boolean | null
    cityId?: StringFilter<"Place"> | string
    latitude?: FloatFilter<"Place"> | number
    longitude?: FloatFilter<"Place"> | number
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    schedules?: ScheduleListRelationFilter
    games?: GameListRelationFilter
    covers?: PlaceCoversListRelationFilter
    sports?: PlaceSportListRelationFilter
    favoritedUsers?: PlaceFavoriteListRelationFilter
    city?: XOR<CityScalarRelationFilter, CityWhereInput>
  }, "id">

  export type PlaceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    isIndoor?: SortOrderInput | SortOrder
    isFree?: SortOrderInput | SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    _count?: PlaceCountOrderByAggregateInput
    _avg?: PlaceAvgOrderByAggregateInput
    _max?: PlaceMaxOrderByAggregateInput
    _min?: PlaceMinOrderByAggregateInput
    _sum?: PlaceSumOrderByAggregateInput
  }

  export type PlaceScalarWhereWithAggregatesInput = {
    AND?: PlaceScalarWhereWithAggregatesInput | PlaceScalarWhereWithAggregatesInput[]
    OR?: PlaceScalarWhereWithAggregatesInput[]
    NOT?: PlaceScalarWhereWithAggregatesInput | PlaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Place"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Place"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Place"> | Date | string
    name?: StringWithAggregatesFilter<"Place"> | string
    description?: StringWithAggregatesFilter<"Place"> | string
    ownerId?: StringWithAggregatesFilter<"Place"> | string
    isIndoor?: BoolNullableWithAggregatesFilter<"Place"> | boolean | null
    isFree?: BoolNullableWithAggregatesFilter<"Place"> | boolean | null
    cityId?: StringWithAggregatesFilter<"Place"> | string
    latitude?: FloatWithAggregatesFilter<"Place"> | number
    longitude?: FloatWithAggregatesFilter<"Place"> | number
  }

  export type PlaceFavoriteWhereInput = {
    AND?: PlaceFavoriteWhereInput | PlaceFavoriteWhereInput[]
    OR?: PlaceFavoriteWhereInput[]
    NOT?: PlaceFavoriteWhereInput | PlaceFavoriteWhereInput[]
    createdAt?: DateTimeFilter<"PlaceFavorite"> | Date | string
    userId?: StringFilter<"PlaceFavorite"> | string
    placeId?: StringFilter<"PlaceFavorite"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
  }

  export type PlaceFavoriteOrderByWithRelationInput = {
    createdAt?: SortOrder
    userId?: SortOrder
    placeId?: SortOrder
    user?: UserOrderByWithRelationInput
    place?: PlaceOrderByWithRelationInput
  }

  export type PlaceFavoriteWhereUniqueInput = Prisma.AtLeast<{
    userId_placeId?: PlaceFavoriteUserIdPlaceIdCompoundUniqueInput
    AND?: PlaceFavoriteWhereInput | PlaceFavoriteWhereInput[]
    OR?: PlaceFavoriteWhereInput[]
    NOT?: PlaceFavoriteWhereInput | PlaceFavoriteWhereInput[]
    createdAt?: DateTimeFilter<"PlaceFavorite"> | Date | string
    userId?: StringFilter<"PlaceFavorite"> | string
    placeId?: StringFilter<"PlaceFavorite"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
  }, "userId_placeId">

  export type PlaceFavoriteOrderByWithAggregationInput = {
    createdAt?: SortOrder
    userId?: SortOrder
    placeId?: SortOrder
    _count?: PlaceFavoriteCountOrderByAggregateInput
    _max?: PlaceFavoriteMaxOrderByAggregateInput
    _min?: PlaceFavoriteMinOrderByAggregateInput
  }

  export type PlaceFavoriteScalarWhereWithAggregatesInput = {
    AND?: PlaceFavoriteScalarWhereWithAggregatesInput | PlaceFavoriteScalarWhereWithAggregatesInput[]
    OR?: PlaceFavoriteScalarWhereWithAggregatesInput[]
    NOT?: PlaceFavoriteScalarWhereWithAggregatesInput | PlaceFavoriteScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"PlaceFavorite"> | Date | string
    userId?: StringWithAggregatesFilter<"PlaceFavorite"> | string
    placeId?: StringWithAggregatesFilter<"PlaceFavorite"> | string
  }

  export type PlaceCoversWhereInput = {
    AND?: PlaceCoversWhereInput | PlaceCoversWhereInput[]
    OR?: PlaceCoversWhereInput[]
    NOT?: PlaceCoversWhereInput | PlaceCoversWhereInput[]
    id?: StringFilter<"PlaceCovers"> | string
    order?: IntFilter<"PlaceCovers"> | number
    placeId?: StringFilter<"PlaceCovers"> | string
    createdAt?: DateTimeFilter<"PlaceCovers"> | Date | string
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
  }

  export type PlaceCoversOrderByWithRelationInput = {
    id?: SortOrder
    order?: SortOrder
    placeId?: SortOrder
    createdAt?: SortOrder
    place?: PlaceOrderByWithRelationInput
  }

  export type PlaceCoversWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlaceCoversWhereInput | PlaceCoversWhereInput[]
    OR?: PlaceCoversWhereInput[]
    NOT?: PlaceCoversWhereInput | PlaceCoversWhereInput[]
    order?: IntFilter<"PlaceCovers"> | number
    placeId?: StringFilter<"PlaceCovers"> | string
    createdAt?: DateTimeFilter<"PlaceCovers"> | Date | string
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
  }, "id">

  export type PlaceCoversOrderByWithAggregationInput = {
    id?: SortOrder
    order?: SortOrder
    placeId?: SortOrder
    createdAt?: SortOrder
    _count?: PlaceCoversCountOrderByAggregateInput
    _avg?: PlaceCoversAvgOrderByAggregateInput
    _max?: PlaceCoversMaxOrderByAggregateInput
    _min?: PlaceCoversMinOrderByAggregateInput
    _sum?: PlaceCoversSumOrderByAggregateInput
  }

  export type PlaceCoversScalarWhereWithAggregatesInput = {
    AND?: PlaceCoversScalarWhereWithAggregatesInput | PlaceCoversScalarWhereWithAggregatesInput[]
    OR?: PlaceCoversScalarWhereWithAggregatesInput[]
    NOT?: PlaceCoversScalarWhereWithAggregatesInput | PlaceCoversScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlaceCovers"> | string
    order?: IntWithAggregatesFilter<"PlaceCovers"> | number
    placeId?: StringWithAggregatesFilter<"PlaceCovers"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PlaceCovers"> | Date | string
  }

  export type PlaceSportWhereInput = {
    AND?: PlaceSportWhereInput | PlaceSportWhereInput[]
    OR?: PlaceSportWhereInput[]
    NOT?: PlaceSportWhereInput | PlaceSportWhereInput[]
    createdAt?: DateTimeFilter<"PlaceSport"> | Date | string
    sportId?: StringFilter<"PlaceSport"> | string
    placeId?: StringFilter<"PlaceSport"> | string
    sport?: XOR<SportScalarRelationFilter, SportWhereInput>
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
  }

  export type PlaceSportOrderByWithRelationInput = {
    createdAt?: SortOrder
    sportId?: SortOrder
    placeId?: SortOrder
    sport?: SportOrderByWithRelationInput
    place?: PlaceOrderByWithRelationInput
  }

  export type PlaceSportWhereUniqueInput = Prisma.AtLeast<{
    sportId_placeId?: PlaceSportSportIdPlaceIdCompoundUniqueInput
    AND?: PlaceSportWhereInput | PlaceSportWhereInput[]
    OR?: PlaceSportWhereInput[]
    NOT?: PlaceSportWhereInput | PlaceSportWhereInput[]
    createdAt?: DateTimeFilter<"PlaceSport"> | Date | string
    sportId?: StringFilter<"PlaceSport"> | string
    placeId?: StringFilter<"PlaceSport"> | string
    sport?: XOR<SportScalarRelationFilter, SportWhereInput>
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
  }, "sportId_placeId">

  export type PlaceSportOrderByWithAggregationInput = {
    createdAt?: SortOrder
    sportId?: SortOrder
    placeId?: SortOrder
    _count?: PlaceSportCountOrderByAggregateInput
    _max?: PlaceSportMaxOrderByAggregateInput
    _min?: PlaceSportMinOrderByAggregateInput
  }

  export type PlaceSportScalarWhereWithAggregatesInput = {
    AND?: PlaceSportScalarWhereWithAggregatesInput | PlaceSportScalarWhereWithAggregatesInput[]
    OR?: PlaceSportScalarWhereWithAggregatesInput[]
    NOT?: PlaceSportScalarWhereWithAggregatesInput | PlaceSportScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"PlaceSport"> | Date | string
    sportId?: StringWithAggregatesFilter<"PlaceSport"> | string
    placeId?: StringWithAggregatesFilter<"PlaceSport"> | string
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: StringFilter<"Schedule"> | string
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    placeId?: StringFilter<"Schedule"> | string
    startDate?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    stopDate?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    name?: StringFilter<"Schedule"> | string
    repeatMode?: EnumCalendarRepeatModeFilter<"Schedule"> | $Enums.CalendarRepeatMode
    repeatStep?: IntFilter<"Schedule"> | number
    m1?: BoolNullableFilter<"Schedule"> | boolean | null
    m2?: BoolNullableFilter<"Schedule"> | boolean | null
    m3?: BoolNullableFilter<"Schedule"> | boolean | null
    m4?: BoolNullableFilter<"Schedule"> | boolean | null
    m5?: BoolNullableFilter<"Schedule"> | boolean | null
    m6?: BoolNullableFilter<"Schedule"> | boolean | null
    m7?: BoolNullableFilter<"Schedule"> | boolean | null
    m8?: BoolNullableFilter<"Schedule"> | boolean | null
    m9?: BoolNullableFilter<"Schedule"> | boolean | null
    m10?: BoolNullableFilter<"Schedule"> | boolean | null
    m11?: BoolNullableFilter<"Schedule"> | boolean | null
    m12?: BoolNullableFilter<"Schedule"> | boolean | null
    w1?: BoolNullableFilter<"Schedule"> | boolean | null
    w2?: BoolNullableFilter<"Schedule"> | boolean | null
    w3?: BoolNullableFilter<"Schedule"> | boolean | null
    w4?: BoolNullableFilter<"Schedule"> | boolean | null
    wLast?: BoolNullableFilter<"Schedule"> | boolean | null
    wd1?: BoolNullableFilter<"Schedule"> | boolean | null
    wd2?: BoolNullableFilter<"Schedule"> | boolean | null
    wd3?: BoolNullableFilter<"Schedule"> | boolean | null
    wd4?: BoolNullableFilter<"Schedule"> | boolean | null
    wd5?: BoolNullableFilter<"Schedule"> | boolean | null
    wd6?: BoolNullableFilter<"Schedule"> | boolean | null
    wd7?: BoolNullableFilter<"Schedule"> | boolean | null
    d1?: BoolNullableFilter<"Schedule"> | boolean | null
    d2?: BoolNullableFilter<"Schedule"> | boolean | null
    d3?: BoolNullableFilter<"Schedule"> | boolean | null
    d4?: BoolNullableFilter<"Schedule"> | boolean | null
    d5?: BoolNullableFilter<"Schedule"> | boolean | null
    d6?: BoolNullableFilter<"Schedule"> | boolean | null
    d7?: BoolNullableFilter<"Schedule"> | boolean | null
    d8?: BoolNullableFilter<"Schedule"> | boolean | null
    d9?: BoolNullableFilter<"Schedule"> | boolean | null
    d10?: BoolNullableFilter<"Schedule"> | boolean | null
    d11?: BoolNullableFilter<"Schedule"> | boolean | null
    d12?: BoolNullableFilter<"Schedule"> | boolean | null
    d13?: BoolNullableFilter<"Schedule"> | boolean | null
    d14?: BoolNullableFilter<"Schedule"> | boolean | null
    d15?: BoolNullableFilter<"Schedule"> | boolean | null
    d16?: BoolNullableFilter<"Schedule"> | boolean | null
    d17?: BoolNullableFilter<"Schedule"> | boolean | null
    d18?: BoolNullableFilter<"Schedule"> | boolean | null
    d19?: BoolNullableFilter<"Schedule"> | boolean | null
    d20?: BoolNullableFilter<"Schedule"> | boolean | null
    d21?: BoolNullableFilter<"Schedule"> | boolean | null
    d22?: BoolNullableFilter<"Schedule"> | boolean | null
    d23?: BoolNullableFilter<"Schedule"> | boolean | null
    d24?: BoolNullableFilter<"Schedule"> | boolean | null
    d25?: BoolNullableFilter<"Schedule"> | boolean | null
    d26?: BoolNullableFilter<"Schedule"> | boolean | null
    d27?: BoolNullableFilter<"Schedule"> | boolean | null
    d28?: BoolNullableFilter<"Schedule"> | boolean | null
    d29?: BoolNullableFilter<"Schedule"> | boolean | null
    d30?: BoolNullableFilter<"Schedule"> | boolean | null
    d31?: BoolNullableFilter<"Schedule"> | boolean | null
    dLast?: BoolNullableFilter<"Schedule"> | boolean | null
    workTimeMode?: EnumWorkTimeModeFilter<"Schedule"> | $Enums.WorkTimeMode
    minDurationHours?: IntFilter<"Schedule"> | number
    minDurationMinutes?: IntFilter<"Schedule"> | number
    maxDurationHours?: IntFilter<"Schedule"> | number
    maxDurationMinutes?: IntFilter<"Schedule"> | number
    timeStart?: IntFilter<"Schedule"> | number
    rank?: IntFilter<"Schedule"> | number
    status?: EnumScheduleStatusFilter<"Schedule"> | $Enums.ScheduleStatus
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
    timeSlots?: TimeSlotListRelationFilter
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    placeId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    stopDate?: SortOrderInput | SortOrder
    name?: SortOrder
    repeatMode?: SortOrder
    repeatStep?: SortOrder
    m1?: SortOrderInput | SortOrder
    m2?: SortOrderInput | SortOrder
    m3?: SortOrderInput | SortOrder
    m4?: SortOrderInput | SortOrder
    m5?: SortOrderInput | SortOrder
    m6?: SortOrderInput | SortOrder
    m7?: SortOrderInput | SortOrder
    m8?: SortOrderInput | SortOrder
    m9?: SortOrderInput | SortOrder
    m10?: SortOrderInput | SortOrder
    m11?: SortOrderInput | SortOrder
    m12?: SortOrderInput | SortOrder
    w1?: SortOrderInput | SortOrder
    w2?: SortOrderInput | SortOrder
    w3?: SortOrderInput | SortOrder
    w4?: SortOrderInput | SortOrder
    wLast?: SortOrderInput | SortOrder
    wd1?: SortOrderInput | SortOrder
    wd2?: SortOrderInput | SortOrder
    wd3?: SortOrderInput | SortOrder
    wd4?: SortOrderInput | SortOrder
    wd5?: SortOrderInput | SortOrder
    wd6?: SortOrderInput | SortOrder
    wd7?: SortOrderInput | SortOrder
    d1?: SortOrderInput | SortOrder
    d2?: SortOrderInput | SortOrder
    d3?: SortOrderInput | SortOrder
    d4?: SortOrderInput | SortOrder
    d5?: SortOrderInput | SortOrder
    d6?: SortOrderInput | SortOrder
    d7?: SortOrderInput | SortOrder
    d8?: SortOrderInput | SortOrder
    d9?: SortOrderInput | SortOrder
    d10?: SortOrderInput | SortOrder
    d11?: SortOrderInput | SortOrder
    d12?: SortOrderInput | SortOrder
    d13?: SortOrderInput | SortOrder
    d14?: SortOrderInput | SortOrder
    d15?: SortOrderInput | SortOrder
    d16?: SortOrderInput | SortOrder
    d17?: SortOrderInput | SortOrder
    d18?: SortOrderInput | SortOrder
    d19?: SortOrderInput | SortOrder
    d20?: SortOrderInput | SortOrder
    d21?: SortOrderInput | SortOrder
    d22?: SortOrderInput | SortOrder
    d23?: SortOrderInput | SortOrder
    d24?: SortOrderInput | SortOrder
    d25?: SortOrderInput | SortOrder
    d26?: SortOrderInput | SortOrder
    d27?: SortOrderInput | SortOrder
    d28?: SortOrderInput | SortOrder
    d29?: SortOrderInput | SortOrder
    d30?: SortOrderInput | SortOrder
    d31?: SortOrderInput | SortOrder
    dLast?: SortOrderInput | SortOrder
    workTimeMode?: SortOrder
    minDurationHours?: SortOrder
    minDurationMinutes?: SortOrder
    maxDurationHours?: SortOrder
    maxDurationMinutes?: SortOrder
    timeStart?: SortOrder
    rank?: SortOrder
    status?: SortOrder
    place?: PlaceOrderByWithRelationInput
    timeSlots?: TimeSlotOrderByRelationAggregateInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    placeId?: StringFilter<"Schedule"> | string
    startDate?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    stopDate?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    name?: StringFilter<"Schedule"> | string
    repeatMode?: EnumCalendarRepeatModeFilter<"Schedule"> | $Enums.CalendarRepeatMode
    repeatStep?: IntFilter<"Schedule"> | number
    m1?: BoolNullableFilter<"Schedule"> | boolean | null
    m2?: BoolNullableFilter<"Schedule"> | boolean | null
    m3?: BoolNullableFilter<"Schedule"> | boolean | null
    m4?: BoolNullableFilter<"Schedule"> | boolean | null
    m5?: BoolNullableFilter<"Schedule"> | boolean | null
    m6?: BoolNullableFilter<"Schedule"> | boolean | null
    m7?: BoolNullableFilter<"Schedule"> | boolean | null
    m8?: BoolNullableFilter<"Schedule"> | boolean | null
    m9?: BoolNullableFilter<"Schedule"> | boolean | null
    m10?: BoolNullableFilter<"Schedule"> | boolean | null
    m11?: BoolNullableFilter<"Schedule"> | boolean | null
    m12?: BoolNullableFilter<"Schedule"> | boolean | null
    w1?: BoolNullableFilter<"Schedule"> | boolean | null
    w2?: BoolNullableFilter<"Schedule"> | boolean | null
    w3?: BoolNullableFilter<"Schedule"> | boolean | null
    w4?: BoolNullableFilter<"Schedule"> | boolean | null
    wLast?: BoolNullableFilter<"Schedule"> | boolean | null
    wd1?: BoolNullableFilter<"Schedule"> | boolean | null
    wd2?: BoolNullableFilter<"Schedule"> | boolean | null
    wd3?: BoolNullableFilter<"Schedule"> | boolean | null
    wd4?: BoolNullableFilter<"Schedule"> | boolean | null
    wd5?: BoolNullableFilter<"Schedule"> | boolean | null
    wd6?: BoolNullableFilter<"Schedule"> | boolean | null
    wd7?: BoolNullableFilter<"Schedule"> | boolean | null
    d1?: BoolNullableFilter<"Schedule"> | boolean | null
    d2?: BoolNullableFilter<"Schedule"> | boolean | null
    d3?: BoolNullableFilter<"Schedule"> | boolean | null
    d4?: BoolNullableFilter<"Schedule"> | boolean | null
    d5?: BoolNullableFilter<"Schedule"> | boolean | null
    d6?: BoolNullableFilter<"Schedule"> | boolean | null
    d7?: BoolNullableFilter<"Schedule"> | boolean | null
    d8?: BoolNullableFilter<"Schedule"> | boolean | null
    d9?: BoolNullableFilter<"Schedule"> | boolean | null
    d10?: BoolNullableFilter<"Schedule"> | boolean | null
    d11?: BoolNullableFilter<"Schedule"> | boolean | null
    d12?: BoolNullableFilter<"Schedule"> | boolean | null
    d13?: BoolNullableFilter<"Schedule"> | boolean | null
    d14?: BoolNullableFilter<"Schedule"> | boolean | null
    d15?: BoolNullableFilter<"Schedule"> | boolean | null
    d16?: BoolNullableFilter<"Schedule"> | boolean | null
    d17?: BoolNullableFilter<"Schedule"> | boolean | null
    d18?: BoolNullableFilter<"Schedule"> | boolean | null
    d19?: BoolNullableFilter<"Schedule"> | boolean | null
    d20?: BoolNullableFilter<"Schedule"> | boolean | null
    d21?: BoolNullableFilter<"Schedule"> | boolean | null
    d22?: BoolNullableFilter<"Schedule"> | boolean | null
    d23?: BoolNullableFilter<"Schedule"> | boolean | null
    d24?: BoolNullableFilter<"Schedule"> | boolean | null
    d25?: BoolNullableFilter<"Schedule"> | boolean | null
    d26?: BoolNullableFilter<"Schedule"> | boolean | null
    d27?: BoolNullableFilter<"Schedule"> | boolean | null
    d28?: BoolNullableFilter<"Schedule"> | boolean | null
    d29?: BoolNullableFilter<"Schedule"> | boolean | null
    d30?: BoolNullableFilter<"Schedule"> | boolean | null
    d31?: BoolNullableFilter<"Schedule"> | boolean | null
    dLast?: BoolNullableFilter<"Schedule"> | boolean | null
    workTimeMode?: EnumWorkTimeModeFilter<"Schedule"> | $Enums.WorkTimeMode
    minDurationHours?: IntFilter<"Schedule"> | number
    minDurationMinutes?: IntFilter<"Schedule"> | number
    maxDurationHours?: IntFilter<"Schedule"> | number
    maxDurationMinutes?: IntFilter<"Schedule"> | number
    timeStart?: IntFilter<"Schedule"> | number
    rank?: IntFilter<"Schedule"> | number
    status?: EnumScheduleStatusFilter<"Schedule"> | $Enums.ScheduleStatus
    place?: XOR<PlaceScalarRelationFilter, PlaceWhereInput>
    timeSlots?: TimeSlotListRelationFilter
  }, "id">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    placeId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    stopDate?: SortOrderInput | SortOrder
    name?: SortOrder
    repeatMode?: SortOrder
    repeatStep?: SortOrder
    m1?: SortOrderInput | SortOrder
    m2?: SortOrderInput | SortOrder
    m3?: SortOrderInput | SortOrder
    m4?: SortOrderInput | SortOrder
    m5?: SortOrderInput | SortOrder
    m6?: SortOrderInput | SortOrder
    m7?: SortOrderInput | SortOrder
    m8?: SortOrderInput | SortOrder
    m9?: SortOrderInput | SortOrder
    m10?: SortOrderInput | SortOrder
    m11?: SortOrderInput | SortOrder
    m12?: SortOrderInput | SortOrder
    w1?: SortOrderInput | SortOrder
    w2?: SortOrderInput | SortOrder
    w3?: SortOrderInput | SortOrder
    w4?: SortOrderInput | SortOrder
    wLast?: SortOrderInput | SortOrder
    wd1?: SortOrderInput | SortOrder
    wd2?: SortOrderInput | SortOrder
    wd3?: SortOrderInput | SortOrder
    wd4?: SortOrderInput | SortOrder
    wd5?: SortOrderInput | SortOrder
    wd6?: SortOrderInput | SortOrder
    wd7?: SortOrderInput | SortOrder
    d1?: SortOrderInput | SortOrder
    d2?: SortOrderInput | SortOrder
    d3?: SortOrderInput | SortOrder
    d4?: SortOrderInput | SortOrder
    d5?: SortOrderInput | SortOrder
    d6?: SortOrderInput | SortOrder
    d7?: SortOrderInput | SortOrder
    d8?: SortOrderInput | SortOrder
    d9?: SortOrderInput | SortOrder
    d10?: SortOrderInput | SortOrder
    d11?: SortOrderInput | SortOrder
    d12?: SortOrderInput | SortOrder
    d13?: SortOrderInput | SortOrder
    d14?: SortOrderInput | SortOrder
    d15?: SortOrderInput | SortOrder
    d16?: SortOrderInput | SortOrder
    d17?: SortOrderInput | SortOrder
    d18?: SortOrderInput | SortOrder
    d19?: SortOrderInput | SortOrder
    d20?: SortOrderInput | SortOrder
    d21?: SortOrderInput | SortOrder
    d22?: SortOrderInput | SortOrder
    d23?: SortOrderInput | SortOrder
    d24?: SortOrderInput | SortOrder
    d25?: SortOrderInput | SortOrder
    d26?: SortOrderInput | SortOrder
    d27?: SortOrderInput | SortOrder
    d28?: SortOrderInput | SortOrder
    d29?: SortOrderInput | SortOrder
    d30?: SortOrderInput | SortOrder
    d31?: SortOrderInput | SortOrder
    dLast?: SortOrderInput | SortOrder
    workTimeMode?: SortOrder
    minDurationHours?: SortOrder
    minDurationMinutes?: SortOrder
    maxDurationHours?: SortOrder
    maxDurationMinutes?: SortOrder
    timeStart?: SortOrder
    rank?: SortOrder
    status?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _avg?: ScheduleAvgOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
    _sum?: ScheduleSumOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Schedule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    placeId?: StringWithAggregatesFilter<"Schedule"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"Schedule"> | Date | string | null
    stopDate?: DateTimeNullableWithAggregatesFilter<"Schedule"> | Date | string | null
    name?: StringWithAggregatesFilter<"Schedule"> | string
    repeatMode?: EnumCalendarRepeatModeWithAggregatesFilter<"Schedule"> | $Enums.CalendarRepeatMode
    repeatStep?: IntWithAggregatesFilter<"Schedule"> | number
    m1?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    m2?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    m3?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    m4?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    m5?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    m6?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    m7?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    m8?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    m9?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    m10?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    m11?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    m12?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    w1?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    w2?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    w3?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    w4?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    wLast?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    wd1?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    wd2?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    wd3?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    wd4?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    wd5?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    wd6?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    wd7?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d1?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d2?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d3?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d4?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d5?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d6?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d7?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d8?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d9?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d10?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d11?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d12?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d13?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d14?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d15?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d16?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d17?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d18?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d19?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d20?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d21?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d22?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d23?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d24?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d25?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d26?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d27?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d28?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d29?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d30?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    d31?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    dLast?: BoolNullableWithAggregatesFilter<"Schedule"> | boolean | null
    workTimeMode?: EnumWorkTimeModeWithAggregatesFilter<"Schedule"> | $Enums.WorkTimeMode
    minDurationHours?: IntWithAggregatesFilter<"Schedule"> | number
    minDurationMinutes?: IntWithAggregatesFilter<"Schedule"> | number
    maxDurationHours?: IntWithAggregatesFilter<"Schedule"> | number
    maxDurationMinutes?: IntWithAggregatesFilter<"Schedule"> | number
    timeStart?: IntWithAggregatesFilter<"Schedule"> | number
    rank?: IntWithAggregatesFilter<"Schedule"> | number
    status?: EnumScheduleStatusWithAggregatesFilter<"Schedule"> | $Enums.ScheduleStatus
  }

  export type TimeSlotWhereInput = {
    AND?: TimeSlotWhereInput | TimeSlotWhereInput[]
    OR?: TimeSlotWhereInput[]
    NOT?: TimeSlotWhereInput | TimeSlotWhereInput[]
    id?: StringFilter<"TimeSlot"> | string
    createdAt?: DateTimeFilter<"TimeSlot"> | Date | string
    updatedAt?: DateTimeFilter<"TimeSlot"> | Date | string
    timeStart?: IntFilter<"TimeSlot"> | number
    timeEnd?: IntFilter<"TimeSlot"> | number
    scheduleId?: StringFilter<"TimeSlot"> | string
    schedule?: XOR<ScheduleScalarRelationFilter, ScheduleWhereInput>
  }

  export type TimeSlotOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timeStart?: SortOrder
    timeEnd?: SortOrder
    scheduleId?: SortOrder
    schedule?: ScheduleOrderByWithRelationInput
  }

  export type TimeSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimeSlotWhereInput | TimeSlotWhereInput[]
    OR?: TimeSlotWhereInput[]
    NOT?: TimeSlotWhereInput | TimeSlotWhereInput[]
    createdAt?: DateTimeFilter<"TimeSlot"> | Date | string
    updatedAt?: DateTimeFilter<"TimeSlot"> | Date | string
    timeStart?: IntFilter<"TimeSlot"> | number
    timeEnd?: IntFilter<"TimeSlot"> | number
    scheduleId?: StringFilter<"TimeSlot"> | string
    schedule?: XOR<ScheduleScalarRelationFilter, ScheduleWhereInput>
  }, "id">

  export type TimeSlotOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timeStart?: SortOrder
    timeEnd?: SortOrder
    scheduleId?: SortOrder
    _count?: TimeSlotCountOrderByAggregateInput
    _avg?: TimeSlotAvgOrderByAggregateInput
    _max?: TimeSlotMaxOrderByAggregateInput
    _min?: TimeSlotMinOrderByAggregateInput
    _sum?: TimeSlotSumOrderByAggregateInput
  }

  export type TimeSlotScalarWhereWithAggregatesInput = {
    AND?: TimeSlotScalarWhereWithAggregatesInput | TimeSlotScalarWhereWithAggregatesInput[]
    OR?: TimeSlotScalarWhereWithAggregatesInput[]
    NOT?: TimeSlotScalarWhereWithAggregatesInput | TimeSlotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeSlot"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TimeSlot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimeSlot"> | Date | string
    timeStart?: IntWithAggregatesFilter<"TimeSlot"> | number
    timeEnd?: IntWithAggregatesFilter<"TimeSlot"> | number
    scheduleId?: StringWithAggregatesFilter<"TimeSlot"> | string
  }

  export type SportWhereInput = {
    AND?: SportWhereInput | SportWhereInput[]
    OR?: SportWhereInput[]
    NOT?: SportWhereInput | SportWhereInput[]
    id?: StringFilter<"Sport"> | string
    name?: StringFilter<"Sport"> | string
    createdAt?: DateTimeFilter<"Sport"> | Date | string
    places?: PlaceSportListRelationFilter
    games?: GameListRelationFilter
    users?: UserSportListRelationFilter
  }

  export type SportOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    places?: PlaceSportOrderByRelationAggregateInput
    games?: GameOrderByRelationAggregateInput
    users?: UserSportOrderByRelationAggregateInput
  }

  export type SportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SportWhereInput | SportWhereInput[]
    OR?: SportWhereInput[]
    NOT?: SportWhereInput | SportWhereInput[]
    name?: StringFilter<"Sport"> | string
    createdAt?: DateTimeFilter<"Sport"> | Date | string
    places?: PlaceSportListRelationFilter
    games?: GameListRelationFilter
    users?: UserSportListRelationFilter
  }, "id">

  export type SportOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: SportCountOrderByAggregateInput
    _max?: SportMaxOrderByAggregateInput
    _min?: SportMinOrderByAggregateInput
  }

  export type SportScalarWhereWithAggregatesInput = {
    AND?: SportScalarWhereWithAggregatesInput | SportScalarWhereWithAggregatesInput[]
    OR?: SportScalarWhereWithAggregatesInput[]
    NOT?: SportScalarWhereWithAggregatesInput | SportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sport"> | string
    name?: StringWithAggregatesFilter<"Sport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Sport"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    idx?: IntFilter<"User"> | number
    email?: StringNullableFilter<"User"> | string | null
    keycloakId?: StringFilter<"User"> | string
    telegramId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    games?: GameUserListRelationFilter
    places?: PlaceListRelationFilter
    favoritePlaces?: PlaceFavoriteListRelationFilter
    sports?: UserSportListRelationFilter
    favorites?: UserFavoriteListRelationFilter
    favoritedBy?: UserFavoriteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    idx?: SortOrder
    email?: SortOrderInput | SortOrder
    keycloakId?: SortOrder
    telegramId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    games?: GameUserOrderByRelationAggregateInput
    places?: PlaceOrderByRelationAggregateInput
    favoritePlaces?: PlaceFavoriteOrderByRelationAggregateInput
    sports?: UserSportOrderByRelationAggregateInput
    favorites?: UserFavoriteOrderByRelationAggregateInput
    favoritedBy?: UserFavoriteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    idx?: number
    email?: string
    keycloakId?: string
    telegramId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    username?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    games?: GameUserListRelationFilter
    places?: PlaceListRelationFilter
    favoritePlaces?: PlaceFavoriteListRelationFilter
    sports?: UserSportListRelationFilter
    favorites?: UserFavoriteListRelationFilter
    favoritedBy?: UserFavoriteListRelationFilter
  }, "id" | "idx" | "email" | "keycloakId" | "telegramId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    idx?: SortOrder
    email?: SortOrderInput | SortOrder
    keycloakId?: SortOrder
    telegramId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    idx?: IntWithAggregatesFilter<"User"> | number
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    keycloakId?: StringWithAggregatesFilter<"User"> | string
    telegramId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type UserFavoriteWhereInput = {
    AND?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    OR?: UserFavoriteWhereInput[]
    NOT?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    userId?: StringFilter<"UserFavorite"> | string
    favoriteId?: StringFilter<"UserFavorite"> | string
    createdAt?: DateTimeFilter<"UserFavorite"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    favorite?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserFavoriteOrderByWithRelationInput = {
    userId?: SortOrder
    favoriteId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    favorite?: UserOrderByWithRelationInput
  }

  export type UserFavoriteWhereUniqueInput = Prisma.AtLeast<{
    userId_favoriteId?: UserFavoriteUserIdFavoriteIdCompoundUniqueInput
    AND?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    OR?: UserFavoriteWhereInput[]
    NOT?: UserFavoriteWhereInput | UserFavoriteWhereInput[]
    userId?: StringFilter<"UserFavorite"> | string
    favoriteId?: StringFilter<"UserFavorite"> | string
    createdAt?: DateTimeFilter<"UserFavorite"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    favorite?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId_favoriteId">

  export type UserFavoriteOrderByWithAggregationInput = {
    userId?: SortOrder
    favoriteId?: SortOrder
    createdAt?: SortOrder
    _count?: UserFavoriteCountOrderByAggregateInput
    _max?: UserFavoriteMaxOrderByAggregateInput
    _min?: UserFavoriteMinOrderByAggregateInput
  }

  export type UserFavoriteScalarWhereWithAggregatesInput = {
    AND?: UserFavoriteScalarWhereWithAggregatesInput | UserFavoriteScalarWhereWithAggregatesInput[]
    OR?: UserFavoriteScalarWhereWithAggregatesInput[]
    NOT?: UserFavoriteScalarWhereWithAggregatesInput | UserFavoriteScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserFavorite"> | string
    favoriteId?: StringWithAggregatesFilter<"UserFavorite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserFavorite"> | Date | string
  }

  export type UserSportWhereInput = {
    AND?: UserSportWhereInput | UserSportWhereInput[]
    OR?: UserSportWhereInput[]
    NOT?: UserSportWhereInput | UserSportWhereInput[]
    createdAt?: DateTimeFilter<"UserSport"> | Date | string
    sportId?: StringFilter<"UserSport"> | string
    userId?: StringFilter<"UserSport"> | string
    sport?: XOR<SportScalarRelationFilter, SportWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSportOrderByWithRelationInput = {
    createdAt?: SortOrder
    sportId?: SortOrder
    userId?: SortOrder
    sport?: SportOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserSportWhereUniqueInput = Prisma.AtLeast<{
    sportId_userId?: UserSportSportIdUserIdCompoundUniqueInput
    AND?: UserSportWhereInput | UserSportWhereInput[]
    OR?: UserSportWhereInput[]
    NOT?: UserSportWhereInput | UserSportWhereInput[]
    createdAt?: DateTimeFilter<"UserSport"> | Date | string
    sportId?: StringFilter<"UserSport"> | string
    userId?: StringFilter<"UserSport"> | string
    sport?: XOR<SportScalarRelationFilter, SportWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "sportId_userId">

  export type UserSportOrderByWithAggregationInput = {
    createdAt?: SortOrder
    sportId?: SortOrder
    userId?: SortOrder
    _count?: UserSportCountOrderByAggregateInput
    _max?: UserSportMaxOrderByAggregateInput
    _min?: UserSportMinOrderByAggregateInput
  }

  export type UserSportScalarWhereWithAggregatesInput = {
    AND?: UserSportScalarWhereWithAggregatesInput | UserSportScalarWhereWithAggregatesInput[]
    OR?: UserSportScalarWhereWithAggregatesInput[]
    NOT?: UserSportScalarWhereWithAggregatesInput | UserSportScalarWhereWithAggregatesInput[]
    createdAt?: DateTimeWithAggregatesFilter<"UserSport"> | Date | string
    sportId?: StringWithAggregatesFilter<"UserSport"> | string
    userId?: StringWithAggregatesFilter<"UserSport"> | string
  }

  export type UserTgLinkerWhereInput = {
    AND?: UserTgLinkerWhereInput | UserTgLinkerWhereInput[]
    OR?: UserTgLinkerWhereInput[]
    NOT?: UserTgLinkerWhereInput | UserTgLinkerWhereInput[]
    id?: StringFilter<"UserTgLinker"> | string
    userId?: StringFilter<"UserTgLinker"> | string
    createdAt?: DateTimeFilter<"UserTgLinker"> | Date | string
  }

  export type UserTgLinkerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserTgLinkerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserTgLinkerWhereInput | UserTgLinkerWhereInput[]
    OR?: UserTgLinkerWhereInput[]
    NOT?: UserTgLinkerWhereInput | UserTgLinkerWhereInput[]
    userId?: StringFilter<"UserTgLinker"> | string
    createdAt?: DateTimeFilter<"UserTgLinker"> | Date | string
  }, "id">

  export type UserTgLinkerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: UserTgLinkerCountOrderByAggregateInput
    _max?: UserTgLinkerMaxOrderByAggregateInput
    _min?: UserTgLinkerMinOrderByAggregateInput
  }

  export type UserTgLinkerScalarWhereWithAggregatesInput = {
    AND?: UserTgLinkerScalarWhereWithAggregatesInput | UserTgLinkerScalarWhereWithAggregatesInput[]
    OR?: UserTgLinkerScalarWhereWithAggregatesInput[]
    NOT?: UserTgLinkerScalarWhereWithAggregatesInput | UserTgLinkerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserTgLinker"> | string
    userId?: StringWithAggregatesFilter<"UserTgLinker"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserTgLinker"> | Date | string
  }

  export type CityCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    region?: number
    places?: PlaceCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    region?: number
    places?: PlaceUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    places?: PlaceUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    places?: PlaceUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    region?: number
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
  }

  export type GameCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
    date: Date | string
    status?: $Enums.GameStatus
    level?: $Enums.GameLevel
    countMembersMin?: number
    countMembersMax?: number
    description?: string | null
    requestMode?: $Enums.RequestMode
    place: PlaceCreateNestedOneWithoutGamesInput
    users?: GameUserCreateNestedManyWithoutGameInput
    sport?: SportCreateNestedOneWithoutGamesInput
  }

  export type GameUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
    date: Date | string
    status?: $Enums.GameStatus
    level?: $Enums.GameLevel
    countMembersMin?: number
    countMembersMax?: number
    description?: string | null
    requestMode?: $Enums.RequestMode
    placeId: string
    sportId?: string | null
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    level?: EnumGameLevelFieldUpdateOperationsInput | $Enums.GameLevel
    countMembersMin?: IntFieldUpdateOperationsInput | number
    countMembersMax?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requestMode?: EnumRequestModeFieldUpdateOperationsInput | $Enums.RequestMode
    place?: PlaceUpdateOneRequiredWithoutGamesNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
    sport?: SportUpdateOneWithoutGamesNestedInput
  }

  export type GameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    level?: EnumGameLevelFieldUpdateOperationsInput | $Enums.GameLevel
    countMembersMin?: IntFieldUpdateOperationsInput | number
    countMembersMax?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requestMode?: EnumRequestModeFieldUpdateOperationsInput | $Enums.RequestMode
    placeId?: StringFieldUpdateOperationsInput | string
    sportId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
    date: Date | string
    status?: $Enums.GameStatus
    level?: $Enums.GameLevel
    countMembersMin?: number
    countMembersMax?: number
    description?: string | null
    requestMode?: $Enums.RequestMode
    placeId: string
    sportId?: string | null
  }

  export type GameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    level?: EnumGameLevelFieldUpdateOperationsInput | $Enums.GameLevel
    countMembersMin?: IntFieldUpdateOperationsInput | number
    countMembersMax?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requestMode?: EnumRequestModeFieldUpdateOperationsInput | $Enums.RequestMode
  }

  export type GameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    level?: EnumGameLevelFieldUpdateOperationsInput | $Enums.GameLevel
    countMembersMin?: IntFieldUpdateOperationsInput | number
    countMembersMax?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requestMode?: EnumRequestModeFieldUpdateOperationsInput | $Enums.RequestMode
    placeId?: StringFieldUpdateOperationsInput | string
    sportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GameUserCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role: $Enums.GameUserRole
    status: $Enums.GameUserStatus
    game: GameCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutGamesInput
  }

  export type GameUserUncheckedCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    gameId: string
    userId: string
    role: $Enums.GameUserRole
    status: $Enums.GameUserStatus
  }

  export type GameUserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumGameUserRoleFieldUpdateOperationsInput | $Enums.GameUserRole
    status?: EnumGameUserStatusFieldUpdateOperationsInput | $Enums.GameUserStatus
    game?: GameUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutGamesNestedInput
  }

  export type GameUserUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGameUserRoleFieldUpdateOperationsInput | $Enums.GameUserRole
    status?: EnumGameUserStatusFieldUpdateOperationsInput | $Enums.GameUserStatus
  }

  export type GameUserCreateManyInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    gameId: string
    userId: string
    role: $Enums.GameUserRole
    status: $Enums.GameUserStatus
  }

  export type GameUserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumGameUserRoleFieldUpdateOperationsInput | $Enums.GameUserRole
    status?: EnumGameUserStatusFieldUpdateOperationsInput | $Enums.GameUserStatus
  }

  export type GameUserUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGameUserRoleFieldUpdateOperationsInput | $Enums.GameUserRole
    status?: EnumGameUserStatusFieldUpdateOperationsInput | $Enums.GameUserStatus
  }

  export type PlaceCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    latitude?: number
    longitude?: number
    owner: UserCreateNestedOneWithoutPlacesInput
    schedules?: ScheduleCreateNestedManyWithoutPlaceInput
    games?: GameCreateNestedManyWithoutPlaceInput
    covers?: PlaceCoversCreateNestedManyWithoutPlaceInput
    sports?: PlaceSportCreateNestedManyWithoutPlaceInput
    favoritedUsers?: PlaceFavoriteCreateNestedManyWithoutPlaceInput
    city: CityCreateNestedOneWithoutPlacesInput
  }

  export type PlaceUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    ownerId: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    cityId: string
    latitude?: number
    longitude?: number
    schedules?: ScheduleUncheckedCreateNestedManyWithoutPlaceInput
    games?: GameUncheckedCreateNestedManyWithoutPlaceInput
    covers?: PlaceCoversUncheckedCreateNestedManyWithoutPlaceInput
    sports?: PlaceSportUncheckedCreateNestedManyWithoutPlaceInput
    favoritedUsers?: PlaceFavoriteUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutPlacesNestedInput
    schedules?: ScheduleUpdateManyWithoutPlaceNestedInput
    games?: GameUpdateManyWithoutPlaceNestedInput
    covers?: PlaceCoversUpdateManyWithoutPlaceNestedInput
    sports?: PlaceSportUpdateManyWithoutPlaceNestedInput
    favoritedUsers?: PlaceFavoriteUpdateManyWithoutPlaceNestedInput
    city?: CityUpdateOneRequiredWithoutPlacesNestedInput
  }

  export type PlaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    schedules?: ScheduleUncheckedUpdateManyWithoutPlaceNestedInput
    games?: GameUncheckedUpdateManyWithoutPlaceNestedInput
    covers?: PlaceCoversUncheckedUpdateManyWithoutPlaceNestedInput
    sports?: PlaceSportUncheckedUpdateManyWithoutPlaceNestedInput
    favoritedUsers?: PlaceFavoriteUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    ownerId: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    cityId: string
    latitude?: number
    longitude?: number
  }

  export type PlaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type PlaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type PlaceFavoriteCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritePlacesInput
    place: PlaceCreateNestedOneWithoutFavoritedUsersInput
  }

  export type PlaceFavoriteUncheckedCreateInput = {
    createdAt?: Date | string
    userId: string
    placeId: string
  }

  export type PlaceFavoriteUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritePlacesNestedInput
    place?: PlaceUpdateOneRequiredWithoutFavoritedUsersNestedInput
  }

  export type PlaceFavoriteUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaceFavoriteCreateManyInput = {
    createdAt?: Date | string
    userId: string
    placeId: string
  }

  export type PlaceFavoriteUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceFavoriteUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaceCoversCreateInput = {
    id?: string
    order?: number
    createdAt?: Date | string
    place: PlaceCreateNestedOneWithoutCoversInput
  }

  export type PlaceCoversUncheckedCreateInput = {
    id?: string
    order?: number
    placeId: string
    createdAt?: Date | string
  }

  export type PlaceCoversUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: PlaceUpdateOneRequiredWithoutCoversNestedInput
  }

  export type PlaceCoversUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    placeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceCoversCreateManyInput = {
    id?: string
    order?: number
    placeId: string
    createdAt?: Date | string
  }

  export type PlaceCoversUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceCoversUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    placeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceSportCreateInput = {
    createdAt?: Date | string
    sport: SportCreateNestedOneWithoutPlacesInput
    place: PlaceCreateNestedOneWithoutSportsInput
  }

  export type PlaceSportUncheckedCreateInput = {
    createdAt?: Date | string
    sportId: string
    placeId: string
  }

  export type PlaceSportUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: SportUpdateOneRequiredWithoutPlacesNestedInput
    place?: PlaceUpdateOneRequiredWithoutSportsNestedInput
  }

  export type PlaceSportUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sportId?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaceSportCreateManyInput = {
    createdAt?: Date | string
    sportId: string
    placeId: string
  }

  export type PlaceSportUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceSportUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sportId?: StringFieldUpdateOperationsInput | string
    placeId?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    stopDate?: Date | string | null
    name?: string
    repeatMode?: $Enums.CalendarRepeatMode
    repeatStep?: number
    m1?: boolean | null
    m2?: boolean | null
    m3?: boolean | null
    m4?: boolean | null
    m5?: boolean | null
    m6?: boolean | null
    m7?: boolean | null
    m8?: boolean | null
    m9?: boolean | null
    m10?: boolean | null
    m11?: boolean | null
    m12?: boolean | null
    w1?: boolean | null
    w2?: boolean | null
    w3?: boolean | null
    w4?: boolean | null
    wLast?: boolean | null
    wd1?: boolean | null
    wd2?: boolean | null
    wd3?: boolean | null
    wd4?: boolean | null
    wd5?: boolean | null
    wd6?: boolean | null
    wd7?: boolean | null
    d1?: boolean | null
    d2?: boolean | null
    d3?: boolean | null
    d4?: boolean | null
    d5?: boolean | null
    d6?: boolean | null
    d7?: boolean | null
    d8?: boolean | null
    d9?: boolean | null
    d10?: boolean | null
    d11?: boolean | null
    d12?: boolean | null
    d13?: boolean | null
    d14?: boolean | null
    d15?: boolean | null
    d16?: boolean | null
    d17?: boolean | null
    d18?: boolean | null
    d19?: boolean | null
    d20?: boolean | null
    d21?: boolean | null
    d22?: boolean | null
    d23?: boolean | null
    d24?: boolean | null
    d25?: boolean | null
    d26?: boolean | null
    d27?: boolean | null
    d28?: boolean | null
    d29?: boolean | null
    d30?: boolean | null
    d31?: boolean | null
    dLast?: boolean | null
    workTimeMode?: $Enums.WorkTimeMode
    minDurationHours?: number
    minDurationMinutes?: number
    maxDurationHours?: number
    maxDurationMinutes?: number
    timeStart?: number
    rank?: number
    status?: $Enums.ScheduleStatus
    place: PlaceCreateNestedOneWithoutSchedulesInput
    timeSlots?: TimeSlotCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    placeId: string
    startDate?: Date | string | null
    stopDate?: Date | string | null
    name?: string
    repeatMode?: $Enums.CalendarRepeatMode
    repeatStep?: number
    m1?: boolean | null
    m2?: boolean | null
    m3?: boolean | null
    m4?: boolean | null
    m5?: boolean | null
    m6?: boolean | null
    m7?: boolean | null
    m8?: boolean | null
    m9?: boolean | null
    m10?: boolean | null
    m11?: boolean | null
    m12?: boolean | null
    w1?: boolean | null
    w2?: boolean | null
    w3?: boolean | null
    w4?: boolean | null
    wLast?: boolean | null
    wd1?: boolean | null
    wd2?: boolean | null
    wd3?: boolean | null
    wd4?: boolean | null
    wd5?: boolean | null
    wd6?: boolean | null
    wd7?: boolean | null
    d1?: boolean | null
    d2?: boolean | null
    d3?: boolean | null
    d4?: boolean | null
    d5?: boolean | null
    d6?: boolean | null
    d7?: boolean | null
    d8?: boolean | null
    d9?: boolean | null
    d10?: boolean | null
    d11?: boolean | null
    d12?: boolean | null
    d13?: boolean | null
    d14?: boolean | null
    d15?: boolean | null
    d16?: boolean | null
    d17?: boolean | null
    d18?: boolean | null
    d19?: boolean | null
    d20?: boolean | null
    d21?: boolean | null
    d22?: boolean | null
    d23?: boolean | null
    d24?: boolean | null
    d25?: boolean | null
    d26?: boolean | null
    d27?: boolean | null
    d28?: boolean | null
    d29?: boolean | null
    d30?: boolean | null
    d31?: boolean | null
    dLast?: boolean | null
    workTimeMode?: $Enums.WorkTimeMode
    minDurationHours?: number
    minDurationMinutes?: number
    maxDurationHours?: number
    maxDurationMinutes?: number
    timeStart?: number
    rank?: number
    status?: $Enums.ScheduleStatus
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    repeatMode?: EnumCalendarRepeatModeFieldUpdateOperationsInput | $Enums.CalendarRepeatMode
    repeatStep?: IntFieldUpdateOperationsInput | number
    m1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d13?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d14?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d15?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d16?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d17?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d18?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d19?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d20?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d21?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d22?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d23?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d24?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d25?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d26?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d27?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d28?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d29?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d31?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workTimeMode?: EnumWorkTimeModeFieldUpdateOperationsInput | $Enums.WorkTimeMode
    minDurationHours?: IntFieldUpdateOperationsInput | number
    minDurationMinutes?: IntFieldUpdateOperationsInput | number
    maxDurationHours?: IntFieldUpdateOperationsInput | number
    maxDurationMinutes?: IntFieldUpdateOperationsInput | number
    timeStart?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    place?: PlaceUpdateOneRequiredWithoutSchedulesNestedInput
    timeSlots?: TimeSlotUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    placeId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    repeatMode?: EnumCalendarRepeatModeFieldUpdateOperationsInput | $Enums.CalendarRepeatMode
    repeatStep?: IntFieldUpdateOperationsInput | number
    m1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d13?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d14?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d15?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d16?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d17?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d18?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d19?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d20?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d21?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d22?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d23?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d24?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d25?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d26?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d27?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d28?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d29?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d31?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workTimeMode?: EnumWorkTimeModeFieldUpdateOperationsInput | $Enums.WorkTimeMode
    minDurationHours?: IntFieldUpdateOperationsInput | number
    minDurationMinutes?: IntFieldUpdateOperationsInput | number
    maxDurationHours?: IntFieldUpdateOperationsInput | number
    maxDurationMinutes?: IntFieldUpdateOperationsInput | number
    timeStart?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    placeId: string
    startDate?: Date | string | null
    stopDate?: Date | string | null
    name?: string
    repeatMode?: $Enums.CalendarRepeatMode
    repeatStep?: number
    m1?: boolean | null
    m2?: boolean | null
    m3?: boolean | null
    m4?: boolean | null
    m5?: boolean | null
    m6?: boolean | null
    m7?: boolean | null
    m8?: boolean | null
    m9?: boolean | null
    m10?: boolean | null
    m11?: boolean | null
    m12?: boolean | null
    w1?: boolean | null
    w2?: boolean | null
    w3?: boolean | null
    w4?: boolean | null
    wLast?: boolean | null
    wd1?: boolean | null
    wd2?: boolean | null
    wd3?: boolean | null
    wd4?: boolean | null
    wd5?: boolean | null
    wd6?: boolean | null
    wd7?: boolean | null
    d1?: boolean | null
    d2?: boolean | null
    d3?: boolean | null
    d4?: boolean | null
    d5?: boolean | null
    d6?: boolean | null
    d7?: boolean | null
    d8?: boolean | null
    d9?: boolean | null
    d10?: boolean | null
    d11?: boolean | null
    d12?: boolean | null
    d13?: boolean | null
    d14?: boolean | null
    d15?: boolean | null
    d16?: boolean | null
    d17?: boolean | null
    d18?: boolean | null
    d19?: boolean | null
    d20?: boolean | null
    d21?: boolean | null
    d22?: boolean | null
    d23?: boolean | null
    d24?: boolean | null
    d25?: boolean | null
    d26?: boolean | null
    d27?: boolean | null
    d28?: boolean | null
    d29?: boolean | null
    d30?: boolean | null
    d31?: boolean | null
    dLast?: boolean | null
    workTimeMode?: $Enums.WorkTimeMode
    minDurationHours?: number
    minDurationMinutes?: number
    maxDurationHours?: number
    maxDurationMinutes?: number
    timeStart?: number
    rank?: number
    status?: $Enums.ScheduleStatus
  }

  export type ScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    repeatMode?: EnumCalendarRepeatModeFieldUpdateOperationsInput | $Enums.CalendarRepeatMode
    repeatStep?: IntFieldUpdateOperationsInput | number
    m1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d13?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d14?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d15?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d16?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d17?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d18?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d19?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d20?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d21?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d22?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d23?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d24?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d25?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d26?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d27?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d28?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d29?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d31?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workTimeMode?: EnumWorkTimeModeFieldUpdateOperationsInput | $Enums.WorkTimeMode
    minDurationHours?: IntFieldUpdateOperationsInput | number
    minDurationMinutes?: IntFieldUpdateOperationsInput | number
    maxDurationHours?: IntFieldUpdateOperationsInput | number
    maxDurationMinutes?: IntFieldUpdateOperationsInput | number
    timeStart?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    placeId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    repeatMode?: EnumCalendarRepeatModeFieldUpdateOperationsInput | $Enums.CalendarRepeatMode
    repeatStep?: IntFieldUpdateOperationsInput | number
    m1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d13?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d14?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d15?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d16?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d17?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d18?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d19?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d20?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d21?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d22?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d23?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d24?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d25?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d26?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d27?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d28?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d29?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d31?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workTimeMode?: EnumWorkTimeModeFieldUpdateOperationsInput | $Enums.WorkTimeMode
    minDurationHours?: IntFieldUpdateOperationsInput | number
    minDurationMinutes?: IntFieldUpdateOperationsInput | number
    maxDurationHours?: IntFieldUpdateOperationsInput | number
    maxDurationMinutes?: IntFieldUpdateOperationsInput | number
    timeStart?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
  }

  export type TimeSlotCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
    schedule: ScheduleCreateNestedOneWithoutTimeSlotsInput
  }

  export type TimeSlotUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
    scheduleId: string
  }

  export type TimeSlotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    schedule?: ScheduleUpdateOneRequiredWithoutTimeSlotsNestedInput
  }

  export type TimeSlotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    scheduleId?: StringFieldUpdateOperationsInput | string
  }

  export type TimeSlotCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
    scheduleId: string
  }

  export type TimeSlotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
  }

  export type TimeSlotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    scheduleId?: StringFieldUpdateOperationsInput | string
  }

  export type SportCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    places?: PlaceSportCreateNestedManyWithoutSportInput
    games?: GameCreateNestedManyWithoutSportInput
    users?: UserSportCreateNestedManyWithoutSportInput
  }

  export type SportUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    places?: PlaceSportUncheckedCreateNestedManyWithoutSportInput
    games?: GameUncheckedCreateNestedManyWithoutSportInput
    users?: UserSportUncheckedCreateNestedManyWithoutSportInput
  }

  export type SportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    places?: PlaceSportUpdateManyWithoutSportNestedInput
    games?: GameUpdateManyWithoutSportNestedInput
    users?: UserSportUpdateManyWithoutSportNestedInput
  }

  export type SportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    places?: PlaceSportUncheckedUpdateManyWithoutSportNestedInput
    games?: GameUncheckedUpdateManyWithoutSportNestedInput
    users?: UserSportUncheckedUpdateManyWithoutSportNestedInput
  }

  export type SportCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type SportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
    games?: GameUserCreateNestedManyWithoutUserInput
    places?: PlaceCreateNestedManyWithoutOwnerInput
    favoritePlaces?: PlaceFavoriteCreateNestedManyWithoutUserInput
    sports?: UserSportCreateNestedManyWithoutUserInput
    favorites?: UserFavoriteCreateNestedManyWithoutUserInput
    favoritedBy?: UserFavoriteCreateNestedManyWithoutFavoriteInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
    games?: GameUserUncheckedCreateNestedManyWithoutUserInput
    places?: PlaceUncheckedCreateNestedManyWithoutOwnerInput
    favoritePlaces?: PlaceFavoriteUncheckedCreateNestedManyWithoutUserInput
    sports?: UserSportUncheckedCreateNestedManyWithoutUserInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    favoritedBy?: UserFavoriteUncheckedCreateNestedManyWithoutFavoriteInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    games?: GameUserUpdateManyWithoutUserNestedInput
    places?: PlaceUpdateManyWithoutOwnerNestedInput
    favoritePlaces?: PlaceFavoriteUpdateManyWithoutUserNestedInput
    sports?: UserSportUpdateManyWithoutUserNestedInput
    favorites?: UserFavoriteUpdateManyWithoutUserNestedInput
    favoritedBy?: UserFavoriteUpdateManyWithoutFavoriteNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    games?: GameUserUncheckedUpdateManyWithoutUserNestedInput
    places?: PlaceUncheckedUpdateManyWithoutOwnerNestedInput
    favoritePlaces?: PlaceFavoriteUncheckedUpdateManyWithoutUserNestedInput
    sports?: UserSportUncheckedUpdateManyWithoutUserNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    favoritedBy?: UserFavoriteUncheckedUpdateManyWithoutFavoriteNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserFavoriteCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
    favorite: UserCreateNestedOneWithoutFavoritedByInput
  }

  export type UserFavoriteUncheckedCreateInput = {
    userId: string
    favoriteId: string
    createdAt?: Date | string
  }

  export type UserFavoriteUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
    favorite?: UserUpdateOneRequiredWithoutFavoritedByNestedInput
  }

  export type UserFavoriteUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    favoriteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteCreateManyInput = {
    userId: string
    favoriteId: string
    createdAt?: Date | string
  }

  export type UserFavoriteUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    favoriteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSportCreateInput = {
    createdAt?: Date | string
    sport: SportCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutSportsInput
  }

  export type UserSportUncheckedCreateInput = {
    createdAt?: Date | string
    sportId: string
    userId: string
  }

  export type UserSportUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: SportUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutSportsNestedInput
  }

  export type UserSportUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sportId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSportCreateManyInput = {
    createdAt?: Date | string
    sportId: string
    userId: string
  }

  export type UserSportUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSportUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sportId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserTgLinkerCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserTgLinkerUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserTgLinkerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTgLinkerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTgLinkerCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserTgLinkerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTgLinkerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PlaceListRelationFilter = {
    every?: PlaceWhereInput
    some?: PlaceWhereInput
    none?: PlaceWhereInput
  }

  export type PlaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    region?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    region?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    region?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    region?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    region?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusFilter<$PrismaModel> | $Enums.GameStatus
  }

  export type EnumGameLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.GameLevel | EnumGameLevelFieldRefInput<$PrismaModel>
    in?: $Enums.GameLevel[] | ListEnumGameLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameLevel[] | ListEnumGameLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumGameLevelFilter<$PrismaModel> | $Enums.GameLevel
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRequestModeFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestMode | EnumRequestModeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestMode[] | ListEnumRequestModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestMode[] | ListEnumRequestModeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestModeFilter<$PrismaModel> | $Enums.RequestMode
  }

  export type PlaceScalarRelationFilter = {
    is?: PlaceWhereInput
    isNot?: PlaceWhereInput
  }

  export type GameUserListRelationFilter = {
    every?: GameUserWhereInput
    some?: GameUserWhereInput
    none?: GameUserWhereInput
  }

  export type SportNullableScalarRelationFilter = {
    is?: SportWhereInput | null
    isNot?: SportWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type GameUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timeStart?: SortOrder
    timeEnd?: SortOrder
    date?: SortOrder
    status?: SortOrder
    level?: SortOrder
    countMembersMin?: SortOrder
    countMembersMax?: SortOrder
    description?: SortOrder
    requestMode?: SortOrder
    placeId?: SortOrder
    sportId?: SortOrder
  }

  export type GameAvgOrderByAggregateInput = {
    timeStart?: SortOrder
    timeEnd?: SortOrder
    countMembersMin?: SortOrder
    countMembersMax?: SortOrder
  }

  export type GameMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timeStart?: SortOrder
    timeEnd?: SortOrder
    date?: SortOrder
    status?: SortOrder
    level?: SortOrder
    countMembersMin?: SortOrder
    countMembersMax?: SortOrder
    description?: SortOrder
    requestMode?: SortOrder
    placeId?: SortOrder
    sportId?: SortOrder
  }

  export type GameMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timeStart?: SortOrder
    timeEnd?: SortOrder
    date?: SortOrder
    status?: SortOrder
    level?: SortOrder
    countMembersMin?: SortOrder
    countMembersMax?: SortOrder
    description?: SortOrder
    requestMode?: SortOrder
    placeId?: SortOrder
    sportId?: SortOrder
  }

  export type GameSumOrderByAggregateInput = {
    timeStart?: SortOrder
    timeEnd?: SortOrder
    countMembersMin?: SortOrder
    countMembersMax?: SortOrder
  }

  export type EnumGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameStatusFilter<$PrismaModel>
    _max?: NestedEnumGameStatusFilter<$PrismaModel>
  }

  export type EnumGameLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameLevel | EnumGameLevelFieldRefInput<$PrismaModel>
    in?: $Enums.GameLevel[] | ListEnumGameLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameLevel[] | ListEnumGameLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumGameLevelWithAggregatesFilter<$PrismaModel> | $Enums.GameLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameLevelFilter<$PrismaModel>
    _max?: NestedEnumGameLevelFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRequestModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestMode | EnumRequestModeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestMode[] | ListEnumRequestModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestMode[] | ListEnumRequestModeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestModeWithAggregatesFilter<$PrismaModel> | $Enums.RequestMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestModeFilter<$PrismaModel>
    _max?: NestedEnumRequestModeFilter<$PrismaModel>
  }

  export type EnumGameUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.GameUserRole | EnumGameUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GameUserRole[] | ListEnumGameUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameUserRole[] | ListEnumGameUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGameUserRoleFilter<$PrismaModel> | $Enums.GameUserRole
  }

  export type EnumGameUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameUserStatus | EnumGameUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameUserStatus[] | ListEnumGameUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameUserStatus[] | ListEnumGameUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameUserStatusFilter<$PrismaModel> | $Enums.GameUserStatus
  }

  export type GameScalarRelationFilter = {
    is?: GameWhereInput
    isNot?: GameWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type GameUserGameIdUserIdCompoundUniqueInput = {
    gameId: string
    userId: string
  }

  export type GameUserCountOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
  }

  export type GameUserMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
  }

  export type GameUserMinOrderByAggregateInput = {
    createdAt?: SortOrder
    updatedAt?: SortOrder
    gameId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
  }

  export type EnumGameUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameUserRole | EnumGameUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GameUserRole[] | ListEnumGameUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameUserRole[] | ListEnumGameUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGameUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.GameUserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameUserRoleFilter<$PrismaModel>
    _max?: NestedEnumGameUserRoleFilter<$PrismaModel>
  }

  export type EnumGameUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameUserStatus | EnumGameUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameUserStatus[] | ListEnumGameUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameUserStatus[] | ListEnumGameUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameUserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameUserStatusFilter<$PrismaModel>
    _max?: NestedEnumGameUserStatusFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type GameListRelationFilter = {
    every?: GameWhereInput
    some?: GameWhereInput
    none?: GameWhereInput
  }

  export type PlaceCoversListRelationFilter = {
    every?: PlaceCoversWhereInput
    some?: PlaceCoversWhereInput
    none?: PlaceCoversWhereInput
  }

  export type PlaceSportListRelationFilter = {
    every?: PlaceSportWhereInput
    some?: PlaceSportWhereInput
    none?: PlaceSportWhereInput
  }

  export type PlaceFavoriteListRelationFilter = {
    every?: PlaceFavoriteWhereInput
    some?: PlaceFavoriteWhereInput
    none?: PlaceFavoriteWhereInput
  }

  export type CityScalarRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaceCoversOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaceSportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaceFavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    isIndoor?: SortOrder
    isFree?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type PlaceAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type PlaceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    isIndoor?: SortOrder
    isFree?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type PlaceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    isIndoor?: SortOrder
    isFree?: SortOrder
    cityId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type PlaceSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PlaceFavoriteUserIdPlaceIdCompoundUniqueInput = {
    userId: string
    placeId: string
  }

  export type PlaceFavoriteCountOrderByAggregateInput = {
    createdAt?: SortOrder
    userId?: SortOrder
    placeId?: SortOrder
  }

  export type PlaceFavoriteMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    userId?: SortOrder
    placeId?: SortOrder
  }

  export type PlaceFavoriteMinOrderByAggregateInput = {
    createdAt?: SortOrder
    userId?: SortOrder
    placeId?: SortOrder
  }

  export type PlaceCoversCountOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    placeId?: SortOrder
    createdAt?: SortOrder
  }

  export type PlaceCoversAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PlaceCoversMaxOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    placeId?: SortOrder
    createdAt?: SortOrder
  }

  export type PlaceCoversMinOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    placeId?: SortOrder
    createdAt?: SortOrder
  }

  export type PlaceCoversSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SportScalarRelationFilter = {
    is?: SportWhereInput
    isNot?: SportWhereInput
  }

  export type PlaceSportSportIdPlaceIdCompoundUniqueInput = {
    sportId: string
    placeId: string
  }

  export type PlaceSportCountOrderByAggregateInput = {
    createdAt?: SortOrder
    sportId?: SortOrder
    placeId?: SortOrder
  }

  export type PlaceSportMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    sportId?: SortOrder
    placeId?: SortOrder
  }

  export type PlaceSportMinOrderByAggregateInput = {
    createdAt?: SortOrder
    sportId?: SortOrder
    placeId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumCalendarRepeatModeFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarRepeatMode | EnumCalendarRepeatModeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarRepeatMode[] | ListEnumCalendarRepeatModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarRepeatMode[] | ListEnumCalendarRepeatModeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarRepeatModeFilter<$PrismaModel> | $Enums.CalendarRepeatMode
  }

  export type EnumWorkTimeModeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTimeMode | EnumWorkTimeModeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTimeMode[] | ListEnumWorkTimeModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTimeMode[] | ListEnumWorkTimeModeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTimeModeFilter<$PrismaModel> | $Enums.WorkTimeMode
  }

  export type EnumScheduleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleStatusFilter<$PrismaModel> | $Enums.ScheduleStatus
  }

  export type TimeSlotListRelationFilter = {
    every?: TimeSlotWhereInput
    some?: TimeSlotWhereInput
    none?: TimeSlotWhereInput
  }

  export type TimeSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    placeId?: SortOrder
    startDate?: SortOrder
    stopDate?: SortOrder
    name?: SortOrder
    repeatMode?: SortOrder
    repeatStep?: SortOrder
    m1?: SortOrder
    m2?: SortOrder
    m3?: SortOrder
    m4?: SortOrder
    m5?: SortOrder
    m6?: SortOrder
    m7?: SortOrder
    m8?: SortOrder
    m9?: SortOrder
    m10?: SortOrder
    m11?: SortOrder
    m12?: SortOrder
    w1?: SortOrder
    w2?: SortOrder
    w3?: SortOrder
    w4?: SortOrder
    wLast?: SortOrder
    wd1?: SortOrder
    wd2?: SortOrder
    wd3?: SortOrder
    wd4?: SortOrder
    wd5?: SortOrder
    wd6?: SortOrder
    wd7?: SortOrder
    d1?: SortOrder
    d2?: SortOrder
    d3?: SortOrder
    d4?: SortOrder
    d5?: SortOrder
    d6?: SortOrder
    d7?: SortOrder
    d8?: SortOrder
    d9?: SortOrder
    d10?: SortOrder
    d11?: SortOrder
    d12?: SortOrder
    d13?: SortOrder
    d14?: SortOrder
    d15?: SortOrder
    d16?: SortOrder
    d17?: SortOrder
    d18?: SortOrder
    d19?: SortOrder
    d20?: SortOrder
    d21?: SortOrder
    d22?: SortOrder
    d23?: SortOrder
    d24?: SortOrder
    d25?: SortOrder
    d26?: SortOrder
    d27?: SortOrder
    d28?: SortOrder
    d29?: SortOrder
    d30?: SortOrder
    d31?: SortOrder
    dLast?: SortOrder
    workTimeMode?: SortOrder
    minDurationHours?: SortOrder
    minDurationMinutes?: SortOrder
    maxDurationHours?: SortOrder
    maxDurationMinutes?: SortOrder
    timeStart?: SortOrder
    rank?: SortOrder
    status?: SortOrder
  }

  export type ScheduleAvgOrderByAggregateInput = {
    repeatStep?: SortOrder
    minDurationHours?: SortOrder
    minDurationMinutes?: SortOrder
    maxDurationHours?: SortOrder
    maxDurationMinutes?: SortOrder
    timeStart?: SortOrder
    rank?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    placeId?: SortOrder
    startDate?: SortOrder
    stopDate?: SortOrder
    name?: SortOrder
    repeatMode?: SortOrder
    repeatStep?: SortOrder
    m1?: SortOrder
    m2?: SortOrder
    m3?: SortOrder
    m4?: SortOrder
    m5?: SortOrder
    m6?: SortOrder
    m7?: SortOrder
    m8?: SortOrder
    m9?: SortOrder
    m10?: SortOrder
    m11?: SortOrder
    m12?: SortOrder
    w1?: SortOrder
    w2?: SortOrder
    w3?: SortOrder
    w4?: SortOrder
    wLast?: SortOrder
    wd1?: SortOrder
    wd2?: SortOrder
    wd3?: SortOrder
    wd4?: SortOrder
    wd5?: SortOrder
    wd6?: SortOrder
    wd7?: SortOrder
    d1?: SortOrder
    d2?: SortOrder
    d3?: SortOrder
    d4?: SortOrder
    d5?: SortOrder
    d6?: SortOrder
    d7?: SortOrder
    d8?: SortOrder
    d9?: SortOrder
    d10?: SortOrder
    d11?: SortOrder
    d12?: SortOrder
    d13?: SortOrder
    d14?: SortOrder
    d15?: SortOrder
    d16?: SortOrder
    d17?: SortOrder
    d18?: SortOrder
    d19?: SortOrder
    d20?: SortOrder
    d21?: SortOrder
    d22?: SortOrder
    d23?: SortOrder
    d24?: SortOrder
    d25?: SortOrder
    d26?: SortOrder
    d27?: SortOrder
    d28?: SortOrder
    d29?: SortOrder
    d30?: SortOrder
    d31?: SortOrder
    dLast?: SortOrder
    workTimeMode?: SortOrder
    minDurationHours?: SortOrder
    minDurationMinutes?: SortOrder
    maxDurationHours?: SortOrder
    maxDurationMinutes?: SortOrder
    timeStart?: SortOrder
    rank?: SortOrder
    status?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    placeId?: SortOrder
    startDate?: SortOrder
    stopDate?: SortOrder
    name?: SortOrder
    repeatMode?: SortOrder
    repeatStep?: SortOrder
    m1?: SortOrder
    m2?: SortOrder
    m3?: SortOrder
    m4?: SortOrder
    m5?: SortOrder
    m6?: SortOrder
    m7?: SortOrder
    m8?: SortOrder
    m9?: SortOrder
    m10?: SortOrder
    m11?: SortOrder
    m12?: SortOrder
    w1?: SortOrder
    w2?: SortOrder
    w3?: SortOrder
    w4?: SortOrder
    wLast?: SortOrder
    wd1?: SortOrder
    wd2?: SortOrder
    wd3?: SortOrder
    wd4?: SortOrder
    wd5?: SortOrder
    wd6?: SortOrder
    wd7?: SortOrder
    d1?: SortOrder
    d2?: SortOrder
    d3?: SortOrder
    d4?: SortOrder
    d5?: SortOrder
    d6?: SortOrder
    d7?: SortOrder
    d8?: SortOrder
    d9?: SortOrder
    d10?: SortOrder
    d11?: SortOrder
    d12?: SortOrder
    d13?: SortOrder
    d14?: SortOrder
    d15?: SortOrder
    d16?: SortOrder
    d17?: SortOrder
    d18?: SortOrder
    d19?: SortOrder
    d20?: SortOrder
    d21?: SortOrder
    d22?: SortOrder
    d23?: SortOrder
    d24?: SortOrder
    d25?: SortOrder
    d26?: SortOrder
    d27?: SortOrder
    d28?: SortOrder
    d29?: SortOrder
    d30?: SortOrder
    d31?: SortOrder
    dLast?: SortOrder
    workTimeMode?: SortOrder
    minDurationHours?: SortOrder
    minDurationMinutes?: SortOrder
    maxDurationHours?: SortOrder
    maxDurationMinutes?: SortOrder
    timeStart?: SortOrder
    rank?: SortOrder
    status?: SortOrder
  }

  export type ScheduleSumOrderByAggregateInput = {
    repeatStep?: SortOrder
    minDurationHours?: SortOrder
    minDurationMinutes?: SortOrder
    maxDurationHours?: SortOrder
    maxDurationMinutes?: SortOrder
    timeStart?: SortOrder
    rank?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumCalendarRepeatModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarRepeatMode | EnumCalendarRepeatModeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarRepeatMode[] | ListEnumCalendarRepeatModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarRepeatMode[] | ListEnumCalendarRepeatModeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarRepeatModeWithAggregatesFilter<$PrismaModel> | $Enums.CalendarRepeatMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalendarRepeatModeFilter<$PrismaModel>
    _max?: NestedEnumCalendarRepeatModeFilter<$PrismaModel>
  }

  export type EnumWorkTimeModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTimeMode | EnumWorkTimeModeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTimeMode[] | ListEnumWorkTimeModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTimeMode[] | ListEnumWorkTimeModeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTimeModeWithAggregatesFilter<$PrismaModel> | $Enums.WorkTimeMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkTimeModeFilter<$PrismaModel>
    _max?: NestedEnumWorkTimeModeFilter<$PrismaModel>
  }

  export type EnumScheduleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleStatusFilter<$PrismaModel>
    _max?: NestedEnumScheduleStatusFilter<$PrismaModel>
  }

  export type ScheduleScalarRelationFilter = {
    is?: ScheduleWhereInput
    isNot?: ScheduleWhereInput
  }

  export type TimeSlotCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timeStart?: SortOrder
    timeEnd?: SortOrder
    scheduleId?: SortOrder
  }

  export type TimeSlotAvgOrderByAggregateInput = {
    timeStart?: SortOrder
    timeEnd?: SortOrder
  }

  export type TimeSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timeStart?: SortOrder
    timeEnd?: SortOrder
    scheduleId?: SortOrder
  }

  export type TimeSlotMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    timeStart?: SortOrder
    timeEnd?: SortOrder
    scheduleId?: SortOrder
  }

  export type TimeSlotSumOrderByAggregateInput = {
    timeStart?: SortOrder
    timeEnd?: SortOrder
  }

  export type UserSportListRelationFilter = {
    every?: UserSportWhereInput
    some?: UserSportWhereInput
    none?: UserSportWhereInput
  }

  export type UserSportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SportCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type SportMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type SportMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFavoriteListRelationFilter = {
    every?: UserFavoriteWhereInput
    some?: UserFavoriteWhereInput
    none?: UserFavoriteWhereInput
  }

  export type UserFavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    idx?: SortOrder
    email?: SortOrder
    keycloakId?: SortOrder
    telegramId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    avatar?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    idx?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    idx?: SortOrder
    email?: SortOrder
    keycloakId?: SortOrder
    telegramId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    avatar?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    idx?: SortOrder
    email?: SortOrder
    keycloakId?: SortOrder
    telegramId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    username?: SortOrder
    avatar?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    idx?: SortOrder
  }

  export type UserFavoriteUserIdFavoriteIdCompoundUniqueInput = {
    userId: string
    favoriteId: string
  }

  export type UserFavoriteCountOrderByAggregateInput = {
    userId?: SortOrder
    favoriteId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFavoriteMaxOrderByAggregateInput = {
    userId?: SortOrder
    favoriteId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserFavoriteMinOrderByAggregateInput = {
    userId?: SortOrder
    favoriteId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSportSportIdUserIdCompoundUniqueInput = {
    sportId: string
    userId: string
  }

  export type UserSportCountOrderByAggregateInput = {
    createdAt?: SortOrder
    sportId?: SortOrder
    userId?: SortOrder
  }

  export type UserSportMaxOrderByAggregateInput = {
    createdAt?: SortOrder
    sportId?: SortOrder
    userId?: SortOrder
  }

  export type UserSportMinOrderByAggregateInput = {
    createdAt?: SortOrder
    sportId?: SortOrder
    userId?: SortOrder
  }

  export type UserTgLinkerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserTgLinkerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserTgLinkerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PlaceCreateNestedManyWithoutCityInput = {
    create?: XOR<PlaceCreateWithoutCityInput, PlaceUncheckedCreateWithoutCityInput> | PlaceCreateWithoutCityInput[] | PlaceUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutCityInput | PlaceCreateOrConnectWithoutCityInput[]
    createMany?: PlaceCreateManyCityInputEnvelope
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
  }

  export type PlaceUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<PlaceCreateWithoutCityInput, PlaceUncheckedCreateWithoutCityInput> | PlaceCreateWithoutCityInput[] | PlaceUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutCityInput | PlaceCreateOrConnectWithoutCityInput[]
    createMany?: PlaceCreateManyCityInputEnvelope
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PlaceUpdateManyWithoutCityNestedInput = {
    create?: XOR<PlaceCreateWithoutCityInput, PlaceUncheckedCreateWithoutCityInput> | PlaceCreateWithoutCityInput[] | PlaceUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutCityInput | PlaceCreateOrConnectWithoutCityInput[]
    upsert?: PlaceUpsertWithWhereUniqueWithoutCityInput | PlaceUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: PlaceCreateManyCityInputEnvelope
    set?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    disconnect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    delete?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    update?: PlaceUpdateWithWhereUniqueWithoutCityInput | PlaceUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: PlaceUpdateManyWithWhereWithoutCityInput | PlaceUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
  }

  export type PlaceUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<PlaceCreateWithoutCityInput, PlaceUncheckedCreateWithoutCityInput> | PlaceCreateWithoutCityInput[] | PlaceUncheckedCreateWithoutCityInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutCityInput | PlaceCreateOrConnectWithoutCityInput[]
    upsert?: PlaceUpsertWithWhereUniqueWithoutCityInput | PlaceUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: PlaceCreateManyCityInputEnvelope
    set?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    disconnect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    delete?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    update?: PlaceUpdateWithWhereUniqueWithoutCityInput | PlaceUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: PlaceUpdateManyWithWhereWithoutCityInput | PlaceUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
  }

  export type PlaceCreateNestedOneWithoutGamesInput = {
    create?: XOR<PlaceCreateWithoutGamesInput, PlaceUncheckedCreateWithoutGamesInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutGamesInput
    connect?: PlaceWhereUniqueInput
  }

  export type GameUserCreateNestedManyWithoutGameInput = {
    create?: XOR<GameUserCreateWithoutGameInput, GameUserUncheckedCreateWithoutGameInput> | GameUserCreateWithoutGameInput[] | GameUserUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutGameInput | GameUserCreateOrConnectWithoutGameInput[]
    createMany?: GameUserCreateManyGameInputEnvelope
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
  }

  export type SportCreateNestedOneWithoutGamesInput = {
    create?: XOR<SportCreateWithoutGamesInput, SportUncheckedCreateWithoutGamesInput>
    connectOrCreate?: SportCreateOrConnectWithoutGamesInput
    connect?: SportWhereUniqueInput
  }

  export type GameUserUncheckedCreateNestedManyWithoutGameInput = {
    create?: XOR<GameUserCreateWithoutGameInput, GameUserUncheckedCreateWithoutGameInput> | GameUserCreateWithoutGameInput[] | GameUserUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutGameInput | GameUserCreateOrConnectWithoutGameInput[]
    createMany?: GameUserCreateManyGameInputEnvelope
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
  }

  export type EnumGameStatusFieldUpdateOperationsInput = {
    set?: $Enums.GameStatus
  }

  export type EnumGameLevelFieldUpdateOperationsInput = {
    set?: $Enums.GameLevel
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRequestModeFieldUpdateOperationsInput = {
    set?: $Enums.RequestMode
  }

  export type PlaceUpdateOneRequiredWithoutGamesNestedInput = {
    create?: XOR<PlaceCreateWithoutGamesInput, PlaceUncheckedCreateWithoutGamesInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutGamesInput
    upsert?: PlaceUpsertWithoutGamesInput
    connect?: PlaceWhereUniqueInput
    update?: XOR<XOR<PlaceUpdateToOneWithWhereWithoutGamesInput, PlaceUpdateWithoutGamesInput>, PlaceUncheckedUpdateWithoutGamesInput>
  }

  export type GameUserUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameUserCreateWithoutGameInput, GameUserUncheckedCreateWithoutGameInput> | GameUserCreateWithoutGameInput[] | GameUserUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutGameInput | GameUserCreateOrConnectWithoutGameInput[]
    upsert?: GameUserUpsertWithWhereUniqueWithoutGameInput | GameUserUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameUserCreateManyGameInputEnvelope
    set?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    disconnect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    delete?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    update?: GameUserUpdateWithWhereUniqueWithoutGameInput | GameUserUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameUserUpdateManyWithWhereWithoutGameInput | GameUserUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameUserScalarWhereInput | GameUserScalarWhereInput[]
  }

  export type SportUpdateOneWithoutGamesNestedInput = {
    create?: XOR<SportCreateWithoutGamesInput, SportUncheckedCreateWithoutGamesInput>
    connectOrCreate?: SportCreateOrConnectWithoutGamesInput
    upsert?: SportUpsertWithoutGamesInput
    disconnect?: SportWhereInput | boolean
    delete?: SportWhereInput | boolean
    connect?: SportWhereUniqueInput
    update?: XOR<XOR<SportUpdateToOneWithWhereWithoutGamesInput, SportUpdateWithoutGamesInput>, SportUncheckedUpdateWithoutGamesInput>
  }

  export type GameUserUncheckedUpdateManyWithoutGameNestedInput = {
    create?: XOR<GameUserCreateWithoutGameInput, GameUserUncheckedCreateWithoutGameInput> | GameUserCreateWithoutGameInput[] | GameUserUncheckedCreateWithoutGameInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutGameInput | GameUserCreateOrConnectWithoutGameInput[]
    upsert?: GameUserUpsertWithWhereUniqueWithoutGameInput | GameUserUpsertWithWhereUniqueWithoutGameInput[]
    createMany?: GameUserCreateManyGameInputEnvelope
    set?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    disconnect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    delete?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    update?: GameUserUpdateWithWhereUniqueWithoutGameInput | GameUserUpdateWithWhereUniqueWithoutGameInput[]
    updateMany?: GameUserUpdateManyWithWhereWithoutGameInput | GameUserUpdateManyWithWhereWithoutGameInput[]
    deleteMany?: GameUserScalarWhereInput | GameUserScalarWhereInput[]
  }

  export type GameCreateNestedOneWithoutUsersInput = {
    create?: XOR<GameCreateWithoutUsersInput, GameUncheckedCreateWithoutUsersInput>
    connectOrCreate?: GameCreateOrConnectWithoutUsersInput
    connect?: GameWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGamesInput = {
    create?: XOR<UserCreateWithoutGamesInput, UserUncheckedCreateWithoutGamesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGamesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGameUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.GameUserRole
  }

  export type EnumGameUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.GameUserStatus
  }

  export type GameUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<GameCreateWithoutUsersInput, GameUncheckedCreateWithoutUsersInput>
    connectOrCreate?: GameCreateOrConnectWithoutUsersInput
    upsert?: GameUpsertWithoutUsersInput
    connect?: GameWhereUniqueInput
    update?: XOR<XOR<GameUpdateToOneWithWhereWithoutUsersInput, GameUpdateWithoutUsersInput>, GameUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutGamesNestedInput = {
    create?: XOR<UserCreateWithoutGamesInput, UserUncheckedCreateWithoutGamesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGamesInput
    upsert?: UserUpsertWithoutGamesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGamesInput, UserUpdateWithoutGamesInput>, UserUncheckedUpdateWithoutGamesInput>
  }

  export type UserCreateNestedOneWithoutPlacesInput = {
    create?: XOR<UserCreateWithoutPlacesInput, UserUncheckedCreateWithoutPlacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlacesInput
    connect?: UserWhereUniqueInput
  }

  export type ScheduleCreateNestedManyWithoutPlaceInput = {
    create?: XOR<ScheduleCreateWithoutPlaceInput, ScheduleUncheckedCreateWithoutPlaceInput> | ScheduleCreateWithoutPlaceInput[] | ScheduleUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutPlaceInput | ScheduleCreateOrConnectWithoutPlaceInput[]
    createMany?: ScheduleCreateManyPlaceInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type GameCreateNestedManyWithoutPlaceInput = {
    create?: XOR<GameCreateWithoutPlaceInput, GameUncheckedCreateWithoutPlaceInput> | GameCreateWithoutPlaceInput[] | GameUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: GameCreateOrConnectWithoutPlaceInput | GameCreateOrConnectWithoutPlaceInput[]
    createMany?: GameCreateManyPlaceInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type PlaceCoversCreateNestedManyWithoutPlaceInput = {
    create?: XOR<PlaceCoversCreateWithoutPlaceInput, PlaceCoversUncheckedCreateWithoutPlaceInput> | PlaceCoversCreateWithoutPlaceInput[] | PlaceCoversUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceCoversCreateOrConnectWithoutPlaceInput | PlaceCoversCreateOrConnectWithoutPlaceInput[]
    createMany?: PlaceCoversCreateManyPlaceInputEnvelope
    connect?: PlaceCoversWhereUniqueInput | PlaceCoversWhereUniqueInput[]
  }

  export type PlaceSportCreateNestedManyWithoutPlaceInput = {
    create?: XOR<PlaceSportCreateWithoutPlaceInput, PlaceSportUncheckedCreateWithoutPlaceInput> | PlaceSportCreateWithoutPlaceInput[] | PlaceSportUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceSportCreateOrConnectWithoutPlaceInput | PlaceSportCreateOrConnectWithoutPlaceInput[]
    createMany?: PlaceSportCreateManyPlaceInputEnvelope
    connect?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
  }

  export type PlaceFavoriteCreateNestedManyWithoutPlaceInput = {
    create?: XOR<PlaceFavoriteCreateWithoutPlaceInput, PlaceFavoriteUncheckedCreateWithoutPlaceInput> | PlaceFavoriteCreateWithoutPlaceInput[] | PlaceFavoriteUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceFavoriteCreateOrConnectWithoutPlaceInput | PlaceFavoriteCreateOrConnectWithoutPlaceInput[]
    createMany?: PlaceFavoriteCreateManyPlaceInputEnvelope
    connect?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
  }

  export type CityCreateNestedOneWithoutPlacesInput = {
    create?: XOR<CityCreateWithoutPlacesInput, CityUncheckedCreateWithoutPlacesInput>
    connectOrCreate?: CityCreateOrConnectWithoutPlacesInput
    connect?: CityWhereUniqueInput
  }

  export type ScheduleUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<ScheduleCreateWithoutPlaceInput, ScheduleUncheckedCreateWithoutPlaceInput> | ScheduleCreateWithoutPlaceInput[] | ScheduleUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutPlaceInput | ScheduleCreateOrConnectWithoutPlaceInput[]
    createMany?: ScheduleCreateManyPlaceInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<GameCreateWithoutPlaceInput, GameUncheckedCreateWithoutPlaceInput> | GameCreateWithoutPlaceInput[] | GameUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: GameCreateOrConnectWithoutPlaceInput | GameCreateOrConnectWithoutPlaceInput[]
    createMany?: GameCreateManyPlaceInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type PlaceCoversUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<PlaceCoversCreateWithoutPlaceInput, PlaceCoversUncheckedCreateWithoutPlaceInput> | PlaceCoversCreateWithoutPlaceInput[] | PlaceCoversUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceCoversCreateOrConnectWithoutPlaceInput | PlaceCoversCreateOrConnectWithoutPlaceInput[]
    createMany?: PlaceCoversCreateManyPlaceInputEnvelope
    connect?: PlaceCoversWhereUniqueInput | PlaceCoversWhereUniqueInput[]
  }

  export type PlaceSportUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<PlaceSportCreateWithoutPlaceInput, PlaceSportUncheckedCreateWithoutPlaceInput> | PlaceSportCreateWithoutPlaceInput[] | PlaceSportUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceSportCreateOrConnectWithoutPlaceInput | PlaceSportCreateOrConnectWithoutPlaceInput[]
    createMany?: PlaceSportCreateManyPlaceInputEnvelope
    connect?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
  }

  export type PlaceFavoriteUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<PlaceFavoriteCreateWithoutPlaceInput, PlaceFavoriteUncheckedCreateWithoutPlaceInput> | PlaceFavoriteCreateWithoutPlaceInput[] | PlaceFavoriteUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceFavoriteCreateOrConnectWithoutPlaceInput | PlaceFavoriteCreateOrConnectWithoutPlaceInput[]
    createMany?: PlaceFavoriteCreateManyPlaceInputEnvelope
    connect?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPlacesNestedInput = {
    create?: XOR<UserCreateWithoutPlacesInput, UserUncheckedCreateWithoutPlacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlacesInput
    upsert?: UserUpsertWithoutPlacesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlacesInput, UserUpdateWithoutPlacesInput>, UserUncheckedUpdateWithoutPlacesInput>
  }

  export type ScheduleUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<ScheduleCreateWithoutPlaceInput, ScheduleUncheckedCreateWithoutPlaceInput> | ScheduleCreateWithoutPlaceInput[] | ScheduleUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutPlaceInput | ScheduleCreateOrConnectWithoutPlaceInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutPlaceInput | ScheduleUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: ScheduleCreateManyPlaceInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutPlaceInput | ScheduleUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutPlaceInput | ScheduleUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type GameUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<GameCreateWithoutPlaceInput, GameUncheckedCreateWithoutPlaceInput> | GameCreateWithoutPlaceInput[] | GameUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: GameCreateOrConnectWithoutPlaceInput | GameCreateOrConnectWithoutPlaceInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutPlaceInput | GameUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: GameCreateManyPlaceInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutPlaceInput | GameUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: GameUpdateManyWithWhereWithoutPlaceInput | GameUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type PlaceCoversUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<PlaceCoversCreateWithoutPlaceInput, PlaceCoversUncheckedCreateWithoutPlaceInput> | PlaceCoversCreateWithoutPlaceInput[] | PlaceCoversUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceCoversCreateOrConnectWithoutPlaceInput | PlaceCoversCreateOrConnectWithoutPlaceInput[]
    upsert?: PlaceCoversUpsertWithWhereUniqueWithoutPlaceInput | PlaceCoversUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: PlaceCoversCreateManyPlaceInputEnvelope
    set?: PlaceCoversWhereUniqueInput | PlaceCoversWhereUniqueInput[]
    disconnect?: PlaceCoversWhereUniqueInput | PlaceCoversWhereUniqueInput[]
    delete?: PlaceCoversWhereUniqueInput | PlaceCoversWhereUniqueInput[]
    connect?: PlaceCoversWhereUniqueInput | PlaceCoversWhereUniqueInput[]
    update?: PlaceCoversUpdateWithWhereUniqueWithoutPlaceInput | PlaceCoversUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: PlaceCoversUpdateManyWithWhereWithoutPlaceInput | PlaceCoversUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: PlaceCoversScalarWhereInput | PlaceCoversScalarWhereInput[]
  }

  export type PlaceSportUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<PlaceSportCreateWithoutPlaceInput, PlaceSportUncheckedCreateWithoutPlaceInput> | PlaceSportCreateWithoutPlaceInput[] | PlaceSportUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceSportCreateOrConnectWithoutPlaceInput | PlaceSportCreateOrConnectWithoutPlaceInput[]
    upsert?: PlaceSportUpsertWithWhereUniqueWithoutPlaceInput | PlaceSportUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: PlaceSportCreateManyPlaceInputEnvelope
    set?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    disconnect?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    delete?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    connect?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    update?: PlaceSportUpdateWithWhereUniqueWithoutPlaceInput | PlaceSportUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: PlaceSportUpdateManyWithWhereWithoutPlaceInput | PlaceSportUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: PlaceSportScalarWhereInput | PlaceSportScalarWhereInput[]
  }

  export type PlaceFavoriteUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<PlaceFavoriteCreateWithoutPlaceInput, PlaceFavoriteUncheckedCreateWithoutPlaceInput> | PlaceFavoriteCreateWithoutPlaceInput[] | PlaceFavoriteUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceFavoriteCreateOrConnectWithoutPlaceInput | PlaceFavoriteCreateOrConnectWithoutPlaceInput[]
    upsert?: PlaceFavoriteUpsertWithWhereUniqueWithoutPlaceInput | PlaceFavoriteUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: PlaceFavoriteCreateManyPlaceInputEnvelope
    set?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    disconnect?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    delete?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    connect?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    update?: PlaceFavoriteUpdateWithWhereUniqueWithoutPlaceInput | PlaceFavoriteUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: PlaceFavoriteUpdateManyWithWhereWithoutPlaceInput | PlaceFavoriteUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: PlaceFavoriteScalarWhereInput | PlaceFavoriteScalarWhereInput[]
  }

  export type CityUpdateOneRequiredWithoutPlacesNestedInput = {
    create?: XOR<CityCreateWithoutPlacesInput, CityUncheckedCreateWithoutPlacesInput>
    connectOrCreate?: CityCreateOrConnectWithoutPlacesInput
    upsert?: CityUpsertWithoutPlacesInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutPlacesInput, CityUpdateWithoutPlacesInput>, CityUncheckedUpdateWithoutPlacesInput>
  }

  export type ScheduleUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<ScheduleCreateWithoutPlaceInput, ScheduleUncheckedCreateWithoutPlaceInput> | ScheduleCreateWithoutPlaceInput[] | ScheduleUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutPlaceInput | ScheduleCreateOrConnectWithoutPlaceInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutPlaceInput | ScheduleUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: ScheduleCreateManyPlaceInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutPlaceInput | ScheduleUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutPlaceInput | ScheduleUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<GameCreateWithoutPlaceInput, GameUncheckedCreateWithoutPlaceInput> | GameCreateWithoutPlaceInput[] | GameUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: GameCreateOrConnectWithoutPlaceInput | GameCreateOrConnectWithoutPlaceInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutPlaceInput | GameUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: GameCreateManyPlaceInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutPlaceInput | GameUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: GameUpdateManyWithWhereWithoutPlaceInput | GameUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type PlaceCoversUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<PlaceCoversCreateWithoutPlaceInput, PlaceCoversUncheckedCreateWithoutPlaceInput> | PlaceCoversCreateWithoutPlaceInput[] | PlaceCoversUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceCoversCreateOrConnectWithoutPlaceInput | PlaceCoversCreateOrConnectWithoutPlaceInput[]
    upsert?: PlaceCoversUpsertWithWhereUniqueWithoutPlaceInput | PlaceCoversUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: PlaceCoversCreateManyPlaceInputEnvelope
    set?: PlaceCoversWhereUniqueInput | PlaceCoversWhereUniqueInput[]
    disconnect?: PlaceCoversWhereUniqueInput | PlaceCoversWhereUniqueInput[]
    delete?: PlaceCoversWhereUniqueInput | PlaceCoversWhereUniqueInput[]
    connect?: PlaceCoversWhereUniqueInput | PlaceCoversWhereUniqueInput[]
    update?: PlaceCoversUpdateWithWhereUniqueWithoutPlaceInput | PlaceCoversUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: PlaceCoversUpdateManyWithWhereWithoutPlaceInput | PlaceCoversUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: PlaceCoversScalarWhereInput | PlaceCoversScalarWhereInput[]
  }

  export type PlaceSportUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<PlaceSportCreateWithoutPlaceInput, PlaceSportUncheckedCreateWithoutPlaceInput> | PlaceSportCreateWithoutPlaceInput[] | PlaceSportUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceSportCreateOrConnectWithoutPlaceInput | PlaceSportCreateOrConnectWithoutPlaceInput[]
    upsert?: PlaceSportUpsertWithWhereUniqueWithoutPlaceInput | PlaceSportUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: PlaceSportCreateManyPlaceInputEnvelope
    set?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    disconnect?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    delete?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    connect?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    update?: PlaceSportUpdateWithWhereUniqueWithoutPlaceInput | PlaceSportUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: PlaceSportUpdateManyWithWhereWithoutPlaceInput | PlaceSportUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: PlaceSportScalarWhereInput | PlaceSportScalarWhereInput[]
  }

  export type PlaceFavoriteUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<PlaceFavoriteCreateWithoutPlaceInput, PlaceFavoriteUncheckedCreateWithoutPlaceInput> | PlaceFavoriteCreateWithoutPlaceInput[] | PlaceFavoriteUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: PlaceFavoriteCreateOrConnectWithoutPlaceInput | PlaceFavoriteCreateOrConnectWithoutPlaceInput[]
    upsert?: PlaceFavoriteUpsertWithWhereUniqueWithoutPlaceInput | PlaceFavoriteUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: PlaceFavoriteCreateManyPlaceInputEnvelope
    set?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    disconnect?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    delete?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    connect?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    update?: PlaceFavoriteUpdateWithWhereUniqueWithoutPlaceInput | PlaceFavoriteUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: PlaceFavoriteUpdateManyWithWhereWithoutPlaceInput | PlaceFavoriteUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: PlaceFavoriteScalarWhereInput | PlaceFavoriteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFavoritePlacesInput = {
    create?: XOR<UserCreateWithoutFavoritePlacesInput, UserUncheckedCreateWithoutFavoritePlacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritePlacesInput
    connect?: UserWhereUniqueInput
  }

  export type PlaceCreateNestedOneWithoutFavoritedUsersInput = {
    create?: XOR<PlaceCreateWithoutFavoritedUsersInput, PlaceUncheckedCreateWithoutFavoritedUsersInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutFavoritedUsersInput
    connect?: PlaceWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoritePlacesNestedInput = {
    create?: XOR<UserCreateWithoutFavoritePlacesInput, UserUncheckedCreateWithoutFavoritePlacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritePlacesInput
    upsert?: UserUpsertWithoutFavoritePlacesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoritePlacesInput, UserUpdateWithoutFavoritePlacesInput>, UserUncheckedUpdateWithoutFavoritePlacesInput>
  }

  export type PlaceUpdateOneRequiredWithoutFavoritedUsersNestedInput = {
    create?: XOR<PlaceCreateWithoutFavoritedUsersInput, PlaceUncheckedCreateWithoutFavoritedUsersInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutFavoritedUsersInput
    upsert?: PlaceUpsertWithoutFavoritedUsersInput
    connect?: PlaceWhereUniqueInput
    update?: XOR<XOR<PlaceUpdateToOneWithWhereWithoutFavoritedUsersInput, PlaceUpdateWithoutFavoritedUsersInput>, PlaceUncheckedUpdateWithoutFavoritedUsersInput>
  }

  export type PlaceCreateNestedOneWithoutCoversInput = {
    create?: XOR<PlaceCreateWithoutCoversInput, PlaceUncheckedCreateWithoutCoversInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutCoversInput
    connect?: PlaceWhereUniqueInput
  }

  export type PlaceUpdateOneRequiredWithoutCoversNestedInput = {
    create?: XOR<PlaceCreateWithoutCoversInput, PlaceUncheckedCreateWithoutCoversInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutCoversInput
    upsert?: PlaceUpsertWithoutCoversInput
    connect?: PlaceWhereUniqueInput
    update?: XOR<XOR<PlaceUpdateToOneWithWhereWithoutCoversInput, PlaceUpdateWithoutCoversInput>, PlaceUncheckedUpdateWithoutCoversInput>
  }

  export type SportCreateNestedOneWithoutPlacesInput = {
    create?: XOR<SportCreateWithoutPlacesInput, SportUncheckedCreateWithoutPlacesInput>
    connectOrCreate?: SportCreateOrConnectWithoutPlacesInput
    connect?: SportWhereUniqueInput
  }

  export type PlaceCreateNestedOneWithoutSportsInput = {
    create?: XOR<PlaceCreateWithoutSportsInput, PlaceUncheckedCreateWithoutSportsInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutSportsInput
    connect?: PlaceWhereUniqueInput
  }

  export type SportUpdateOneRequiredWithoutPlacesNestedInput = {
    create?: XOR<SportCreateWithoutPlacesInput, SportUncheckedCreateWithoutPlacesInput>
    connectOrCreate?: SportCreateOrConnectWithoutPlacesInput
    upsert?: SportUpsertWithoutPlacesInput
    connect?: SportWhereUniqueInput
    update?: XOR<XOR<SportUpdateToOneWithWhereWithoutPlacesInput, SportUpdateWithoutPlacesInput>, SportUncheckedUpdateWithoutPlacesInput>
  }

  export type PlaceUpdateOneRequiredWithoutSportsNestedInput = {
    create?: XOR<PlaceCreateWithoutSportsInput, PlaceUncheckedCreateWithoutSportsInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutSportsInput
    upsert?: PlaceUpsertWithoutSportsInput
    connect?: PlaceWhereUniqueInput
    update?: XOR<XOR<PlaceUpdateToOneWithWhereWithoutSportsInput, PlaceUpdateWithoutSportsInput>, PlaceUncheckedUpdateWithoutSportsInput>
  }

  export type PlaceCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<PlaceCreateWithoutSchedulesInput, PlaceUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutSchedulesInput
    connect?: PlaceWhereUniqueInput
  }

  export type TimeSlotCreateNestedManyWithoutScheduleInput = {
    create?: XOR<TimeSlotCreateWithoutScheduleInput, TimeSlotUncheckedCreateWithoutScheduleInput> | TimeSlotCreateWithoutScheduleInput[] | TimeSlotUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutScheduleInput | TimeSlotCreateOrConnectWithoutScheduleInput[]
    createMany?: TimeSlotCreateManyScheduleInputEnvelope
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
  }

  export type TimeSlotUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<TimeSlotCreateWithoutScheduleInput, TimeSlotUncheckedCreateWithoutScheduleInput> | TimeSlotCreateWithoutScheduleInput[] | TimeSlotUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutScheduleInput | TimeSlotCreateOrConnectWithoutScheduleInput[]
    createMany?: TimeSlotCreateManyScheduleInputEnvelope
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumCalendarRepeatModeFieldUpdateOperationsInput = {
    set?: $Enums.CalendarRepeatMode
  }

  export type EnumWorkTimeModeFieldUpdateOperationsInput = {
    set?: $Enums.WorkTimeMode
  }

  export type EnumScheduleStatusFieldUpdateOperationsInput = {
    set?: $Enums.ScheduleStatus
  }

  export type PlaceUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<PlaceCreateWithoutSchedulesInput, PlaceUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutSchedulesInput
    upsert?: PlaceUpsertWithoutSchedulesInput
    connect?: PlaceWhereUniqueInput
    update?: XOR<XOR<PlaceUpdateToOneWithWhereWithoutSchedulesInput, PlaceUpdateWithoutSchedulesInput>, PlaceUncheckedUpdateWithoutSchedulesInput>
  }

  export type TimeSlotUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<TimeSlotCreateWithoutScheduleInput, TimeSlotUncheckedCreateWithoutScheduleInput> | TimeSlotCreateWithoutScheduleInput[] | TimeSlotUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutScheduleInput | TimeSlotCreateOrConnectWithoutScheduleInput[]
    upsert?: TimeSlotUpsertWithWhereUniqueWithoutScheduleInput | TimeSlotUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: TimeSlotCreateManyScheduleInputEnvelope
    set?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    disconnect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    delete?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    update?: TimeSlotUpdateWithWhereUniqueWithoutScheduleInput | TimeSlotUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: TimeSlotUpdateManyWithWhereWithoutScheduleInput | TimeSlotUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
  }

  export type TimeSlotUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<TimeSlotCreateWithoutScheduleInput, TimeSlotUncheckedCreateWithoutScheduleInput> | TimeSlotCreateWithoutScheduleInput[] | TimeSlotUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: TimeSlotCreateOrConnectWithoutScheduleInput | TimeSlotCreateOrConnectWithoutScheduleInput[]
    upsert?: TimeSlotUpsertWithWhereUniqueWithoutScheduleInput | TimeSlotUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: TimeSlotCreateManyScheduleInputEnvelope
    set?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    disconnect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    delete?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    connect?: TimeSlotWhereUniqueInput | TimeSlotWhereUniqueInput[]
    update?: TimeSlotUpdateWithWhereUniqueWithoutScheduleInput | TimeSlotUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: TimeSlotUpdateManyWithWhereWithoutScheduleInput | TimeSlotUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
  }

  export type ScheduleCreateNestedOneWithoutTimeSlotsInput = {
    create?: XOR<ScheduleCreateWithoutTimeSlotsInput, ScheduleUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutTimeSlotsInput
    connect?: ScheduleWhereUniqueInput
  }

  export type ScheduleUpdateOneRequiredWithoutTimeSlotsNestedInput = {
    create?: XOR<ScheduleCreateWithoutTimeSlotsInput, ScheduleUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutTimeSlotsInput
    upsert?: ScheduleUpsertWithoutTimeSlotsInput
    connect?: ScheduleWhereUniqueInput
    update?: XOR<XOR<ScheduleUpdateToOneWithWhereWithoutTimeSlotsInput, ScheduleUpdateWithoutTimeSlotsInput>, ScheduleUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type PlaceSportCreateNestedManyWithoutSportInput = {
    create?: XOR<PlaceSportCreateWithoutSportInput, PlaceSportUncheckedCreateWithoutSportInput> | PlaceSportCreateWithoutSportInput[] | PlaceSportUncheckedCreateWithoutSportInput[]
    connectOrCreate?: PlaceSportCreateOrConnectWithoutSportInput | PlaceSportCreateOrConnectWithoutSportInput[]
    createMany?: PlaceSportCreateManySportInputEnvelope
    connect?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
  }

  export type GameCreateNestedManyWithoutSportInput = {
    create?: XOR<GameCreateWithoutSportInput, GameUncheckedCreateWithoutSportInput> | GameCreateWithoutSportInput[] | GameUncheckedCreateWithoutSportInput[]
    connectOrCreate?: GameCreateOrConnectWithoutSportInput | GameCreateOrConnectWithoutSportInput[]
    createMany?: GameCreateManySportInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type UserSportCreateNestedManyWithoutSportInput = {
    create?: XOR<UserSportCreateWithoutSportInput, UserSportUncheckedCreateWithoutSportInput> | UserSportCreateWithoutSportInput[] | UserSportUncheckedCreateWithoutSportInput[]
    connectOrCreate?: UserSportCreateOrConnectWithoutSportInput | UserSportCreateOrConnectWithoutSportInput[]
    createMany?: UserSportCreateManySportInputEnvelope
    connect?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
  }

  export type PlaceSportUncheckedCreateNestedManyWithoutSportInput = {
    create?: XOR<PlaceSportCreateWithoutSportInput, PlaceSportUncheckedCreateWithoutSportInput> | PlaceSportCreateWithoutSportInput[] | PlaceSportUncheckedCreateWithoutSportInput[]
    connectOrCreate?: PlaceSportCreateOrConnectWithoutSportInput | PlaceSportCreateOrConnectWithoutSportInput[]
    createMany?: PlaceSportCreateManySportInputEnvelope
    connect?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
  }

  export type GameUncheckedCreateNestedManyWithoutSportInput = {
    create?: XOR<GameCreateWithoutSportInput, GameUncheckedCreateWithoutSportInput> | GameCreateWithoutSportInput[] | GameUncheckedCreateWithoutSportInput[]
    connectOrCreate?: GameCreateOrConnectWithoutSportInput | GameCreateOrConnectWithoutSportInput[]
    createMany?: GameCreateManySportInputEnvelope
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
  }

  export type UserSportUncheckedCreateNestedManyWithoutSportInput = {
    create?: XOR<UserSportCreateWithoutSportInput, UserSportUncheckedCreateWithoutSportInput> | UserSportCreateWithoutSportInput[] | UserSportUncheckedCreateWithoutSportInput[]
    connectOrCreate?: UserSportCreateOrConnectWithoutSportInput | UserSportCreateOrConnectWithoutSportInput[]
    createMany?: UserSportCreateManySportInputEnvelope
    connect?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
  }

  export type PlaceSportUpdateManyWithoutSportNestedInput = {
    create?: XOR<PlaceSportCreateWithoutSportInput, PlaceSportUncheckedCreateWithoutSportInput> | PlaceSportCreateWithoutSportInput[] | PlaceSportUncheckedCreateWithoutSportInput[]
    connectOrCreate?: PlaceSportCreateOrConnectWithoutSportInput | PlaceSportCreateOrConnectWithoutSportInput[]
    upsert?: PlaceSportUpsertWithWhereUniqueWithoutSportInput | PlaceSportUpsertWithWhereUniqueWithoutSportInput[]
    createMany?: PlaceSportCreateManySportInputEnvelope
    set?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    disconnect?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    delete?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    connect?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    update?: PlaceSportUpdateWithWhereUniqueWithoutSportInput | PlaceSportUpdateWithWhereUniqueWithoutSportInput[]
    updateMany?: PlaceSportUpdateManyWithWhereWithoutSportInput | PlaceSportUpdateManyWithWhereWithoutSportInput[]
    deleteMany?: PlaceSportScalarWhereInput | PlaceSportScalarWhereInput[]
  }

  export type GameUpdateManyWithoutSportNestedInput = {
    create?: XOR<GameCreateWithoutSportInput, GameUncheckedCreateWithoutSportInput> | GameCreateWithoutSportInput[] | GameUncheckedCreateWithoutSportInput[]
    connectOrCreate?: GameCreateOrConnectWithoutSportInput | GameCreateOrConnectWithoutSportInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutSportInput | GameUpsertWithWhereUniqueWithoutSportInput[]
    createMany?: GameCreateManySportInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutSportInput | GameUpdateWithWhereUniqueWithoutSportInput[]
    updateMany?: GameUpdateManyWithWhereWithoutSportInput | GameUpdateManyWithWhereWithoutSportInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type UserSportUpdateManyWithoutSportNestedInput = {
    create?: XOR<UserSportCreateWithoutSportInput, UserSportUncheckedCreateWithoutSportInput> | UserSportCreateWithoutSportInput[] | UserSportUncheckedCreateWithoutSportInput[]
    connectOrCreate?: UserSportCreateOrConnectWithoutSportInput | UserSportCreateOrConnectWithoutSportInput[]
    upsert?: UserSportUpsertWithWhereUniqueWithoutSportInput | UserSportUpsertWithWhereUniqueWithoutSportInput[]
    createMany?: UserSportCreateManySportInputEnvelope
    set?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    disconnect?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    delete?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    connect?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    update?: UserSportUpdateWithWhereUniqueWithoutSportInput | UserSportUpdateWithWhereUniqueWithoutSportInput[]
    updateMany?: UserSportUpdateManyWithWhereWithoutSportInput | UserSportUpdateManyWithWhereWithoutSportInput[]
    deleteMany?: UserSportScalarWhereInput | UserSportScalarWhereInput[]
  }

  export type PlaceSportUncheckedUpdateManyWithoutSportNestedInput = {
    create?: XOR<PlaceSportCreateWithoutSportInput, PlaceSportUncheckedCreateWithoutSportInput> | PlaceSportCreateWithoutSportInput[] | PlaceSportUncheckedCreateWithoutSportInput[]
    connectOrCreate?: PlaceSportCreateOrConnectWithoutSportInput | PlaceSportCreateOrConnectWithoutSportInput[]
    upsert?: PlaceSportUpsertWithWhereUniqueWithoutSportInput | PlaceSportUpsertWithWhereUniqueWithoutSportInput[]
    createMany?: PlaceSportCreateManySportInputEnvelope
    set?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    disconnect?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    delete?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    connect?: PlaceSportWhereUniqueInput | PlaceSportWhereUniqueInput[]
    update?: PlaceSportUpdateWithWhereUniqueWithoutSportInput | PlaceSportUpdateWithWhereUniqueWithoutSportInput[]
    updateMany?: PlaceSportUpdateManyWithWhereWithoutSportInput | PlaceSportUpdateManyWithWhereWithoutSportInput[]
    deleteMany?: PlaceSportScalarWhereInput | PlaceSportScalarWhereInput[]
  }

  export type GameUncheckedUpdateManyWithoutSportNestedInput = {
    create?: XOR<GameCreateWithoutSportInput, GameUncheckedCreateWithoutSportInput> | GameCreateWithoutSportInput[] | GameUncheckedCreateWithoutSportInput[]
    connectOrCreate?: GameCreateOrConnectWithoutSportInput | GameCreateOrConnectWithoutSportInput[]
    upsert?: GameUpsertWithWhereUniqueWithoutSportInput | GameUpsertWithWhereUniqueWithoutSportInput[]
    createMany?: GameCreateManySportInputEnvelope
    set?: GameWhereUniqueInput | GameWhereUniqueInput[]
    disconnect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    delete?: GameWhereUniqueInput | GameWhereUniqueInput[]
    connect?: GameWhereUniqueInput | GameWhereUniqueInput[]
    update?: GameUpdateWithWhereUniqueWithoutSportInput | GameUpdateWithWhereUniqueWithoutSportInput[]
    updateMany?: GameUpdateManyWithWhereWithoutSportInput | GameUpdateManyWithWhereWithoutSportInput[]
    deleteMany?: GameScalarWhereInput | GameScalarWhereInput[]
  }

  export type UserSportUncheckedUpdateManyWithoutSportNestedInput = {
    create?: XOR<UserSportCreateWithoutSportInput, UserSportUncheckedCreateWithoutSportInput> | UserSportCreateWithoutSportInput[] | UserSportUncheckedCreateWithoutSportInput[]
    connectOrCreate?: UserSportCreateOrConnectWithoutSportInput | UserSportCreateOrConnectWithoutSportInput[]
    upsert?: UserSportUpsertWithWhereUniqueWithoutSportInput | UserSportUpsertWithWhereUniqueWithoutSportInput[]
    createMany?: UserSportCreateManySportInputEnvelope
    set?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    disconnect?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    delete?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    connect?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    update?: UserSportUpdateWithWhereUniqueWithoutSportInput | UserSportUpdateWithWhereUniqueWithoutSportInput[]
    updateMany?: UserSportUpdateManyWithWhereWithoutSportInput | UserSportUpdateManyWithWhereWithoutSportInput[]
    deleteMany?: UserSportScalarWhereInput | UserSportScalarWhereInput[]
  }

  export type GameUserCreateNestedManyWithoutUserInput = {
    create?: XOR<GameUserCreateWithoutUserInput, GameUserUncheckedCreateWithoutUserInput> | GameUserCreateWithoutUserInput[] | GameUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutUserInput | GameUserCreateOrConnectWithoutUserInput[]
    createMany?: GameUserCreateManyUserInputEnvelope
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
  }

  export type PlaceCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PlaceCreateWithoutOwnerInput, PlaceUncheckedCreateWithoutOwnerInput> | PlaceCreateWithoutOwnerInput[] | PlaceUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutOwnerInput | PlaceCreateOrConnectWithoutOwnerInput[]
    createMany?: PlaceCreateManyOwnerInputEnvelope
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
  }

  export type PlaceFavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaceFavoriteCreateWithoutUserInput, PlaceFavoriteUncheckedCreateWithoutUserInput> | PlaceFavoriteCreateWithoutUserInput[] | PlaceFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaceFavoriteCreateOrConnectWithoutUserInput | PlaceFavoriteCreateOrConnectWithoutUserInput[]
    createMany?: PlaceFavoriteCreateManyUserInputEnvelope
    connect?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
  }

  export type UserSportCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSportCreateWithoutUserInput, UserSportUncheckedCreateWithoutUserInput> | UserSportCreateWithoutUserInput[] | UserSportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSportCreateOrConnectWithoutUserInput | UserSportCreateOrConnectWithoutUserInput[]
    createMany?: UserSportCreateManyUserInputEnvelope
    connect?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
  }

  export type UserFavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type UserFavoriteCreateNestedManyWithoutFavoriteInput = {
    create?: XOR<UserFavoriteCreateWithoutFavoriteInput, UserFavoriteUncheckedCreateWithoutFavoriteInput> | UserFavoriteCreateWithoutFavoriteInput[] | UserFavoriteUncheckedCreateWithoutFavoriteInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutFavoriteInput | UserFavoriteCreateOrConnectWithoutFavoriteInput[]
    createMany?: UserFavoriteCreateManyFavoriteInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type GameUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GameUserCreateWithoutUserInput, GameUserUncheckedCreateWithoutUserInput> | GameUserCreateWithoutUserInput[] | GameUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutUserInput | GameUserCreateOrConnectWithoutUserInput[]
    createMany?: GameUserCreateManyUserInputEnvelope
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
  }

  export type PlaceUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PlaceCreateWithoutOwnerInput, PlaceUncheckedCreateWithoutOwnerInput> | PlaceCreateWithoutOwnerInput[] | PlaceUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutOwnerInput | PlaceCreateOrConnectWithoutOwnerInput[]
    createMany?: PlaceCreateManyOwnerInputEnvelope
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
  }

  export type PlaceFavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaceFavoriteCreateWithoutUserInput, PlaceFavoriteUncheckedCreateWithoutUserInput> | PlaceFavoriteCreateWithoutUserInput[] | PlaceFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaceFavoriteCreateOrConnectWithoutUserInput | PlaceFavoriteCreateOrConnectWithoutUserInput[]
    createMany?: PlaceFavoriteCreateManyUserInputEnvelope
    connect?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
  }

  export type UserSportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSportCreateWithoutUserInput, UserSportUncheckedCreateWithoutUserInput> | UserSportCreateWithoutUserInput[] | UserSportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSportCreateOrConnectWithoutUserInput | UserSportCreateOrConnectWithoutUserInput[]
    createMany?: UserSportCreateManyUserInputEnvelope
    connect?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
  }

  export type UserFavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type UserFavoriteUncheckedCreateNestedManyWithoutFavoriteInput = {
    create?: XOR<UserFavoriteCreateWithoutFavoriteInput, UserFavoriteUncheckedCreateWithoutFavoriteInput> | UserFavoriteCreateWithoutFavoriteInput[] | UserFavoriteUncheckedCreateWithoutFavoriteInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutFavoriteInput | UserFavoriteCreateOrConnectWithoutFavoriteInput[]
    createMany?: UserFavoriteCreateManyFavoriteInputEnvelope
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
  }

  export type GameUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameUserCreateWithoutUserInput, GameUserUncheckedCreateWithoutUserInput> | GameUserCreateWithoutUserInput[] | GameUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutUserInput | GameUserCreateOrConnectWithoutUserInput[]
    upsert?: GameUserUpsertWithWhereUniqueWithoutUserInput | GameUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameUserCreateManyUserInputEnvelope
    set?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    disconnect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    delete?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    update?: GameUserUpdateWithWhereUniqueWithoutUserInput | GameUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameUserUpdateManyWithWhereWithoutUserInput | GameUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameUserScalarWhereInput | GameUserScalarWhereInput[]
  }

  export type PlaceUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PlaceCreateWithoutOwnerInput, PlaceUncheckedCreateWithoutOwnerInput> | PlaceCreateWithoutOwnerInput[] | PlaceUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutOwnerInput | PlaceCreateOrConnectWithoutOwnerInput[]
    upsert?: PlaceUpsertWithWhereUniqueWithoutOwnerInput | PlaceUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PlaceCreateManyOwnerInputEnvelope
    set?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    disconnect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    delete?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    update?: PlaceUpdateWithWhereUniqueWithoutOwnerInput | PlaceUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PlaceUpdateManyWithWhereWithoutOwnerInput | PlaceUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
  }

  export type PlaceFavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaceFavoriteCreateWithoutUserInput, PlaceFavoriteUncheckedCreateWithoutUserInput> | PlaceFavoriteCreateWithoutUserInput[] | PlaceFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaceFavoriteCreateOrConnectWithoutUserInput | PlaceFavoriteCreateOrConnectWithoutUserInput[]
    upsert?: PlaceFavoriteUpsertWithWhereUniqueWithoutUserInput | PlaceFavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaceFavoriteCreateManyUserInputEnvelope
    set?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    disconnect?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    delete?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    connect?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    update?: PlaceFavoriteUpdateWithWhereUniqueWithoutUserInput | PlaceFavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaceFavoriteUpdateManyWithWhereWithoutUserInput | PlaceFavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaceFavoriteScalarWhereInput | PlaceFavoriteScalarWhereInput[]
  }

  export type UserSportUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSportCreateWithoutUserInput, UserSportUncheckedCreateWithoutUserInput> | UserSportCreateWithoutUserInput[] | UserSportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSportCreateOrConnectWithoutUserInput | UserSportCreateOrConnectWithoutUserInput[]
    upsert?: UserSportUpsertWithWhereUniqueWithoutUserInput | UserSportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSportCreateManyUserInputEnvelope
    set?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    disconnect?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    delete?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    connect?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    update?: UserSportUpdateWithWhereUniqueWithoutUserInput | UserSportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSportUpdateManyWithWhereWithoutUserInput | UserSportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSportScalarWhereInput | UserSportScalarWhereInput[]
  }

  export type UserFavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutUserInput | UserFavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutUserInput | UserFavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutUserInput | UserFavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type UserFavoriteUpdateManyWithoutFavoriteNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutFavoriteInput, UserFavoriteUncheckedCreateWithoutFavoriteInput> | UserFavoriteCreateWithoutFavoriteInput[] | UserFavoriteUncheckedCreateWithoutFavoriteInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutFavoriteInput | UserFavoriteCreateOrConnectWithoutFavoriteInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutFavoriteInput | UserFavoriteUpsertWithWhereUniqueWithoutFavoriteInput[]
    createMany?: UserFavoriteCreateManyFavoriteInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutFavoriteInput | UserFavoriteUpdateWithWhereUniqueWithoutFavoriteInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutFavoriteInput | UserFavoriteUpdateManyWithWhereWithoutFavoriteInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type GameUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GameUserCreateWithoutUserInput, GameUserUncheckedCreateWithoutUserInput> | GameUserCreateWithoutUserInput[] | GameUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GameUserCreateOrConnectWithoutUserInput | GameUserCreateOrConnectWithoutUserInput[]
    upsert?: GameUserUpsertWithWhereUniqueWithoutUserInput | GameUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GameUserCreateManyUserInputEnvelope
    set?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    disconnect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    delete?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    connect?: GameUserWhereUniqueInput | GameUserWhereUniqueInput[]
    update?: GameUserUpdateWithWhereUniqueWithoutUserInput | GameUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GameUserUpdateManyWithWhereWithoutUserInput | GameUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GameUserScalarWhereInput | GameUserScalarWhereInput[]
  }

  export type PlaceUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PlaceCreateWithoutOwnerInput, PlaceUncheckedCreateWithoutOwnerInput> | PlaceCreateWithoutOwnerInput[] | PlaceUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutOwnerInput | PlaceCreateOrConnectWithoutOwnerInput[]
    upsert?: PlaceUpsertWithWhereUniqueWithoutOwnerInput | PlaceUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PlaceCreateManyOwnerInputEnvelope
    set?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    disconnect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    delete?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    update?: PlaceUpdateWithWhereUniqueWithoutOwnerInput | PlaceUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PlaceUpdateManyWithWhereWithoutOwnerInput | PlaceUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
  }

  export type PlaceFavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaceFavoriteCreateWithoutUserInput, PlaceFavoriteUncheckedCreateWithoutUserInput> | PlaceFavoriteCreateWithoutUserInput[] | PlaceFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaceFavoriteCreateOrConnectWithoutUserInput | PlaceFavoriteCreateOrConnectWithoutUserInput[]
    upsert?: PlaceFavoriteUpsertWithWhereUniqueWithoutUserInput | PlaceFavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaceFavoriteCreateManyUserInputEnvelope
    set?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    disconnect?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    delete?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    connect?: PlaceFavoriteWhereUniqueInput | PlaceFavoriteWhereUniqueInput[]
    update?: PlaceFavoriteUpdateWithWhereUniqueWithoutUserInput | PlaceFavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaceFavoriteUpdateManyWithWhereWithoutUserInput | PlaceFavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaceFavoriteScalarWhereInput | PlaceFavoriteScalarWhereInput[]
  }

  export type UserSportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSportCreateWithoutUserInput, UserSportUncheckedCreateWithoutUserInput> | UserSportCreateWithoutUserInput[] | UserSportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSportCreateOrConnectWithoutUserInput | UserSportCreateOrConnectWithoutUserInput[]
    upsert?: UserSportUpsertWithWhereUniqueWithoutUserInput | UserSportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSportCreateManyUserInputEnvelope
    set?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    disconnect?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    delete?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    connect?: UserSportWhereUniqueInput | UserSportWhereUniqueInput[]
    update?: UserSportUpdateWithWhereUniqueWithoutUserInput | UserSportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSportUpdateManyWithWhereWithoutUserInput | UserSportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSportScalarWhereInput | UserSportScalarWhereInput[]
  }

  export type UserFavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput> | UserFavoriteCreateWithoutUserInput[] | UserFavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutUserInput | UserFavoriteCreateOrConnectWithoutUserInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutUserInput | UserFavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFavoriteCreateManyUserInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutUserInput | UserFavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutUserInput | UserFavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type UserFavoriteUncheckedUpdateManyWithoutFavoriteNestedInput = {
    create?: XOR<UserFavoriteCreateWithoutFavoriteInput, UserFavoriteUncheckedCreateWithoutFavoriteInput> | UserFavoriteCreateWithoutFavoriteInput[] | UserFavoriteUncheckedCreateWithoutFavoriteInput[]
    connectOrCreate?: UserFavoriteCreateOrConnectWithoutFavoriteInput | UserFavoriteCreateOrConnectWithoutFavoriteInput[]
    upsert?: UserFavoriteUpsertWithWhereUniqueWithoutFavoriteInput | UserFavoriteUpsertWithWhereUniqueWithoutFavoriteInput[]
    createMany?: UserFavoriteCreateManyFavoriteInputEnvelope
    set?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    disconnect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    delete?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    connect?: UserFavoriteWhereUniqueInput | UserFavoriteWhereUniqueInput[]
    update?: UserFavoriteUpdateWithWhereUniqueWithoutFavoriteInput | UserFavoriteUpdateWithWhereUniqueWithoutFavoriteInput[]
    updateMany?: UserFavoriteUpdateManyWithWhereWithoutFavoriteInput | UserFavoriteUpdateManyWithWhereWithoutFavoriteInput[]
    deleteMany?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFavoritedByInput = {
    create?: XOR<UserCreateWithoutFavoritedByInput, UserUncheckedCreateWithoutFavoritedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    upsert?: UserUpsertWithoutFavoritesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoritesInput, UserUpdateWithoutFavoritesInput>, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateOneRequiredWithoutFavoritedByNestedInput = {
    create?: XOR<UserCreateWithoutFavoritedByInput, UserUncheckedCreateWithoutFavoritedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritedByInput
    upsert?: UserUpsertWithoutFavoritedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoritedByInput, UserUpdateWithoutFavoritedByInput>, UserUncheckedUpdateWithoutFavoritedByInput>
  }

  export type SportCreateNestedOneWithoutUsersInput = {
    create?: XOR<SportCreateWithoutUsersInput, SportUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SportCreateOrConnectWithoutUsersInput
    connect?: SportWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSportsInput = {
    create?: XOR<UserCreateWithoutSportsInput, UserUncheckedCreateWithoutSportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSportsInput
    connect?: UserWhereUniqueInput
  }

  export type SportUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<SportCreateWithoutUsersInput, SportUncheckedCreateWithoutUsersInput>
    connectOrCreate?: SportCreateOrConnectWithoutUsersInput
    upsert?: SportUpsertWithoutUsersInput
    connect?: SportWhereUniqueInput
    update?: XOR<XOR<SportUpdateToOneWithWhereWithoutUsersInput, SportUpdateWithoutUsersInput>, SportUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutSportsNestedInput = {
    create?: XOR<UserCreateWithoutSportsInput, UserUncheckedCreateWithoutSportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSportsInput
    upsert?: UserUpsertWithoutSportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSportsInput, UserUpdateWithoutSportsInput>, UserUncheckedUpdateWithoutSportsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumGameStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusFilter<$PrismaModel> | $Enums.GameStatus
  }

  export type NestedEnumGameLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.GameLevel | EnumGameLevelFieldRefInput<$PrismaModel>
    in?: $Enums.GameLevel[] | ListEnumGameLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameLevel[] | ListEnumGameLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumGameLevelFilter<$PrismaModel> | $Enums.GameLevel
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRequestModeFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestMode | EnumRequestModeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestMode[] | ListEnumRequestModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestMode[] | ListEnumRequestModeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestModeFilter<$PrismaModel> | $Enums.RequestMode
  }

  export type NestedEnumGameStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameStatus | EnumGameStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameStatus[] | ListEnumGameStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameStatusFilter<$PrismaModel>
    _max?: NestedEnumGameStatusFilter<$PrismaModel>
  }

  export type NestedEnumGameLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameLevel | EnumGameLevelFieldRefInput<$PrismaModel>
    in?: $Enums.GameLevel[] | ListEnumGameLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameLevel[] | ListEnumGameLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumGameLevelWithAggregatesFilter<$PrismaModel> | $Enums.GameLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameLevelFilter<$PrismaModel>
    _max?: NestedEnumGameLevelFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRequestModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestMode | EnumRequestModeFieldRefInput<$PrismaModel>
    in?: $Enums.RequestMode[] | ListEnumRequestModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestMode[] | ListEnumRequestModeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestModeWithAggregatesFilter<$PrismaModel> | $Enums.RequestMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestModeFilter<$PrismaModel>
    _max?: NestedEnumRequestModeFilter<$PrismaModel>
  }

  export type NestedEnumGameUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.GameUserRole | EnumGameUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GameUserRole[] | ListEnumGameUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameUserRole[] | ListEnumGameUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGameUserRoleFilter<$PrismaModel> | $Enums.GameUserRole
  }

  export type NestedEnumGameUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.GameUserStatus | EnumGameUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameUserStatus[] | ListEnumGameUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameUserStatus[] | ListEnumGameUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameUserStatusFilter<$PrismaModel> | $Enums.GameUserStatus
  }

  export type NestedEnumGameUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameUserRole | EnumGameUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GameUserRole[] | ListEnumGameUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameUserRole[] | ListEnumGameUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGameUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.GameUserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameUserRoleFilter<$PrismaModel>
    _max?: NestedEnumGameUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumGameUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GameUserStatus | EnumGameUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.GameUserStatus[] | ListEnumGameUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.GameUserStatus[] | ListEnumGameUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumGameUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.GameUserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGameUserStatusFilter<$PrismaModel>
    _max?: NestedEnumGameUserStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumCalendarRepeatModeFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarRepeatMode | EnumCalendarRepeatModeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarRepeatMode[] | ListEnumCalendarRepeatModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarRepeatMode[] | ListEnumCalendarRepeatModeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarRepeatModeFilter<$PrismaModel> | $Enums.CalendarRepeatMode
  }

  export type NestedEnumWorkTimeModeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTimeMode | EnumWorkTimeModeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTimeMode[] | ListEnumWorkTimeModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTimeMode[] | ListEnumWorkTimeModeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTimeModeFilter<$PrismaModel> | $Enums.WorkTimeMode
  }

  export type NestedEnumScheduleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleStatusFilter<$PrismaModel> | $Enums.ScheduleStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCalendarRepeatModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalendarRepeatMode | EnumCalendarRepeatModeFieldRefInput<$PrismaModel>
    in?: $Enums.CalendarRepeatMode[] | ListEnumCalendarRepeatModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalendarRepeatMode[] | ListEnumCalendarRepeatModeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalendarRepeatModeWithAggregatesFilter<$PrismaModel> | $Enums.CalendarRepeatMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalendarRepeatModeFilter<$PrismaModel>
    _max?: NestedEnumCalendarRepeatModeFilter<$PrismaModel>
  }

  export type NestedEnumWorkTimeModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkTimeMode | EnumWorkTimeModeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkTimeMode[] | ListEnumWorkTimeModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkTimeMode[] | ListEnumWorkTimeModeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTimeModeWithAggregatesFilter<$PrismaModel> | $Enums.WorkTimeMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkTimeModeFilter<$PrismaModel>
    _max?: NestedEnumWorkTimeModeFilter<$PrismaModel>
  }

  export type NestedEnumScheduleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleStatusFilter<$PrismaModel>
    _max?: NestedEnumScheduleStatusFilter<$PrismaModel>
  }

  export type PlaceCreateWithoutCityInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    latitude?: number
    longitude?: number
    owner: UserCreateNestedOneWithoutPlacesInput
    schedules?: ScheduleCreateNestedManyWithoutPlaceInput
    games?: GameCreateNestedManyWithoutPlaceInput
    covers?: PlaceCoversCreateNestedManyWithoutPlaceInput
    sports?: PlaceSportCreateNestedManyWithoutPlaceInput
    favoritedUsers?: PlaceFavoriteCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUncheckedCreateWithoutCityInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    ownerId: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    latitude?: number
    longitude?: number
    schedules?: ScheduleUncheckedCreateNestedManyWithoutPlaceInput
    games?: GameUncheckedCreateNestedManyWithoutPlaceInput
    covers?: PlaceCoversUncheckedCreateNestedManyWithoutPlaceInput
    sports?: PlaceSportUncheckedCreateNestedManyWithoutPlaceInput
    favoritedUsers?: PlaceFavoriteUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceCreateOrConnectWithoutCityInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutCityInput, PlaceUncheckedCreateWithoutCityInput>
  }

  export type PlaceCreateManyCityInputEnvelope = {
    data: PlaceCreateManyCityInput | PlaceCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type PlaceUpsertWithWhereUniqueWithoutCityInput = {
    where: PlaceWhereUniqueInput
    update: XOR<PlaceUpdateWithoutCityInput, PlaceUncheckedUpdateWithoutCityInput>
    create: XOR<PlaceCreateWithoutCityInput, PlaceUncheckedCreateWithoutCityInput>
  }

  export type PlaceUpdateWithWhereUniqueWithoutCityInput = {
    where: PlaceWhereUniqueInput
    data: XOR<PlaceUpdateWithoutCityInput, PlaceUncheckedUpdateWithoutCityInput>
  }

  export type PlaceUpdateManyWithWhereWithoutCityInput = {
    where: PlaceScalarWhereInput
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyWithoutCityInput>
  }

  export type PlaceScalarWhereInput = {
    AND?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
    OR?: PlaceScalarWhereInput[]
    NOT?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
    id?: StringFilter<"Place"> | string
    createdAt?: DateTimeFilter<"Place"> | Date | string
    updatedAt?: DateTimeFilter<"Place"> | Date | string
    name?: StringFilter<"Place"> | string
    description?: StringFilter<"Place"> | string
    ownerId?: StringFilter<"Place"> | string
    isIndoor?: BoolNullableFilter<"Place"> | boolean | null
    isFree?: BoolNullableFilter<"Place"> | boolean | null
    cityId?: StringFilter<"Place"> | string
    latitude?: FloatFilter<"Place"> | number
    longitude?: FloatFilter<"Place"> | number
  }

  export type PlaceCreateWithoutGamesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    latitude?: number
    longitude?: number
    owner: UserCreateNestedOneWithoutPlacesInput
    schedules?: ScheduleCreateNestedManyWithoutPlaceInput
    covers?: PlaceCoversCreateNestedManyWithoutPlaceInput
    sports?: PlaceSportCreateNestedManyWithoutPlaceInput
    favoritedUsers?: PlaceFavoriteCreateNestedManyWithoutPlaceInput
    city: CityCreateNestedOneWithoutPlacesInput
  }

  export type PlaceUncheckedCreateWithoutGamesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    ownerId: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    cityId: string
    latitude?: number
    longitude?: number
    schedules?: ScheduleUncheckedCreateNestedManyWithoutPlaceInput
    covers?: PlaceCoversUncheckedCreateNestedManyWithoutPlaceInput
    sports?: PlaceSportUncheckedCreateNestedManyWithoutPlaceInput
    favoritedUsers?: PlaceFavoriteUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceCreateOrConnectWithoutGamesInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutGamesInput, PlaceUncheckedCreateWithoutGamesInput>
  }

  export type GameUserCreateWithoutGameInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role: $Enums.GameUserRole
    status: $Enums.GameUserStatus
    user: UserCreateNestedOneWithoutGamesInput
  }

  export type GameUserUncheckedCreateWithoutGameInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    role: $Enums.GameUserRole
    status: $Enums.GameUserStatus
  }

  export type GameUserCreateOrConnectWithoutGameInput = {
    where: GameUserWhereUniqueInput
    create: XOR<GameUserCreateWithoutGameInput, GameUserUncheckedCreateWithoutGameInput>
  }

  export type GameUserCreateManyGameInputEnvelope = {
    data: GameUserCreateManyGameInput | GameUserCreateManyGameInput[]
    skipDuplicates?: boolean
  }

  export type SportCreateWithoutGamesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    places?: PlaceSportCreateNestedManyWithoutSportInput
    users?: UserSportCreateNestedManyWithoutSportInput
  }

  export type SportUncheckedCreateWithoutGamesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    places?: PlaceSportUncheckedCreateNestedManyWithoutSportInput
    users?: UserSportUncheckedCreateNestedManyWithoutSportInput
  }

  export type SportCreateOrConnectWithoutGamesInput = {
    where: SportWhereUniqueInput
    create: XOR<SportCreateWithoutGamesInput, SportUncheckedCreateWithoutGamesInput>
  }

  export type PlaceUpsertWithoutGamesInput = {
    update: XOR<PlaceUpdateWithoutGamesInput, PlaceUncheckedUpdateWithoutGamesInput>
    create: XOR<PlaceCreateWithoutGamesInput, PlaceUncheckedCreateWithoutGamesInput>
    where?: PlaceWhereInput
  }

  export type PlaceUpdateToOneWithWhereWithoutGamesInput = {
    where?: PlaceWhereInput
    data: XOR<PlaceUpdateWithoutGamesInput, PlaceUncheckedUpdateWithoutGamesInput>
  }

  export type PlaceUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutPlacesNestedInput
    schedules?: ScheduleUpdateManyWithoutPlaceNestedInput
    covers?: PlaceCoversUpdateManyWithoutPlaceNestedInput
    sports?: PlaceSportUpdateManyWithoutPlaceNestedInput
    favoritedUsers?: PlaceFavoriteUpdateManyWithoutPlaceNestedInput
    city?: CityUpdateOneRequiredWithoutPlacesNestedInput
  }

  export type PlaceUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    schedules?: ScheduleUncheckedUpdateManyWithoutPlaceNestedInput
    covers?: PlaceCoversUncheckedUpdateManyWithoutPlaceNestedInput
    sports?: PlaceSportUncheckedUpdateManyWithoutPlaceNestedInput
    favoritedUsers?: PlaceFavoriteUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type GameUserUpsertWithWhereUniqueWithoutGameInput = {
    where: GameUserWhereUniqueInput
    update: XOR<GameUserUpdateWithoutGameInput, GameUserUncheckedUpdateWithoutGameInput>
    create: XOR<GameUserCreateWithoutGameInput, GameUserUncheckedCreateWithoutGameInput>
  }

  export type GameUserUpdateWithWhereUniqueWithoutGameInput = {
    where: GameUserWhereUniqueInput
    data: XOR<GameUserUpdateWithoutGameInput, GameUserUncheckedUpdateWithoutGameInput>
  }

  export type GameUserUpdateManyWithWhereWithoutGameInput = {
    where: GameUserScalarWhereInput
    data: XOR<GameUserUpdateManyMutationInput, GameUserUncheckedUpdateManyWithoutGameInput>
  }

  export type GameUserScalarWhereInput = {
    AND?: GameUserScalarWhereInput | GameUserScalarWhereInput[]
    OR?: GameUserScalarWhereInput[]
    NOT?: GameUserScalarWhereInput | GameUserScalarWhereInput[]
    createdAt?: DateTimeFilter<"GameUser"> | Date | string
    updatedAt?: DateTimeFilter<"GameUser"> | Date | string
    gameId?: StringFilter<"GameUser"> | string
    userId?: StringFilter<"GameUser"> | string
    role?: EnumGameUserRoleFilter<"GameUser"> | $Enums.GameUserRole
    status?: EnumGameUserStatusFilter<"GameUser"> | $Enums.GameUserStatus
  }

  export type SportUpsertWithoutGamesInput = {
    update: XOR<SportUpdateWithoutGamesInput, SportUncheckedUpdateWithoutGamesInput>
    create: XOR<SportCreateWithoutGamesInput, SportUncheckedCreateWithoutGamesInput>
    where?: SportWhereInput
  }

  export type SportUpdateToOneWithWhereWithoutGamesInput = {
    where?: SportWhereInput
    data: XOR<SportUpdateWithoutGamesInput, SportUncheckedUpdateWithoutGamesInput>
  }

  export type SportUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    places?: PlaceSportUpdateManyWithoutSportNestedInput
    users?: UserSportUpdateManyWithoutSportNestedInput
  }

  export type SportUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    places?: PlaceSportUncheckedUpdateManyWithoutSportNestedInput
    users?: UserSportUncheckedUpdateManyWithoutSportNestedInput
  }

  export type GameCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
    date: Date | string
    status?: $Enums.GameStatus
    level?: $Enums.GameLevel
    countMembersMin?: number
    countMembersMax?: number
    description?: string | null
    requestMode?: $Enums.RequestMode
    place: PlaceCreateNestedOneWithoutGamesInput
    sport?: SportCreateNestedOneWithoutGamesInput
  }

  export type GameUncheckedCreateWithoutUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
    date: Date | string
    status?: $Enums.GameStatus
    level?: $Enums.GameLevel
    countMembersMin?: number
    countMembersMax?: number
    description?: string | null
    requestMode?: $Enums.RequestMode
    placeId: string
    sportId?: string | null
  }

  export type GameCreateOrConnectWithoutUsersInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutUsersInput, GameUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutGamesInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
    places?: PlaceCreateNestedManyWithoutOwnerInput
    favoritePlaces?: PlaceFavoriteCreateNestedManyWithoutUserInput
    sports?: UserSportCreateNestedManyWithoutUserInput
    favorites?: UserFavoriteCreateNestedManyWithoutUserInput
    favoritedBy?: UserFavoriteCreateNestedManyWithoutFavoriteInput
  }

  export type UserUncheckedCreateWithoutGamesInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
    places?: PlaceUncheckedCreateNestedManyWithoutOwnerInput
    favoritePlaces?: PlaceFavoriteUncheckedCreateNestedManyWithoutUserInput
    sports?: UserSportUncheckedCreateNestedManyWithoutUserInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    favoritedBy?: UserFavoriteUncheckedCreateNestedManyWithoutFavoriteInput
  }

  export type UserCreateOrConnectWithoutGamesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGamesInput, UserUncheckedCreateWithoutGamesInput>
  }

  export type GameUpsertWithoutUsersInput = {
    update: XOR<GameUpdateWithoutUsersInput, GameUncheckedUpdateWithoutUsersInput>
    create: XOR<GameCreateWithoutUsersInput, GameUncheckedCreateWithoutUsersInput>
    where?: GameWhereInput
  }

  export type GameUpdateToOneWithWhereWithoutUsersInput = {
    where?: GameWhereInput
    data: XOR<GameUpdateWithoutUsersInput, GameUncheckedUpdateWithoutUsersInput>
  }

  export type GameUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    level?: EnumGameLevelFieldUpdateOperationsInput | $Enums.GameLevel
    countMembersMin?: IntFieldUpdateOperationsInput | number
    countMembersMax?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requestMode?: EnumRequestModeFieldUpdateOperationsInput | $Enums.RequestMode
    place?: PlaceUpdateOneRequiredWithoutGamesNestedInput
    sport?: SportUpdateOneWithoutGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    level?: EnumGameLevelFieldUpdateOperationsInput | $Enums.GameLevel
    countMembersMin?: IntFieldUpdateOperationsInput | number
    countMembersMax?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requestMode?: EnumRequestModeFieldUpdateOperationsInput | $Enums.RequestMode
    placeId?: StringFieldUpdateOperationsInput | string
    sportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutGamesInput = {
    update: XOR<UserUpdateWithoutGamesInput, UserUncheckedUpdateWithoutGamesInput>
    create: XOR<UserCreateWithoutGamesInput, UserUncheckedCreateWithoutGamesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGamesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGamesInput, UserUncheckedUpdateWithoutGamesInput>
  }

  export type UserUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    places?: PlaceUpdateManyWithoutOwnerNestedInput
    favoritePlaces?: PlaceFavoriteUpdateManyWithoutUserNestedInput
    sports?: UserSportUpdateManyWithoutUserNestedInput
    favorites?: UserFavoriteUpdateManyWithoutUserNestedInput
    favoritedBy?: UserFavoriteUpdateManyWithoutFavoriteNestedInput
  }

  export type UserUncheckedUpdateWithoutGamesInput = {
    id?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    places?: PlaceUncheckedUpdateManyWithoutOwnerNestedInput
    favoritePlaces?: PlaceFavoriteUncheckedUpdateManyWithoutUserNestedInput
    sports?: UserSportUncheckedUpdateManyWithoutUserNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    favoritedBy?: UserFavoriteUncheckedUpdateManyWithoutFavoriteNestedInput
  }

  export type UserCreateWithoutPlacesInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
    games?: GameUserCreateNestedManyWithoutUserInput
    favoritePlaces?: PlaceFavoriteCreateNestedManyWithoutUserInput
    sports?: UserSportCreateNestedManyWithoutUserInput
    favorites?: UserFavoriteCreateNestedManyWithoutUserInput
    favoritedBy?: UserFavoriteCreateNestedManyWithoutFavoriteInput
  }

  export type UserUncheckedCreateWithoutPlacesInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
    games?: GameUserUncheckedCreateNestedManyWithoutUserInput
    favoritePlaces?: PlaceFavoriteUncheckedCreateNestedManyWithoutUserInput
    sports?: UserSportUncheckedCreateNestedManyWithoutUserInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    favoritedBy?: UserFavoriteUncheckedCreateNestedManyWithoutFavoriteInput
  }

  export type UserCreateOrConnectWithoutPlacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlacesInput, UserUncheckedCreateWithoutPlacesInput>
  }

  export type ScheduleCreateWithoutPlaceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    stopDate?: Date | string | null
    name?: string
    repeatMode?: $Enums.CalendarRepeatMode
    repeatStep?: number
    m1?: boolean | null
    m2?: boolean | null
    m3?: boolean | null
    m4?: boolean | null
    m5?: boolean | null
    m6?: boolean | null
    m7?: boolean | null
    m8?: boolean | null
    m9?: boolean | null
    m10?: boolean | null
    m11?: boolean | null
    m12?: boolean | null
    w1?: boolean | null
    w2?: boolean | null
    w3?: boolean | null
    w4?: boolean | null
    wLast?: boolean | null
    wd1?: boolean | null
    wd2?: boolean | null
    wd3?: boolean | null
    wd4?: boolean | null
    wd5?: boolean | null
    wd6?: boolean | null
    wd7?: boolean | null
    d1?: boolean | null
    d2?: boolean | null
    d3?: boolean | null
    d4?: boolean | null
    d5?: boolean | null
    d6?: boolean | null
    d7?: boolean | null
    d8?: boolean | null
    d9?: boolean | null
    d10?: boolean | null
    d11?: boolean | null
    d12?: boolean | null
    d13?: boolean | null
    d14?: boolean | null
    d15?: boolean | null
    d16?: boolean | null
    d17?: boolean | null
    d18?: boolean | null
    d19?: boolean | null
    d20?: boolean | null
    d21?: boolean | null
    d22?: boolean | null
    d23?: boolean | null
    d24?: boolean | null
    d25?: boolean | null
    d26?: boolean | null
    d27?: boolean | null
    d28?: boolean | null
    d29?: boolean | null
    d30?: boolean | null
    d31?: boolean | null
    dLast?: boolean | null
    workTimeMode?: $Enums.WorkTimeMode
    minDurationHours?: number
    minDurationMinutes?: number
    maxDurationHours?: number
    maxDurationMinutes?: number
    timeStart?: number
    rank?: number
    status?: $Enums.ScheduleStatus
    timeSlots?: TimeSlotCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateWithoutPlaceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    stopDate?: Date | string | null
    name?: string
    repeatMode?: $Enums.CalendarRepeatMode
    repeatStep?: number
    m1?: boolean | null
    m2?: boolean | null
    m3?: boolean | null
    m4?: boolean | null
    m5?: boolean | null
    m6?: boolean | null
    m7?: boolean | null
    m8?: boolean | null
    m9?: boolean | null
    m10?: boolean | null
    m11?: boolean | null
    m12?: boolean | null
    w1?: boolean | null
    w2?: boolean | null
    w3?: boolean | null
    w4?: boolean | null
    wLast?: boolean | null
    wd1?: boolean | null
    wd2?: boolean | null
    wd3?: boolean | null
    wd4?: boolean | null
    wd5?: boolean | null
    wd6?: boolean | null
    wd7?: boolean | null
    d1?: boolean | null
    d2?: boolean | null
    d3?: boolean | null
    d4?: boolean | null
    d5?: boolean | null
    d6?: boolean | null
    d7?: boolean | null
    d8?: boolean | null
    d9?: boolean | null
    d10?: boolean | null
    d11?: boolean | null
    d12?: boolean | null
    d13?: boolean | null
    d14?: boolean | null
    d15?: boolean | null
    d16?: boolean | null
    d17?: boolean | null
    d18?: boolean | null
    d19?: boolean | null
    d20?: boolean | null
    d21?: boolean | null
    d22?: boolean | null
    d23?: boolean | null
    d24?: boolean | null
    d25?: boolean | null
    d26?: boolean | null
    d27?: boolean | null
    d28?: boolean | null
    d29?: boolean | null
    d30?: boolean | null
    d31?: boolean | null
    dLast?: boolean | null
    workTimeMode?: $Enums.WorkTimeMode
    minDurationHours?: number
    minDurationMinutes?: number
    maxDurationHours?: number
    maxDurationMinutes?: number
    timeStart?: number
    rank?: number
    status?: $Enums.ScheduleStatus
    timeSlots?: TimeSlotUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleCreateOrConnectWithoutPlaceInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutPlaceInput, ScheduleUncheckedCreateWithoutPlaceInput>
  }

  export type ScheduleCreateManyPlaceInputEnvelope = {
    data: ScheduleCreateManyPlaceInput | ScheduleCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutPlaceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
    date: Date | string
    status?: $Enums.GameStatus
    level?: $Enums.GameLevel
    countMembersMin?: number
    countMembersMax?: number
    description?: string | null
    requestMode?: $Enums.RequestMode
    users?: GameUserCreateNestedManyWithoutGameInput
    sport?: SportCreateNestedOneWithoutGamesInput
  }

  export type GameUncheckedCreateWithoutPlaceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
    date: Date | string
    status?: $Enums.GameStatus
    level?: $Enums.GameLevel
    countMembersMin?: number
    countMembersMax?: number
    description?: string | null
    requestMode?: $Enums.RequestMode
    sportId?: string | null
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutPlaceInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutPlaceInput, GameUncheckedCreateWithoutPlaceInput>
  }

  export type GameCreateManyPlaceInputEnvelope = {
    data: GameCreateManyPlaceInput | GameCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type PlaceCoversCreateWithoutPlaceInput = {
    id?: string
    order?: number
    createdAt?: Date | string
  }

  export type PlaceCoversUncheckedCreateWithoutPlaceInput = {
    id?: string
    order?: number
    createdAt?: Date | string
  }

  export type PlaceCoversCreateOrConnectWithoutPlaceInput = {
    where: PlaceCoversWhereUniqueInput
    create: XOR<PlaceCoversCreateWithoutPlaceInput, PlaceCoversUncheckedCreateWithoutPlaceInput>
  }

  export type PlaceCoversCreateManyPlaceInputEnvelope = {
    data: PlaceCoversCreateManyPlaceInput | PlaceCoversCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type PlaceSportCreateWithoutPlaceInput = {
    createdAt?: Date | string
    sport: SportCreateNestedOneWithoutPlacesInput
  }

  export type PlaceSportUncheckedCreateWithoutPlaceInput = {
    createdAt?: Date | string
    sportId: string
  }

  export type PlaceSportCreateOrConnectWithoutPlaceInput = {
    where: PlaceSportWhereUniqueInput
    create: XOR<PlaceSportCreateWithoutPlaceInput, PlaceSportUncheckedCreateWithoutPlaceInput>
  }

  export type PlaceSportCreateManyPlaceInputEnvelope = {
    data: PlaceSportCreateManyPlaceInput | PlaceSportCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type PlaceFavoriteCreateWithoutPlaceInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritePlacesInput
  }

  export type PlaceFavoriteUncheckedCreateWithoutPlaceInput = {
    createdAt?: Date | string
    userId: string
  }

  export type PlaceFavoriteCreateOrConnectWithoutPlaceInput = {
    where: PlaceFavoriteWhereUniqueInput
    create: XOR<PlaceFavoriteCreateWithoutPlaceInput, PlaceFavoriteUncheckedCreateWithoutPlaceInput>
  }

  export type PlaceFavoriteCreateManyPlaceInputEnvelope = {
    data: PlaceFavoriteCreateManyPlaceInput | PlaceFavoriteCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type CityCreateWithoutPlacesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    region?: number
  }

  export type CityUncheckedCreateWithoutPlacesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    region?: number
  }

  export type CityCreateOrConnectWithoutPlacesInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutPlacesInput, CityUncheckedCreateWithoutPlacesInput>
  }

  export type UserUpsertWithoutPlacesInput = {
    update: XOR<UserUpdateWithoutPlacesInput, UserUncheckedUpdateWithoutPlacesInput>
    create: XOR<UserCreateWithoutPlacesInput, UserUncheckedCreateWithoutPlacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlacesInput, UserUncheckedUpdateWithoutPlacesInput>
  }

  export type UserUpdateWithoutPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    games?: GameUserUpdateManyWithoutUserNestedInput
    favoritePlaces?: PlaceFavoriteUpdateManyWithoutUserNestedInput
    sports?: UserSportUpdateManyWithoutUserNestedInput
    favorites?: UserFavoriteUpdateManyWithoutUserNestedInput
    favoritedBy?: UserFavoriteUpdateManyWithoutFavoriteNestedInput
  }

  export type UserUncheckedUpdateWithoutPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    games?: GameUserUncheckedUpdateManyWithoutUserNestedInput
    favoritePlaces?: PlaceFavoriteUncheckedUpdateManyWithoutUserNestedInput
    sports?: UserSportUncheckedUpdateManyWithoutUserNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    favoritedBy?: UserFavoriteUncheckedUpdateManyWithoutFavoriteNestedInput
  }

  export type ScheduleUpsertWithWhereUniqueWithoutPlaceInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutPlaceInput, ScheduleUncheckedUpdateWithoutPlaceInput>
    create: XOR<ScheduleCreateWithoutPlaceInput, ScheduleUncheckedCreateWithoutPlaceInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutPlaceInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutPlaceInput, ScheduleUncheckedUpdateWithoutPlaceInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutPlaceInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutPlaceInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    OR?: ScheduleScalarWhereInput[]
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    id?: StringFilter<"Schedule"> | string
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    placeId?: StringFilter<"Schedule"> | string
    startDate?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    stopDate?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    name?: StringFilter<"Schedule"> | string
    repeatMode?: EnumCalendarRepeatModeFilter<"Schedule"> | $Enums.CalendarRepeatMode
    repeatStep?: IntFilter<"Schedule"> | number
    m1?: BoolNullableFilter<"Schedule"> | boolean | null
    m2?: BoolNullableFilter<"Schedule"> | boolean | null
    m3?: BoolNullableFilter<"Schedule"> | boolean | null
    m4?: BoolNullableFilter<"Schedule"> | boolean | null
    m5?: BoolNullableFilter<"Schedule"> | boolean | null
    m6?: BoolNullableFilter<"Schedule"> | boolean | null
    m7?: BoolNullableFilter<"Schedule"> | boolean | null
    m8?: BoolNullableFilter<"Schedule"> | boolean | null
    m9?: BoolNullableFilter<"Schedule"> | boolean | null
    m10?: BoolNullableFilter<"Schedule"> | boolean | null
    m11?: BoolNullableFilter<"Schedule"> | boolean | null
    m12?: BoolNullableFilter<"Schedule"> | boolean | null
    w1?: BoolNullableFilter<"Schedule"> | boolean | null
    w2?: BoolNullableFilter<"Schedule"> | boolean | null
    w3?: BoolNullableFilter<"Schedule"> | boolean | null
    w4?: BoolNullableFilter<"Schedule"> | boolean | null
    wLast?: BoolNullableFilter<"Schedule"> | boolean | null
    wd1?: BoolNullableFilter<"Schedule"> | boolean | null
    wd2?: BoolNullableFilter<"Schedule"> | boolean | null
    wd3?: BoolNullableFilter<"Schedule"> | boolean | null
    wd4?: BoolNullableFilter<"Schedule"> | boolean | null
    wd5?: BoolNullableFilter<"Schedule"> | boolean | null
    wd6?: BoolNullableFilter<"Schedule"> | boolean | null
    wd7?: BoolNullableFilter<"Schedule"> | boolean | null
    d1?: BoolNullableFilter<"Schedule"> | boolean | null
    d2?: BoolNullableFilter<"Schedule"> | boolean | null
    d3?: BoolNullableFilter<"Schedule"> | boolean | null
    d4?: BoolNullableFilter<"Schedule"> | boolean | null
    d5?: BoolNullableFilter<"Schedule"> | boolean | null
    d6?: BoolNullableFilter<"Schedule"> | boolean | null
    d7?: BoolNullableFilter<"Schedule"> | boolean | null
    d8?: BoolNullableFilter<"Schedule"> | boolean | null
    d9?: BoolNullableFilter<"Schedule"> | boolean | null
    d10?: BoolNullableFilter<"Schedule"> | boolean | null
    d11?: BoolNullableFilter<"Schedule"> | boolean | null
    d12?: BoolNullableFilter<"Schedule"> | boolean | null
    d13?: BoolNullableFilter<"Schedule"> | boolean | null
    d14?: BoolNullableFilter<"Schedule"> | boolean | null
    d15?: BoolNullableFilter<"Schedule"> | boolean | null
    d16?: BoolNullableFilter<"Schedule"> | boolean | null
    d17?: BoolNullableFilter<"Schedule"> | boolean | null
    d18?: BoolNullableFilter<"Schedule"> | boolean | null
    d19?: BoolNullableFilter<"Schedule"> | boolean | null
    d20?: BoolNullableFilter<"Schedule"> | boolean | null
    d21?: BoolNullableFilter<"Schedule"> | boolean | null
    d22?: BoolNullableFilter<"Schedule"> | boolean | null
    d23?: BoolNullableFilter<"Schedule"> | boolean | null
    d24?: BoolNullableFilter<"Schedule"> | boolean | null
    d25?: BoolNullableFilter<"Schedule"> | boolean | null
    d26?: BoolNullableFilter<"Schedule"> | boolean | null
    d27?: BoolNullableFilter<"Schedule"> | boolean | null
    d28?: BoolNullableFilter<"Schedule"> | boolean | null
    d29?: BoolNullableFilter<"Schedule"> | boolean | null
    d30?: BoolNullableFilter<"Schedule"> | boolean | null
    d31?: BoolNullableFilter<"Schedule"> | boolean | null
    dLast?: BoolNullableFilter<"Schedule"> | boolean | null
    workTimeMode?: EnumWorkTimeModeFilter<"Schedule"> | $Enums.WorkTimeMode
    minDurationHours?: IntFilter<"Schedule"> | number
    minDurationMinutes?: IntFilter<"Schedule"> | number
    maxDurationHours?: IntFilter<"Schedule"> | number
    maxDurationMinutes?: IntFilter<"Schedule"> | number
    timeStart?: IntFilter<"Schedule"> | number
    rank?: IntFilter<"Schedule"> | number
    status?: EnumScheduleStatusFilter<"Schedule"> | $Enums.ScheduleStatus
  }

  export type GameUpsertWithWhereUniqueWithoutPlaceInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutPlaceInput, GameUncheckedUpdateWithoutPlaceInput>
    create: XOR<GameCreateWithoutPlaceInput, GameUncheckedCreateWithoutPlaceInput>
  }

  export type GameUpdateWithWhereUniqueWithoutPlaceInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutPlaceInput, GameUncheckedUpdateWithoutPlaceInput>
  }

  export type GameUpdateManyWithWhereWithoutPlaceInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutPlaceInput>
  }

  export type GameScalarWhereInput = {
    AND?: GameScalarWhereInput | GameScalarWhereInput[]
    OR?: GameScalarWhereInput[]
    NOT?: GameScalarWhereInput | GameScalarWhereInput[]
    id?: StringFilter<"Game"> | string
    createdAt?: DateTimeFilter<"Game"> | Date | string
    updatedAt?: DateTimeFilter<"Game"> | Date | string
    timeStart?: IntFilter<"Game"> | number
    timeEnd?: IntFilter<"Game"> | number
    date?: DateTimeFilter<"Game"> | Date | string
    status?: EnumGameStatusFilter<"Game"> | $Enums.GameStatus
    level?: EnumGameLevelFilter<"Game"> | $Enums.GameLevel
    countMembersMin?: IntFilter<"Game"> | number
    countMembersMax?: IntFilter<"Game"> | number
    description?: StringNullableFilter<"Game"> | string | null
    requestMode?: EnumRequestModeFilter<"Game"> | $Enums.RequestMode
    placeId?: StringFilter<"Game"> | string
    sportId?: StringNullableFilter<"Game"> | string | null
  }

  export type PlaceCoversUpsertWithWhereUniqueWithoutPlaceInput = {
    where: PlaceCoversWhereUniqueInput
    update: XOR<PlaceCoversUpdateWithoutPlaceInput, PlaceCoversUncheckedUpdateWithoutPlaceInput>
    create: XOR<PlaceCoversCreateWithoutPlaceInput, PlaceCoversUncheckedCreateWithoutPlaceInput>
  }

  export type PlaceCoversUpdateWithWhereUniqueWithoutPlaceInput = {
    where: PlaceCoversWhereUniqueInput
    data: XOR<PlaceCoversUpdateWithoutPlaceInput, PlaceCoversUncheckedUpdateWithoutPlaceInput>
  }

  export type PlaceCoversUpdateManyWithWhereWithoutPlaceInput = {
    where: PlaceCoversScalarWhereInput
    data: XOR<PlaceCoversUpdateManyMutationInput, PlaceCoversUncheckedUpdateManyWithoutPlaceInput>
  }

  export type PlaceCoversScalarWhereInput = {
    AND?: PlaceCoversScalarWhereInput | PlaceCoversScalarWhereInput[]
    OR?: PlaceCoversScalarWhereInput[]
    NOT?: PlaceCoversScalarWhereInput | PlaceCoversScalarWhereInput[]
    id?: StringFilter<"PlaceCovers"> | string
    order?: IntFilter<"PlaceCovers"> | number
    placeId?: StringFilter<"PlaceCovers"> | string
    createdAt?: DateTimeFilter<"PlaceCovers"> | Date | string
  }

  export type PlaceSportUpsertWithWhereUniqueWithoutPlaceInput = {
    where: PlaceSportWhereUniqueInput
    update: XOR<PlaceSportUpdateWithoutPlaceInput, PlaceSportUncheckedUpdateWithoutPlaceInput>
    create: XOR<PlaceSportCreateWithoutPlaceInput, PlaceSportUncheckedCreateWithoutPlaceInput>
  }

  export type PlaceSportUpdateWithWhereUniqueWithoutPlaceInput = {
    where: PlaceSportWhereUniqueInput
    data: XOR<PlaceSportUpdateWithoutPlaceInput, PlaceSportUncheckedUpdateWithoutPlaceInput>
  }

  export type PlaceSportUpdateManyWithWhereWithoutPlaceInput = {
    where: PlaceSportScalarWhereInput
    data: XOR<PlaceSportUpdateManyMutationInput, PlaceSportUncheckedUpdateManyWithoutPlaceInput>
  }

  export type PlaceSportScalarWhereInput = {
    AND?: PlaceSportScalarWhereInput | PlaceSportScalarWhereInput[]
    OR?: PlaceSportScalarWhereInput[]
    NOT?: PlaceSportScalarWhereInput | PlaceSportScalarWhereInput[]
    createdAt?: DateTimeFilter<"PlaceSport"> | Date | string
    sportId?: StringFilter<"PlaceSport"> | string
    placeId?: StringFilter<"PlaceSport"> | string
  }

  export type PlaceFavoriteUpsertWithWhereUniqueWithoutPlaceInput = {
    where: PlaceFavoriteWhereUniqueInput
    update: XOR<PlaceFavoriteUpdateWithoutPlaceInput, PlaceFavoriteUncheckedUpdateWithoutPlaceInput>
    create: XOR<PlaceFavoriteCreateWithoutPlaceInput, PlaceFavoriteUncheckedCreateWithoutPlaceInput>
  }

  export type PlaceFavoriteUpdateWithWhereUniqueWithoutPlaceInput = {
    where: PlaceFavoriteWhereUniqueInput
    data: XOR<PlaceFavoriteUpdateWithoutPlaceInput, PlaceFavoriteUncheckedUpdateWithoutPlaceInput>
  }

  export type PlaceFavoriteUpdateManyWithWhereWithoutPlaceInput = {
    where: PlaceFavoriteScalarWhereInput
    data: XOR<PlaceFavoriteUpdateManyMutationInput, PlaceFavoriteUncheckedUpdateManyWithoutPlaceInput>
  }

  export type PlaceFavoriteScalarWhereInput = {
    AND?: PlaceFavoriteScalarWhereInput | PlaceFavoriteScalarWhereInput[]
    OR?: PlaceFavoriteScalarWhereInput[]
    NOT?: PlaceFavoriteScalarWhereInput | PlaceFavoriteScalarWhereInput[]
    createdAt?: DateTimeFilter<"PlaceFavorite"> | Date | string
    userId?: StringFilter<"PlaceFavorite"> | string
    placeId?: StringFilter<"PlaceFavorite"> | string
  }

  export type CityUpsertWithoutPlacesInput = {
    update: XOR<CityUpdateWithoutPlacesInput, CityUncheckedUpdateWithoutPlacesInput>
    create: XOR<CityCreateWithoutPlacesInput, CityUncheckedCreateWithoutPlacesInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutPlacesInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutPlacesInput, CityUncheckedUpdateWithoutPlacesInput>
  }

  export type CityUpdateWithoutPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
  }

  export type CityUncheckedUpdateWithoutPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutFavoritePlacesInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
    games?: GameUserCreateNestedManyWithoutUserInput
    places?: PlaceCreateNestedManyWithoutOwnerInput
    sports?: UserSportCreateNestedManyWithoutUserInput
    favorites?: UserFavoriteCreateNestedManyWithoutUserInput
    favoritedBy?: UserFavoriteCreateNestedManyWithoutFavoriteInput
  }

  export type UserUncheckedCreateWithoutFavoritePlacesInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
    games?: GameUserUncheckedCreateNestedManyWithoutUserInput
    places?: PlaceUncheckedCreateNestedManyWithoutOwnerInput
    sports?: UserSportUncheckedCreateNestedManyWithoutUserInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    favoritedBy?: UserFavoriteUncheckedCreateNestedManyWithoutFavoriteInput
  }

  export type UserCreateOrConnectWithoutFavoritePlacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoritePlacesInput, UserUncheckedCreateWithoutFavoritePlacesInput>
  }

  export type PlaceCreateWithoutFavoritedUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    latitude?: number
    longitude?: number
    owner: UserCreateNestedOneWithoutPlacesInput
    schedules?: ScheduleCreateNestedManyWithoutPlaceInput
    games?: GameCreateNestedManyWithoutPlaceInput
    covers?: PlaceCoversCreateNestedManyWithoutPlaceInput
    sports?: PlaceSportCreateNestedManyWithoutPlaceInput
    city: CityCreateNestedOneWithoutPlacesInput
  }

  export type PlaceUncheckedCreateWithoutFavoritedUsersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    ownerId: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    cityId: string
    latitude?: number
    longitude?: number
    schedules?: ScheduleUncheckedCreateNestedManyWithoutPlaceInput
    games?: GameUncheckedCreateNestedManyWithoutPlaceInput
    covers?: PlaceCoversUncheckedCreateNestedManyWithoutPlaceInput
    sports?: PlaceSportUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceCreateOrConnectWithoutFavoritedUsersInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutFavoritedUsersInput, PlaceUncheckedCreateWithoutFavoritedUsersInput>
  }

  export type UserUpsertWithoutFavoritePlacesInput = {
    update: XOR<UserUpdateWithoutFavoritePlacesInput, UserUncheckedUpdateWithoutFavoritePlacesInput>
    create: XOR<UserCreateWithoutFavoritePlacesInput, UserUncheckedCreateWithoutFavoritePlacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoritePlacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoritePlacesInput, UserUncheckedUpdateWithoutFavoritePlacesInput>
  }

  export type UserUpdateWithoutFavoritePlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    games?: GameUserUpdateManyWithoutUserNestedInput
    places?: PlaceUpdateManyWithoutOwnerNestedInput
    sports?: UserSportUpdateManyWithoutUserNestedInput
    favorites?: UserFavoriteUpdateManyWithoutUserNestedInput
    favoritedBy?: UserFavoriteUpdateManyWithoutFavoriteNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoritePlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    games?: GameUserUncheckedUpdateManyWithoutUserNestedInput
    places?: PlaceUncheckedUpdateManyWithoutOwnerNestedInput
    sports?: UserSportUncheckedUpdateManyWithoutUserNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    favoritedBy?: UserFavoriteUncheckedUpdateManyWithoutFavoriteNestedInput
  }

  export type PlaceUpsertWithoutFavoritedUsersInput = {
    update: XOR<PlaceUpdateWithoutFavoritedUsersInput, PlaceUncheckedUpdateWithoutFavoritedUsersInput>
    create: XOR<PlaceCreateWithoutFavoritedUsersInput, PlaceUncheckedCreateWithoutFavoritedUsersInput>
    where?: PlaceWhereInput
  }

  export type PlaceUpdateToOneWithWhereWithoutFavoritedUsersInput = {
    where?: PlaceWhereInput
    data: XOR<PlaceUpdateWithoutFavoritedUsersInput, PlaceUncheckedUpdateWithoutFavoritedUsersInput>
  }

  export type PlaceUpdateWithoutFavoritedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutPlacesNestedInput
    schedules?: ScheduleUpdateManyWithoutPlaceNestedInput
    games?: GameUpdateManyWithoutPlaceNestedInput
    covers?: PlaceCoversUpdateManyWithoutPlaceNestedInput
    sports?: PlaceSportUpdateManyWithoutPlaceNestedInput
    city?: CityUpdateOneRequiredWithoutPlacesNestedInput
  }

  export type PlaceUncheckedUpdateWithoutFavoritedUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    schedules?: ScheduleUncheckedUpdateManyWithoutPlaceNestedInput
    games?: GameUncheckedUpdateManyWithoutPlaceNestedInput
    covers?: PlaceCoversUncheckedUpdateManyWithoutPlaceNestedInput
    sports?: PlaceSportUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceCreateWithoutCoversInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    latitude?: number
    longitude?: number
    owner: UserCreateNestedOneWithoutPlacesInput
    schedules?: ScheduleCreateNestedManyWithoutPlaceInput
    games?: GameCreateNestedManyWithoutPlaceInput
    sports?: PlaceSportCreateNestedManyWithoutPlaceInput
    favoritedUsers?: PlaceFavoriteCreateNestedManyWithoutPlaceInput
    city: CityCreateNestedOneWithoutPlacesInput
  }

  export type PlaceUncheckedCreateWithoutCoversInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    ownerId: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    cityId: string
    latitude?: number
    longitude?: number
    schedules?: ScheduleUncheckedCreateNestedManyWithoutPlaceInput
    games?: GameUncheckedCreateNestedManyWithoutPlaceInput
    sports?: PlaceSportUncheckedCreateNestedManyWithoutPlaceInput
    favoritedUsers?: PlaceFavoriteUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceCreateOrConnectWithoutCoversInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutCoversInput, PlaceUncheckedCreateWithoutCoversInput>
  }

  export type PlaceUpsertWithoutCoversInput = {
    update: XOR<PlaceUpdateWithoutCoversInput, PlaceUncheckedUpdateWithoutCoversInput>
    create: XOR<PlaceCreateWithoutCoversInput, PlaceUncheckedCreateWithoutCoversInput>
    where?: PlaceWhereInput
  }

  export type PlaceUpdateToOneWithWhereWithoutCoversInput = {
    where?: PlaceWhereInput
    data: XOR<PlaceUpdateWithoutCoversInput, PlaceUncheckedUpdateWithoutCoversInput>
  }

  export type PlaceUpdateWithoutCoversInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutPlacesNestedInput
    schedules?: ScheduleUpdateManyWithoutPlaceNestedInput
    games?: GameUpdateManyWithoutPlaceNestedInput
    sports?: PlaceSportUpdateManyWithoutPlaceNestedInput
    favoritedUsers?: PlaceFavoriteUpdateManyWithoutPlaceNestedInput
    city?: CityUpdateOneRequiredWithoutPlacesNestedInput
  }

  export type PlaceUncheckedUpdateWithoutCoversInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    schedules?: ScheduleUncheckedUpdateManyWithoutPlaceNestedInput
    games?: GameUncheckedUpdateManyWithoutPlaceNestedInput
    sports?: PlaceSportUncheckedUpdateManyWithoutPlaceNestedInput
    favoritedUsers?: PlaceFavoriteUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type SportCreateWithoutPlacesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    games?: GameCreateNestedManyWithoutSportInput
    users?: UserSportCreateNestedManyWithoutSportInput
  }

  export type SportUncheckedCreateWithoutPlacesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    games?: GameUncheckedCreateNestedManyWithoutSportInput
    users?: UserSportUncheckedCreateNestedManyWithoutSportInput
  }

  export type SportCreateOrConnectWithoutPlacesInput = {
    where: SportWhereUniqueInput
    create: XOR<SportCreateWithoutPlacesInput, SportUncheckedCreateWithoutPlacesInput>
  }

  export type PlaceCreateWithoutSportsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    latitude?: number
    longitude?: number
    owner: UserCreateNestedOneWithoutPlacesInput
    schedules?: ScheduleCreateNestedManyWithoutPlaceInput
    games?: GameCreateNestedManyWithoutPlaceInput
    covers?: PlaceCoversCreateNestedManyWithoutPlaceInput
    favoritedUsers?: PlaceFavoriteCreateNestedManyWithoutPlaceInput
    city: CityCreateNestedOneWithoutPlacesInput
  }

  export type PlaceUncheckedCreateWithoutSportsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    ownerId: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    cityId: string
    latitude?: number
    longitude?: number
    schedules?: ScheduleUncheckedCreateNestedManyWithoutPlaceInput
    games?: GameUncheckedCreateNestedManyWithoutPlaceInput
    covers?: PlaceCoversUncheckedCreateNestedManyWithoutPlaceInput
    favoritedUsers?: PlaceFavoriteUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceCreateOrConnectWithoutSportsInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutSportsInput, PlaceUncheckedCreateWithoutSportsInput>
  }

  export type SportUpsertWithoutPlacesInput = {
    update: XOR<SportUpdateWithoutPlacesInput, SportUncheckedUpdateWithoutPlacesInput>
    create: XOR<SportCreateWithoutPlacesInput, SportUncheckedCreateWithoutPlacesInput>
    where?: SportWhereInput
  }

  export type SportUpdateToOneWithWhereWithoutPlacesInput = {
    where?: SportWhereInput
    data: XOR<SportUpdateWithoutPlacesInput, SportUncheckedUpdateWithoutPlacesInput>
  }

  export type SportUpdateWithoutPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUpdateManyWithoutSportNestedInput
    users?: UserSportUpdateManyWithoutSportNestedInput
  }

  export type SportUncheckedUpdateWithoutPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    games?: GameUncheckedUpdateManyWithoutSportNestedInput
    users?: UserSportUncheckedUpdateManyWithoutSportNestedInput
  }

  export type PlaceUpsertWithoutSportsInput = {
    update: XOR<PlaceUpdateWithoutSportsInput, PlaceUncheckedUpdateWithoutSportsInput>
    create: XOR<PlaceCreateWithoutSportsInput, PlaceUncheckedCreateWithoutSportsInput>
    where?: PlaceWhereInput
  }

  export type PlaceUpdateToOneWithWhereWithoutSportsInput = {
    where?: PlaceWhereInput
    data: XOR<PlaceUpdateWithoutSportsInput, PlaceUncheckedUpdateWithoutSportsInput>
  }

  export type PlaceUpdateWithoutSportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutPlacesNestedInput
    schedules?: ScheduleUpdateManyWithoutPlaceNestedInput
    games?: GameUpdateManyWithoutPlaceNestedInput
    covers?: PlaceCoversUpdateManyWithoutPlaceNestedInput
    favoritedUsers?: PlaceFavoriteUpdateManyWithoutPlaceNestedInput
    city?: CityUpdateOneRequiredWithoutPlacesNestedInput
  }

  export type PlaceUncheckedUpdateWithoutSportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    schedules?: ScheduleUncheckedUpdateManyWithoutPlaceNestedInput
    games?: GameUncheckedUpdateManyWithoutPlaceNestedInput
    covers?: PlaceCoversUncheckedUpdateManyWithoutPlaceNestedInput
    favoritedUsers?: PlaceFavoriteUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceCreateWithoutSchedulesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    latitude?: number
    longitude?: number
    owner: UserCreateNestedOneWithoutPlacesInput
    games?: GameCreateNestedManyWithoutPlaceInput
    covers?: PlaceCoversCreateNestedManyWithoutPlaceInput
    sports?: PlaceSportCreateNestedManyWithoutPlaceInput
    favoritedUsers?: PlaceFavoriteCreateNestedManyWithoutPlaceInput
    city: CityCreateNestedOneWithoutPlacesInput
  }

  export type PlaceUncheckedCreateWithoutSchedulesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    ownerId: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    cityId: string
    latitude?: number
    longitude?: number
    games?: GameUncheckedCreateNestedManyWithoutPlaceInput
    covers?: PlaceCoversUncheckedCreateNestedManyWithoutPlaceInput
    sports?: PlaceSportUncheckedCreateNestedManyWithoutPlaceInput
    favoritedUsers?: PlaceFavoriteUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceCreateOrConnectWithoutSchedulesInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutSchedulesInput, PlaceUncheckedCreateWithoutSchedulesInput>
  }

  export type TimeSlotCreateWithoutScheduleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
  }

  export type TimeSlotUncheckedCreateWithoutScheduleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
  }

  export type TimeSlotCreateOrConnectWithoutScheduleInput = {
    where: TimeSlotWhereUniqueInput
    create: XOR<TimeSlotCreateWithoutScheduleInput, TimeSlotUncheckedCreateWithoutScheduleInput>
  }

  export type TimeSlotCreateManyScheduleInputEnvelope = {
    data: TimeSlotCreateManyScheduleInput | TimeSlotCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type PlaceUpsertWithoutSchedulesInput = {
    update: XOR<PlaceUpdateWithoutSchedulesInput, PlaceUncheckedUpdateWithoutSchedulesInput>
    create: XOR<PlaceCreateWithoutSchedulesInput, PlaceUncheckedCreateWithoutSchedulesInput>
    where?: PlaceWhereInput
  }

  export type PlaceUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: PlaceWhereInput
    data: XOR<PlaceUpdateWithoutSchedulesInput, PlaceUncheckedUpdateWithoutSchedulesInput>
  }

  export type PlaceUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutPlacesNestedInput
    games?: GameUpdateManyWithoutPlaceNestedInput
    covers?: PlaceCoversUpdateManyWithoutPlaceNestedInput
    sports?: PlaceSportUpdateManyWithoutPlaceNestedInput
    favoritedUsers?: PlaceFavoriteUpdateManyWithoutPlaceNestedInput
    city?: CityUpdateOneRequiredWithoutPlacesNestedInput
  }

  export type PlaceUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    games?: GameUncheckedUpdateManyWithoutPlaceNestedInput
    covers?: PlaceCoversUncheckedUpdateManyWithoutPlaceNestedInput
    sports?: PlaceSportUncheckedUpdateManyWithoutPlaceNestedInput
    favoritedUsers?: PlaceFavoriteUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type TimeSlotUpsertWithWhereUniqueWithoutScheduleInput = {
    where: TimeSlotWhereUniqueInput
    update: XOR<TimeSlotUpdateWithoutScheduleInput, TimeSlotUncheckedUpdateWithoutScheduleInput>
    create: XOR<TimeSlotCreateWithoutScheduleInput, TimeSlotUncheckedCreateWithoutScheduleInput>
  }

  export type TimeSlotUpdateWithWhereUniqueWithoutScheduleInput = {
    where: TimeSlotWhereUniqueInput
    data: XOR<TimeSlotUpdateWithoutScheduleInput, TimeSlotUncheckedUpdateWithoutScheduleInput>
  }

  export type TimeSlotUpdateManyWithWhereWithoutScheduleInput = {
    where: TimeSlotScalarWhereInput
    data: XOR<TimeSlotUpdateManyMutationInput, TimeSlotUncheckedUpdateManyWithoutScheduleInput>
  }

  export type TimeSlotScalarWhereInput = {
    AND?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
    OR?: TimeSlotScalarWhereInput[]
    NOT?: TimeSlotScalarWhereInput | TimeSlotScalarWhereInput[]
    id?: StringFilter<"TimeSlot"> | string
    createdAt?: DateTimeFilter<"TimeSlot"> | Date | string
    updatedAt?: DateTimeFilter<"TimeSlot"> | Date | string
    timeStart?: IntFilter<"TimeSlot"> | number
    timeEnd?: IntFilter<"TimeSlot"> | number
    scheduleId?: StringFilter<"TimeSlot"> | string
  }

  export type ScheduleCreateWithoutTimeSlotsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    stopDate?: Date | string | null
    name?: string
    repeatMode?: $Enums.CalendarRepeatMode
    repeatStep?: number
    m1?: boolean | null
    m2?: boolean | null
    m3?: boolean | null
    m4?: boolean | null
    m5?: boolean | null
    m6?: boolean | null
    m7?: boolean | null
    m8?: boolean | null
    m9?: boolean | null
    m10?: boolean | null
    m11?: boolean | null
    m12?: boolean | null
    w1?: boolean | null
    w2?: boolean | null
    w3?: boolean | null
    w4?: boolean | null
    wLast?: boolean | null
    wd1?: boolean | null
    wd2?: boolean | null
    wd3?: boolean | null
    wd4?: boolean | null
    wd5?: boolean | null
    wd6?: boolean | null
    wd7?: boolean | null
    d1?: boolean | null
    d2?: boolean | null
    d3?: boolean | null
    d4?: boolean | null
    d5?: boolean | null
    d6?: boolean | null
    d7?: boolean | null
    d8?: boolean | null
    d9?: boolean | null
    d10?: boolean | null
    d11?: boolean | null
    d12?: boolean | null
    d13?: boolean | null
    d14?: boolean | null
    d15?: boolean | null
    d16?: boolean | null
    d17?: boolean | null
    d18?: boolean | null
    d19?: boolean | null
    d20?: boolean | null
    d21?: boolean | null
    d22?: boolean | null
    d23?: boolean | null
    d24?: boolean | null
    d25?: boolean | null
    d26?: boolean | null
    d27?: boolean | null
    d28?: boolean | null
    d29?: boolean | null
    d30?: boolean | null
    d31?: boolean | null
    dLast?: boolean | null
    workTimeMode?: $Enums.WorkTimeMode
    minDurationHours?: number
    minDurationMinutes?: number
    maxDurationHours?: number
    maxDurationMinutes?: number
    timeStart?: number
    rank?: number
    status?: $Enums.ScheduleStatus
    place: PlaceCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutTimeSlotsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    placeId: string
    startDate?: Date | string | null
    stopDate?: Date | string | null
    name?: string
    repeatMode?: $Enums.CalendarRepeatMode
    repeatStep?: number
    m1?: boolean | null
    m2?: boolean | null
    m3?: boolean | null
    m4?: boolean | null
    m5?: boolean | null
    m6?: boolean | null
    m7?: boolean | null
    m8?: boolean | null
    m9?: boolean | null
    m10?: boolean | null
    m11?: boolean | null
    m12?: boolean | null
    w1?: boolean | null
    w2?: boolean | null
    w3?: boolean | null
    w4?: boolean | null
    wLast?: boolean | null
    wd1?: boolean | null
    wd2?: boolean | null
    wd3?: boolean | null
    wd4?: boolean | null
    wd5?: boolean | null
    wd6?: boolean | null
    wd7?: boolean | null
    d1?: boolean | null
    d2?: boolean | null
    d3?: boolean | null
    d4?: boolean | null
    d5?: boolean | null
    d6?: boolean | null
    d7?: boolean | null
    d8?: boolean | null
    d9?: boolean | null
    d10?: boolean | null
    d11?: boolean | null
    d12?: boolean | null
    d13?: boolean | null
    d14?: boolean | null
    d15?: boolean | null
    d16?: boolean | null
    d17?: boolean | null
    d18?: boolean | null
    d19?: boolean | null
    d20?: boolean | null
    d21?: boolean | null
    d22?: boolean | null
    d23?: boolean | null
    d24?: boolean | null
    d25?: boolean | null
    d26?: boolean | null
    d27?: boolean | null
    d28?: boolean | null
    d29?: boolean | null
    d30?: boolean | null
    d31?: boolean | null
    dLast?: boolean | null
    workTimeMode?: $Enums.WorkTimeMode
    minDurationHours?: number
    minDurationMinutes?: number
    maxDurationHours?: number
    maxDurationMinutes?: number
    timeStart?: number
    rank?: number
    status?: $Enums.ScheduleStatus
  }

  export type ScheduleCreateOrConnectWithoutTimeSlotsInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutTimeSlotsInput, ScheduleUncheckedCreateWithoutTimeSlotsInput>
  }

  export type ScheduleUpsertWithoutTimeSlotsInput = {
    update: XOR<ScheduleUpdateWithoutTimeSlotsInput, ScheduleUncheckedUpdateWithoutTimeSlotsInput>
    create: XOR<ScheduleCreateWithoutTimeSlotsInput, ScheduleUncheckedCreateWithoutTimeSlotsInput>
    where?: ScheduleWhereInput
  }

  export type ScheduleUpdateToOneWithWhereWithoutTimeSlotsInput = {
    where?: ScheduleWhereInput
    data: XOR<ScheduleUpdateWithoutTimeSlotsInput, ScheduleUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type ScheduleUpdateWithoutTimeSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    repeatMode?: EnumCalendarRepeatModeFieldUpdateOperationsInput | $Enums.CalendarRepeatMode
    repeatStep?: IntFieldUpdateOperationsInput | number
    m1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d13?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d14?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d15?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d16?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d17?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d18?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d19?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d20?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d21?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d22?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d23?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d24?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d25?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d26?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d27?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d28?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d29?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d31?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workTimeMode?: EnumWorkTimeModeFieldUpdateOperationsInput | $Enums.WorkTimeMode
    minDurationHours?: IntFieldUpdateOperationsInput | number
    minDurationMinutes?: IntFieldUpdateOperationsInput | number
    maxDurationHours?: IntFieldUpdateOperationsInput | number
    maxDurationMinutes?: IntFieldUpdateOperationsInput | number
    timeStart?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    place?: PlaceUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutTimeSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    placeId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    repeatMode?: EnumCalendarRepeatModeFieldUpdateOperationsInput | $Enums.CalendarRepeatMode
    repeatStep?: IntFieldUpdateOperationsInput | number
    m1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d13?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d14?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d15?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d16?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d17?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d18?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d19?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d20?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d21?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d22?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d23?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d24?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d25?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d26?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d27?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d28?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d29?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d31?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workTimeMode?: EnumWorkTimeModeFieldUpdateOperationsInput | $Enums.WorkTimeMode
    minDurationHours?: IntFieldUpdateOperationsInput | number
    minDurationMinutes?: IntFieldUpdateOperationsInput | number
    maxDurationHours?: IntFieldUpdateOperationsInput | number
    maxDurationMinutes?: IntFieldUpdateOperationsInput | number
    timeStart?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
  }

  export type PlaceSportCreateWithoutSportInput = {
    createdAt?: Date | string
    place: PlaceCreateNestedOneWithoutSportsInput
  }

  export type PlaceSportUncheckedCreateWithoutSportInput = {
    createdAt?: Date | string
    placeId: string
  }

  export type PlaceSportCreateOrConnectWithoutSportInput = {
    where: PlaceSportWhereUniqueInput
    create: XOR<PlaceSportCreateWithoutSportInput, PlaceSportUncheckedCreateWithoutSportInput>
  }

  export type PlaceSportCreateManySportInputEnvelope = {
    data: PlaceSportCreateManySportInput | PlaceSportCreateManySportInput[]
    skipDuplicates?: boolean
  }

  export type GameCreateWithoutSportInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
    date: Date | string
    status?: $Enums.GameStatus
    level?: $Enums.GameLevel
    countMembersMin?: number
    countMembersMax?: number
    description?: string | null
    requestMode?: $Enums.RequestMode
    place: PlaceCreateNestedOneWithoutGamesInput
    users?: GameUserCreateNestedManyWithoutGameInput
  }

  export type GameUncheckedCreateWithoutSportInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
    date: Date | string
    status?: $Enums.GameStatus
    level?: $Enums.GameLevel
    countMembersMin?: number
    countMembersMax?: number
    description?: string | null
    requestMode?: $Enums.RequestMode
    placeId: string
    users?: GameUserUncheckedCreateNestedManyWithoutGameInput
  }

  export type GameCreateOrConnectWithoutSportInput = {
    where: GameWhereUniqueInput
    create: XOR<GameCreateWithoutSportInput, GameUncheckedCreateWithoutSportInput>
  }

  export type GameCreateManySportInputEnvelope = {
    data: GameCreateManySportInput | GameCreateManySportInput[]
    skipDuplicates?: boolean
  }

  export type UserSportCreateWithoutSportInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSportsInput
  }

  export type UserSportUncheckedCreateWithoutSportInput = {
    createdAt?: Date | string
    userId: string
  }

  export type UserSportCreateOrConnectWithoutSportInput = {
    where: UserSportWhereUniqueInput
    create: XOR<UserSportCreateWithoutSportInput, UserSportUncheckedCreateWithoutSportInput>
  }

  export type UserSportCreateManySportInputEnvelope = {
    data: UserSportCreateManySportInput | UserSportCreateManySportInput[]
    skipDuplicates?: boolean
  }

  export type PlaceSportUpsertWithWhereUniqueWithoutSportInput = {
    where: PlaceSportWhereUniqueInput
    update: XOR<PlaceSportUpdateWithoutSportInput, PlaceSportUncheckedUpdateWithoutSportInput>
    create: XOR<PlaceSportCreateWithoutSportInput, PlaceSportUncheckedCreateWithoutSportInput>
  }

  export type PlaceSportUpdateWithWhereUniqueWithoutSportInput = {
    where: PlaceSportWhereUniqueInput
    data: XOR<PlaceSportUpdateWithoutSportInput, PlaceSportUncheckedUpdateWithoutSportInput>
  }

  export type PlaceSportUpdateManyWithWhereWithoutSportInput = {
    where: PlaceSportScalarWhereInput
    data: XOR<PlaceSportUpdateManyMutationInput, PlaceSportUncheckedUpdateManyWithoutSportInput>
  }

  export type GameUpsertWithWhereUniqueWithoutSportInput = {
    where: GameWhereUniqueInput
    update: XOR<GameUpdateWithoutSportInput, GameUncheckedUpdateWithoutSportInput>
    create: XOR<GameCreateWithoutSportInput, GameUncheckedCreateWithoutSportInput>
  }

  export type GameUpdateWithWhereUniqueWithoutSportInput = {
    where: GameWhereUniqueInput
    data: XOR<GameUpdateWithoutSportInput, GameUncheckedUpdateWithoutSportInput>
  }

  export type GameUpdateManyWithWhereWithoutSportInput = {
    where: GameScalarWhereInput
    data: XOR<GameUpdateManyMutationInput, GameUncheckedUpdateManyWithoutSportInput>
  }

  export type UserSportUpsertWithWhereUniqueWithoutSportInput = {
    where: UserSportWhereUniqueInput
    update: XOR<UserSportUpdateWithoutSportInput, UserSportUncheckedUpdateWithoutSportInput>
    create: XOR<UserSportCreateWithoutSportInput, UserSportUncheckedCreateWithoutSportInput>
  }

  export type UserSportUpdateWithWhereUniqueWithoutSportInput = {
    where: UserSportWhereUniqueInput
    data: XOR<UserSportUpdateWithoutSportInput, UserSportUncheckedUpdateWithoutSportInput>
  }

  export type UserSportUpdateManyWithWhereWithoutSportInput = {
    where: UserSportScalarWhereInput
    data: XOR<UserSportUpdateManyMutationInput, UserSportUncheckedUpdateManyWithoutSportInput>
  }

  export type UserSportScalarWhereInput = {
    AND?: UserSportScalarWhereInput | UserSportScalarWhereInput[]
    OR?: UserSportScalarWhereInput[]
    NOT?: UserSportScalarWhereInput | UserSportScalarWhereInput[]
    createdAt?: DateTimeFilter<"UserSport"> | Date | string
    sportId?: StringFilter<"UserSport"> | string
    userId?: StringFilter<"UserSport"> | string
  }

  export type GameUserCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    role: $Enums.GameUserRole
    status: $Enums.GameUserStatus
    game: GameCreateNestedOneWithoutUsersInput
  }

  export type GameUserUncheckedCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    gameId: string
    role: $Enums.GameUserRole
    status: $Enums.GameUserStatus
  }

  export type GameUserCreateOrConnectWithoutUserInput = {
    where: GameUserWhereUniqueInput
    create: XOR<GameUserCreateWithoutUserInput, GameUserUncheckedCreateWithoutUserInput>
  }

  export type GameUserCreateManyUserInputEnvelope = {
    data: GameUserCreateManyUserInput | GameUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlaceCreateWithoutOwnerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    latitude?: number
    longitude?: number
    schedules?: ScheduleCreateNestedManyWithoutPlaceInput
    games?: GameCreateNestedManyWithoutPlaceInput
    covers?: PlaceCoversCreateNestedManyWithoutPlaceInput
    sports?: PlaceSportCreateNestedManyWithoutPlaceInput
    favoritedUsers?: PlaceFavoriteCreateNestedManyWithoutPlaceInput
    city: CityCreateNestedOneWithoutPlacesInput
  }

  export type PlaceUncheckedCreateWithoutOwnerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    cityId: string
    latitude?: number
    longitude?: number
    schedules?: ScheduleUncheckedCreateNestedManyWithoutPlaceInput
    games?: GameUncheckedCreateNestedManyWithoutPlaceInput
    covers?: PlaceCoversUncheckedCreateNestedManyWithoutPlaceInput
    sports?: PlaceSportUncheckedCreateNestedManyWithoutPlaceInput
    favoritedUsers?: PlaceFavoriteUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceCreateOrConnectWithoutOwnerInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutOwnerInput, PlaceUncheckedCreateWithoutOwnerInput>
  }

  export type PlaceCreateManyOwnerInputEnvelope = {
    data: PlaceCreateManyOwnerInput | PlaceCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type PlaceFavoriteCreateWithoutUserInput = {
    createdAt?: Date | string
    place: PlaceCreateNestedOneWithoutFavoritedUsersInput
  }

  export type PlaceFavoriteUncheckedCreateWithoutUserInput = {
    createdAt?: Date | string
    placeId: string
  }

  export type PlaceFavoriteCreateOrConnectWithoutUserInput = {
    where: PlaceFavoriteWhereUniqueInput
    create: XOR<PlaceFavoriteCreateWithoutUserInput, PlaceFavoriteUncheckedCreateWithoutUserInput>
  }

  export type PlaceFavoriteCreateManyUserInputEnvelope = {
    data: PlaceFavoriteCreateManyUserInput | PlaceFavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSportCreateWithoutUserInput = {
    createdAt?: Date | string
    sport: SportCreateNestedOneWithoutUsersInput
  }

  export type UserSportUncheckedCreateWithoutUserInput = {
    createdAt?: Date | string
    sportId: string
  }

  export type UserSportCreateOrConnectWithoutUserInput = {
    where: UserSportWhereUniqueInput
    create: XOR<UserSportCreateWithoutUserInput, UserSportUncheckedCreateWithoutUserInput>
  }

  export type UserSportCreateManyUserInputEnvelope = {
    data: UserSportCreateManyUserInput | UserSportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFavoriteCreateWithoutUserInput = {
    createdAt?: Date | string
    favorite: UserCreateNestedOneWithoutFavoritedByInput
  }

  export type UserFavoriteUncheckedCreateWithoutUserInput = {
    favoriteId: string
    createdAt?: Date | string
  }

  export type UserFavoriteCreateOrConnectWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    create: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput>
  }

  export type UserFavoriteCreateManyUserInputEnvelope = {
    data: UserFavoriteCreateManyUserInput | UserFavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFavoriteCreateWithoutFavoriteInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
  }

  export type UserFavoriteUncheckedCreateWithoutFavoriteInput = {
    userId: string
    createdAt?: Date | string
  }

  export type UserFavoriteCreateOrConnectWithoutFavoriteInput = {
    where: UserFavoriteWhereUniqueInput
    create: XOR<UserFavoriteCreateWithoutFavoriteInput, UserFavoriteUncheckedCreateWithoutFavoriteInput>
  }

  export type UserFavoriteCreateManyFavoriteInputEnvelope = {
    data: UserFavoriteCreateManyFavoriteInput | UserFavoriteCreateManyFavoriteInput[]
    skipDuplicates?: boolean
  }

  export type GameUserUpsertWithWhereUniqueWithoutUserInput = {
    where: GameUserWhereUniqueInput
    update: XOR<GameUserUpdateWithoutUserInput, GameUserUncheckedUpdateWithoutUserInput>
    create: XOR<GameUserCreateWithoutUserInput, GameUserUncheckedCreateWithoutUserInput>
  }

  export type GameUserUpdateWithWhereUniqueWithoutUserInput = {
    where: GameUserWhereUniqueInput
    data: XOR<GameUserUpdateWithoutUserInput, GameUserUncheckedUpdateWithoutUserInput>
  }

  export type GameUserUpdateManyWithWhereWithoutUserInput = {
    where: GameUserScalarWhereInput
    data: XOR<GameUserUpdateManyMutationInput, GameUserUncheckedUpdateManyWithoutUserInput>
  }

  export type PlaceUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PlaceWhereUniqueInput
    update: XOR<PlaceUpdateWithoutOwnerInput, PlaceUncheckedUpdateWithoutOwnerInput>
    create: XOR<PlaceCreateWithoutOwnerInput, PlaceUncheckedCreateWithoutOwnerInput>
  }

  export type PlaceUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PlaceWhereUniqueInput
    data: XOR<PlaceUpdateWithoutOwnerInput, PlaceUncheckedUpdateWithoutOwnerInput>
  }

  export type PlaceUpdateManyWithWhereWithoutOwnerInput = {
    where: PlaceScalarWhereInput
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyWithoutOwnerInput>
  }

  export type PlaceFavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: PlaceFavoriteWhereUniqueInput
    update: XOR<PlaceFavoriteUpdateWithoutUserInput, PlaceFavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<PlaceFavoriteCreateWithoutUserInput, PlaceFavoriteUncheckedCreateWithoutUserInput>
  }

  export type PlaceFavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: PlaceFavoriteWhereUniqueInput
    data: XOR<PlaceFavoriteUpdateWithoutUserInput, PlaceFavoriteUncheckedUpdateWithoutUserInput>
  }

  export type PlaceFavoriteUpdateManyWithWhereWithoutUserInput = {
    where: PlaceFavoriteScalarWhereInput
    data: XOR<PlaceFavoriteUpdateManyMutationInput, PlaceFavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSportUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSportWhereUniqueInput
    update: XOR<UserSportUpdateWithoutUserInput, UserSportUncheckedUpdateWithoutUserInput>
    create: XOR<UserSportCreateWithoutUserInput, UserSportUncheckedCreateWithoutUserInput>
  }

  export type UserSportUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSportWhereUniqueInput
    data: XOR<UserSportUpdateWithoutUserInput, UserSportUncheckedUpdateWithoutUserInput>
  }

  export type UserSportUpdateManyWithWhereWithoutUserInput = {
    where: UserSportScalarWhereInput
    data: XOR<UserSportUpdateManyMutationInput, UserSportUncheckedUpdateManyWithoutUserInput>
  }

  export type UserFavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    update: XOR<UserFavoriteUpdateWithoutUserInput, UserFavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<UserFavoriteCreateWithoutUserInput, UserFavoriteUncheckedCreateWithoutUserInput>
  }

  export type UserFavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFavoriteWhereUniqueInput
    data: XOR<UserFavoriteUpdateWithoutUserInput, UserFavoriteUncheckedUpdateWithoutUserInput>
  }

  export type UserFavoriteUpdateManyWithWhereWithoutUserInput = {
    where: UserFavoriteScalarWhereInput
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type UserFavoriteScalarWhereInput = {
    AND?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
    OR?: UserFavoriteScalarWhereInput[]
    NOT?: UserFavoriteScalarWhereInput | UserFavoriteScalarWhereInput[]
    userId?: StringFilter<"UserFavorite"> | string
    favoriteId?: StringFilter<"UserFavorite"> | string
    createdAt?: DateTimeFilter<"UserFavorite"> | Date | string
  }

  export type UserFavoriteUpsertWithWhereUniqueWithoutFavoriteInput = {
    where: UserFavoriteWhereUniqueInput
    update: XOR<UserFavoriteUpdateWithoutFavoriteInput, UserFavoriteUncheckedUpdateWithoutFavoriteInput>
    create: XOR<UserFavoriteCreateWithoutFavoriteInput, UserFavoriteUncheckedCreateWithoutFavoriteInput>
  }

  export type UserFavoriteUpdateWithWhereUniqueWithoutFavoriteInput = {
    where: UserFavoriteWhereUniqueInput
    data: XOR<UserFavoriteUpdateWithoutFavoriteInput, UserFavoriteUncheckedUpdateWithoutFavoriteInput>
  }

  export type UserFavoriteUpdateManyWithWhereWithoutFavoriteInput = {
    where: UserFavoriteScalarWhereInput
    data: XOR<UserFavoriteUpdateManyMutationInput, UserFavoriteUncheckedUpdateManyWithoutFavoriteInput>
  }

  export type UserCreateWithoutFavoritesInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
    games?: GameUserCreateNestedManyWithoutUserInput
    places?: PlaceCreateNestedManyWithoutOwnerInput
    favoritePlaces?: PlaceFavoriteCreateNestedManyWithoutUserInput
    sports?: UserSportCreateNestedManyWithoutUserInput
    favoritedBy?: UserFavoriteCreateNestedManyWithoutFavoriteInput
  }

  export type UserUncheckedCreateWithoutFavoritesInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
    games?: GameUserUncheckedCreateNestedManyWithoutUserInput
    places?: PlaceUncheckedCreateNestedManyWithoutOwnerInput
    favoritePlaces?: PlaceFavoriteUncheckedCreateNestedManyWithoutUserInput
    sports?: UserSportUncheckedCreateNestedManyWithoutUserInput
    favoritedBy?: UserFavoriteUncheckedCreateNestedManyWithoutFavoriteInput
  }

  export type UserCreateOrConnectWithoutFavoritesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
  }

  export type UserCreateWithoutFavoritedByInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
    games?: GameUserCreateNestedManyWithoutUserInput
    places?: PlaceCreateNestedManyWithoutOwnerInput
    favoritePlaces?: PlaceFavoriteCreateNestedManyWithoutUserInput
    sports?: UserSportCreateNestedManyWithoutUserInput
    favorites?: UserFavoriteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFavoritedByInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
    games?: GameUserUncheckedCreateNestedManyWithoutUserInput
    places?: PlaceUncheckedCreateNestedManyWithoutOwnerInput
    favoritePlaces?: PlaceFavoriteUncheckedCreateNestedManyWithoutUserInput
    sports?: UserSportUncheckedCreateNestedManyWithoutUserInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavoritedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoritedByInput, UserUncheckedCreateWithoutFavoritedByInput>
  }

  export type UserUpsertWithoutFavoritesInput = {
    update: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    games?: GameUserUpdateManyWithoutUserNestedInput
    places?: PlaceUpdateManyWithoutOwnerNestedInput
    favoritePlaces?: PlaceFavoriteUpdateManyWithoutUserNestedInput
    sports?: UserSportUpdateManyWithoutUserNestedInput
    favoritedBy?: UserFavoriteUpdateManyWithoutFavoriteNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    games?: GameUserUncheckedUpdateManyWithoutUserNestedInput
    places?: PlaceUncheckedUpdateManyWithoutOwnerNestedInput
    favoritePlaces?: PlaceFavoriteUncheckedUpdateManyWithoutUserNestedInput
    sports?: UserSportUncheckedUpdateManyWithoutUserNestedInput
    favoritedBy?: UserFavoriteUncheckedUpdateManyWithoutFavoriteNestedInput
  }

  export type UserUpsertWithoutFavoritedByInput = {
    update: XOR<UserUpdateWithoutFavoritedByInput, UserUncheckedUpdateWithoutFavoritedByInput>
    create: XOR<UserCreateWithoutFavoritedByInput, UserUncheckedCreateWithoutFavoritedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoritedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoritedByInput, UserUncheckedUpdateWithoutFavoritedByInput>
  }

  export type UserUpdateWithoutFavoritedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    games?: GameUserUpdateManyWithoutUserNestedInput
    places?: PlaceUpdateManyWithoutOwnerNestedInput
    favoritePlaces?: PlaceFavoriteUpdateManyWithoutUserNestedInput
    sports?: UserSportUpdateManyWithoutUserNestedInput
    favorites?: UserFavoriteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoritedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    games?: GameUserUncheckedUpdateManyWithoutUserNestedInput
    places?: PlaceUncheckedUpdateManyWithoutOwnerNestedInput
    favoritePlaces?: PlaceFavoriteUncheckedUpdateManyWithoutUserNestedInput
    sports?: UserSportUncheckedUpdateManyWithoutUserNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SportCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    places?: PlaceSportCreateNestedManyWithoutSportInput
    games?: GameCreateNestedManyWithoutSportInput
  }

  export type SportUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    places?: PlaceSportUncheckedCreateNestedManyWithoutSportInput
    games?: GameUncheckedCreateNestedManyWithoutSportInput
  }

  export type SportCreateOrConnectWithoutUsersInput = {
    where: SportWhereUniqueInput
    create: XOR<SportCreateWithoutUsersInput, SportUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutSportsInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
    games?: GameUserCreateNestedManyWithoutUserInput
    places?: PlaceCreateNestedManyWithoutOwnerInput
    favoritePlaces?: PlaceFavoriteCreateNestedManyWithoutUserInput
    favorites?: UserFavoriteCreateNestedManyWithoutUserInput
    favoritedBy?: UserFavoriteCreateNestedManyWithoutFavoriteInput
  }

  export type UserUncheckedCreateWithoutSportsInput = {
    id?: string
    idx?: number
    email?: string | null
    keycloakId: string
    telegramId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    username?: string | null
    avatar?: string | null
    games?: GameUserUncheckedCreateNestedManyWithoutUserInput
    places?: PlaceUncheckedCreateNestedManyWithoutOwnerInput
    favoritePlaces?: PlaceFavoriteUncheckedCreateNestedManyWithoutUserInput
    favorites?: UserFavoriteUncheckedCreateNestedManyWithoutUserInput
    favoritedBy?: UserFavoriteUncheckedCreateNestedManyWithoutFavoriteInput
  }

  export type UserCreateOrConnectWithoutSportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSportsInput, UserUncheckedCreateWithoutSportsInput>
  }

  export type SportUpsertWithoutUsersInput = {
    update: XOR<SportUpdateWithoutUsersInput, SportUncheckedUpdateWithoutUsersInput>
    create: XOR<SportCreateWithoutUsersInput, SportUncheckedCreateWithoutUsersInput>
    where?: SportWhereInput
  }

  export type SportUpdateToOneWithWhereWithoutUsersInput = {
    where?: SportWhereInput
    data: XOR<SportUpdateWithoutUsersInput, SportUncheckedUpdateWithoutUsersInput>
  }

  export type SportUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    places?: PlaceSportUpdateManyWithoutSportNestedInput
    games?: GameUpdateManyWithoutSportNestedInput
  }

  export type SportUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    places?: PlaceSportUncheckedUpdateManyWithoutSportNestedInput
    games?: GameUncheckedUpdateManyWithoutSportNestedInput
  }

  export type UserUpsertWithoutSportsInput = {
    update: XOR<UserUpdateWithoutSportsInput, UserUncheckedUpdateWithoutSportsInput>
    create: XOR<UserCreateWithoutSportsInput, UserUncheckedCreateWithoutSportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSportsInput, UserUncheckedUpdateWithoutSportsInput>
  }

  export type UserUpdateWithoutSportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    games?: GameUserUpdateManyWithoutUserNestedInput
    places?: PlaceUpdateManyWithoutOwnerNestedInput
    favoritePlaces?: PlaceFavoriteUpdateManyWithoutUserNestedInput
    favorites?: UserFavoriteUpdateManyWithoutUserNestedInput
    favoritedBy?: UserFavoriteUpdateManyWithoutFavoriteNestedInput
  }

  export type UserUncheckedUpdateWithoutSportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    idx?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    keycloakId?: StringFieldUpdateOperationsInput | string
    telegramId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    games?: GameUserUncheckedUpdateManyWithoutUserNestedInput
    places?: PlaceUncheckedUpdateManyWithoutOwnerNestedInput
    favoritePlaces?: PlaceFavoriteUncheckedUpdateManyWithoutUserNestedInput
    favorites?: UserFavoriteUncheckedUpdateManyWithoutUserNestedInput
    favoritedBy?: UserFavoriteUncheckedUpdateManyWithoutFavoriteNestedInput
  }

  export type PlaceCreateManyCityInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    ownerId: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    latitude?: number
    longitude?: number
  }

  export type PlaceUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    owner?: UserUpdateOneRequiredWithoutPlacesNestedInput
    schedules?: ScheduleUpdateManyWithoutPlaceNestedInput
    games?: GameUpdateManyWithoutPlaceNestedInput
    covers?: PlaceCoversUpdateManyWithoutPlaceNestedInput
    sports?: PlaceSportUpdateManyWithoutPlaceNestedInput
    favoritedUsers?: PlaceFavoriteUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    schedules?: ScheduleUncheckedUpdateManyWithoutPlaceNestedInput
    games?: GameUncheckedUpdateManyWithoutPlaceNestedInput
    covers?: PlaceCoversUncheckedUpdateManyWithoutPlaceNestedInput
    sports?: PlaceSportUncheckedUpdateManyWithoutPlaceNestedInput
    favoritedUsers?: PlaceFavoriteUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type GameUserCreateManyGameInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    role: $Enums.GameUserRole
    status: $Enums.GameUserStatus
  }

  export type GameUserUpdateWithoutGameInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumGameUserRoleFieldUpdateOperationsInput | $Enums.GameUserRole
    status?: EnumGameUserStatusFieldUpdateOperationsInput | $Enums.GameUserStatus
    user?: UserUpdateOneRequiredWithoutGamesNestedInput
  }

  export type GameUserUncheckedUpdateWithoutGameInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGameUserRoleFieldUpdateOperationsInput | $Enums.GameUserRole
    status?: EnumGameUserStatusFieldUpdateOperationsInput | $Enums.GameUserStatus
  }

  export type GameUserUncheckedUpdateManyWithoutGameInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGameUserRoleFieldUpdateOperationsInput | $Enums.GameUserRole
    status?: EnumGameUserStatusFieldUpdateOperationsInput | $Enums.GameUserStatus
  }

  export type ScheduleCreateManyPlaceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    startDate?: Date | string | null
    stopDate?: Date | string | null
    name?: string
    repeatMode?: $Enums.CalendarRepeatMode
    repeatStep?: number
    m1?: boolean | null
    m2?: boolean | null
    m3?: boolean | null
    m4?: boolean | null
    m5?: boolean | null
    m6?: boolean | null
    m7?: boolean | null
    m8?: boolean | null
    m9?: boolean | null
    m10?: boolean | null
    m11?: boolean | null
    m12?: boolean | null
    w1?: boolean | null
    w2?: boolean | null
    w3?: boolean | null
    w4?: boolean | null
    wLast?: boolean | null
    wd1?: boolean | null
    wd2?: boolean | null
    wd3?: boolean | null
    wd4?: boolean | null
    wd5?: boolean | null
    wd6?: boolean | null
    wd7?: boolean | null
    d1?: boolean | null
    d2?: boolean | null
    d3?: boolean | null
    d4?: boolean | null
    d5?: boolean | null
    d6?: boolean | null
    d7?: boolean | null
    d8?: boolean | null
    d9?: boolean | null
    d10?: boolean | null
    d11?: boolean | null
    d12?: boolean | null
    d13?: boolean | null
    d14?: boolean | null
    d15?: boolean | null
    d16?: boolean | null
    d17?: boolean | null
    d18?: boolean | null
    d19?: boolean | null
    d20?: boolean | null
    d21?: boolean | null
    d22?: boolean | null
    d23?: boolean | null
    d24?: boolean | null
    d25?: boolean | null
    d26?: boolean | null
    d27?: boolean | null
    d28?: boolean | null
    d29?: boolean | null
    d30?: boolean | null
    d31?: boolean | null
    dLast?: boolean | null
    workTimeMode?: $Enums.WorkTimeMode
    minDurationHours?: number
    minDurationMinutes?: number
    maxDurationHours?: number
    maxDurationMinutes?: number
    timeStart?: number
    rank?: number
    status?: $Enums.ScheduleStatus
  }

  export type GameCreateManyPlaceInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
    date: Date | string
    status?: $Enums.GameStatus
    level?: $Enums.GameLevel
    countMembersMin?: number
    countMembersMax?: number
    description?: string | null
    requestMode?: $Enums.RequestMode
    sportId?: string | null
  }

  export type PlaceCoversCreateManyPlaceInput = {
    id?: string
    order?: number
    createdAt?: Date | string
  }

  export type PlaceSportCreateManyPlaceInput = {
    createdAt?: Date | string
    sportId: string
  }

  export type PlaceFavoriteCreateManyPlaceInput = {
    createdAt?: Date | string
    userId: string
  }

  export type ScheduleUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    repeatMode?: EnumCalendarRepeatModeFieldUpdateOperationsInput | $Enums.CalendarRepeatMode
    repeatStep?: IntFieldUpdateOperationsInput | number
    m1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d13?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d14?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d15?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d16?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d17?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d18?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d19?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d20?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d21?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d22?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d23?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d24?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d25?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d26?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d27?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d28?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d29?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d31?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workTimeMode?: EnumWorkTimeModeFieldUpdateOperationsInput | $Enums.WorkTimeMode
    minDurationHours?: IntFieldUpdateOperationsInput | number
    minDurationMinutes?: IntFieldUpdateOperationsInput | number
    maxDurationHours?: IntFieldUpdateOperationsInput | number
    maxDurationMinutes?: IntFieldUpdateOperationsInput | number
    timeStart?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    timeSlots?: TimeSlotUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    repeatMode?: EnumCalendarRepeatModeFieldUpdateOperationsInput | $Enums.CalendarRepeatMode
    repeatStep?: IntFieldUpdateOperationsInput | number
    m1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d13?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d14?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d15?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d16?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d17?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d18?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d19?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d20?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d21?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d22?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d23?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d24?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d25?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d26?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d27?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d28?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d29?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d31?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workTimeMode?: EnumWorkTimeModeFieldUpdateOperationsInput | $Enums.WorkTimeMode
    minDurationHours?: IntFieldUpdateOperationsInput | number
    minDurationMinutes?: IntFieldUpdateOperationsInput | number
    maxDurationHours?: IntFieldUpdateOperationsInput | number
    maxDurationMinutes?: IntFieldUpdateOperationsInput | number
    timeStart?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    timeSlots?: TimeSlotUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateManyWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stopDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: StringFieldUpdateOperationsInput | string
    repeatMode?: EnumCalendarRepeatModeFieldUpdateOperationsInput | $Enums.CalendarRepeatMode
    repeatStep?: IntFieldUpdateOperationsInput | number
    m1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    m12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    w4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wd7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d1?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d2?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d3?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d4?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d5?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d6?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d7?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d8?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d9?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d10?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d11?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d12?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d13?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d14?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d15?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d16?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d17?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d18?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d19?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d20?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d21?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d22?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d23?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d24?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d25?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d26?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d27?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d28?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d29?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d30?: NullableBoolFieldUpdateOperationsInput | boolean | null
    d31?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dLast?: NullableBoolFieldUpdateOperationsInput | boolean | null
    workTimeMode?: EnumWorkTimeModeFieldUpdateOperationsInput | $Enums.WorkTimeMode
    minDurationHours?: IntFieldUpdateOperationsInput | number
    minDurationMinutes?: IntFieldUpdateOperationsInput | number
    maxDurationHours?: IntFieldUpdateOperationsInput | number
    maxDurationMinutes?: IntFieldUpdateOperationsInput | number
    timeStart?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
  }

  export type GameUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    level?: EnumGameLevelFieldUpdateOperationsInput | $Enums.GameLevel
    countMembersMin?: IntFieldUpdateOperationsInput | number
    countMembersMax?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requestMode?: EnumRequestModeFieldUpdateOperationsInput | $Enums.RequestMode
    users?: GameUserUpdateManyWithoutGameNestedInput
    sport?: SportUpdateOneWithoutGamesNestedInput
  }

  export type GameUncheckedUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    level?: EnumGameLevelFieldUpdateOperationsInput | $Enums.GameLevel
    countMembersMin?: IntFieldUpdateOperationsInput | number
    countMembersMax?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requestMode?: EnumRequestModeFieldUpdateOperationsInput | $Enums.RequestMode
    sportId?: NullableStringFieldUpdateOperationsInput | string | null
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    level?: EnumGameLevelFieldUpdateOperationsInput | $Enums.GameLevel
    countMembersMin?: IntFieldUpdateOperationsInput | number
    countMembersMax?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requestMode?: EnumRequestModeFieldUpdateOperationsInput | $Enums.RequestMode
    sportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaceCoversUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceCoversUncheckedUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceCoversUncheckedUpdateManyWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceSportUpdateWithoutPlaceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: SportUpdateOneRequiredWithoutPlacesNestedInput
  }

  export type PlaceSportUncheckedUpdateWithoutPlaceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sportId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaceSportUncheckedUpdateManyWithoutPlaceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sportId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaceFavoriteUpdateWithoutPlaceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritePlacesNestedInput
  }

  export type PlaceFavoriteUncheckedUpdateWithoutPlaceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaceFavoriteUncheckedUpdateManyWithoutPlaceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TimeSlotCreateManyScheduleInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
  }

  export type TimeSlotUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
  }

  export type TimeSlotUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
  }

  export type TimeSlotUncheckedUpdateManyWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
  }

  export type PlaceSportCreateManySportInput = {
    createdAt?: Date | string
    placeId: string
  }

  export type GameCreateManySportInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    timeStart?: number
    timeEnd?: number
    date: Date | string
    status?: $Enums.GameStatus
    level?: $Enums.GameLevel
    countMembersMin?: number
    countMembersMax?: number
    description?: string | null
    requestMode?: $Enums.RequestMode
    placeId: string
  }

  export type UserSportCreateManySportInput = {
    createdAt?: Date | string
    userId: string
  }

  export type PlaceSportUpdateWithoutSportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: PlaceUpdateOneRequiredWithoutSportsNestedInput
  }

  export type PlaceSportUncheckedUpdateWithoutSportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    placeId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaceSportUncheckedUpdateManyWithoutSportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    placeId?: StringFieldUpdateOperationsInput | string
  }

  export type GameUpdateWithoutSportInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    level?: EnumGameLevelFieldUpdateOperationsInput | $Enums.GameLevel
    countMembersMin?: IntFieldUpdateOperationsInput | number
    countMembersMax?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requestMode?: EnumRequestModeFieldUpdateOperationsInput | $Enums.RequestMode
    place?: PlaceUpdateOneRequiredWithoutGamesNestedInput
    users?: GameUserUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateWithoutSportInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    level?: EnumGameLevelFieldUpdateOperationsInput | $Enums.GameLevel
    countMembersMin?: IntFieldUpdateOperationsInput | number
    countMembersMax?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requestMode?: EnumRequestModeFieldUpdateOperationsInput | $Enums.RequestMode
    placeId?: StringFieldUpdateOperationsInput | string
    users?: GameUserUncheckedUpdateManyWithoutGameNestedInput
  }

  export type GameUncheckedUpdateManyWithoutSportInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeStart?: IntFieldUpdateOperationsInput | number
    timeEnd?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumGameStatusFieldUpdateOperationsInput | $Enums.GameStatus
    level?: EnumGameLevelFieldUpdateOperationsInput | $Enums.GameLevel
    countMembersMin?: IntFieldUpdateOperationsInput | number
    countMembersMax?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    requestMode?: EnumRequestModeFieldUpdateOperationsInput | $Enums.RequestMode
    placeId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSportUpdateWithoutSportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSportsNestedInput
  }

  export type UserSportUncheckedUpdateWithoutSportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSportUncheckedUpdateManyWithoutSportInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type GameUserCreateManyUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    gameId: string
    role: $Enums.GameUserRole
    status: $Enums.GameUserStatus
  }

  export type PlaceCreateManyOwnerInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string
    isIndoor?: boolean | null
    isFree?: boolean | null
    cityId: string
    latitude?: number
    longitude?: number
  }

  export type PlaceFavoriteCreateManyUserInput = {
    createdAt?: Date | string
    placeId: string
  }

  export type UserSportCreateManyUserInput = {
    createdAt?: Date | string
    sportId: string
  }

  export type UserFavoriteCreateManyUserInput = {
    favoriteId: string
    createdAt?: Date | string
  }

  export type UserFavoriteCreateManyFavoriteInput = {
    userId: string
    createdAt?: Date | string
  }

  export type GameUserUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumGameUserRoleFieldUpdateOperationsInput | $Enums.GameUserRole
    status?: EnumGameUserStatusFieldUpdateOperationsInput | $Enums.GameUserStatus
    game?: GameUpdateOneRequiredWithoutUsersNestedInput
  }

  export type GameUserUncheckedUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: StringFieldUpdateOperationsInput | string
    role?: EnumGameUserRoleFieldUpdateOperationsInput | $Enums.GameUserRole
    status?: EnumGameUserStatusFieldUpdateOperationsInput | $Enums.GameUserStatus
  }

  export type GameUserUncheckedUpdateManyWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gameId?: StringFieldUpdateOperationsInput | string
    role?: EnumGameUserRoleFieldUpdateOperationsInput | $Enums.GameUserRole
    status?: EnumGameUserStatusFieldUpdateOperationsInput | $Enums.GameUserStatus
  }

  export type PlaceUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    schedules?: ScheduleUpdateManyWithoutPlaceNestedInput
    games?: GameUpdateManyWithoutPlaceNestedInput
    covers?: PlaceCoversUpdateManyWithoutPlaceNestedInput
    sports?: PlaceSportUpdateManyWithoutPlaceNestedInput
    favoritedUsers?: PlaceFavoriteUpdateManyWithoutPlaceNestedInput
    city?: CityUpdateOneRequiredWithoutPlacesNestedInput
  }

  export type PlaceUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    schedules?: ScheduleUncheckedUpdateManyWithoutPlaceNestedInput
    games?: GameUncheckedUpdateManyWithoutPlaceNestedInput
    covers?: PlaceCoversUncheckedUpdateManyWithoutPlaceNestedInput
    sports?: PlaceSportUncheckedUpdateManyWithoutPlaceNestedInput
    favoritedUsers?: PlaceFavoriteUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isIndoor?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isFree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cityId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type PlaceFavoriteUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    place?: PlaceUpdateOneRequiredWithoutFavoritedUsersNestedInput
  }

  export type PlaceFavoriteUncheckedUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    placeId?: StringFieldUpdateOperationsInput | string
  }

  export type PlaceFavoriteUncheckedUpdateManyWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    placeId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSportUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sport?: SportUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserSportUncheckedUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sportId?: StringFieldUpdateOperationsInput | string
  }

  export type UserSportUncheckedUpdateManyWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sportId?: StringFieldUpdateOperationsInput | string
  }

  export type UserFavoriteUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favorite?: UserUpdateOneRequiredWithoutFavoritedByNestedInput
  }

  export type UserFavoriteUncheckedUpdateWithoutUserInput = {
    favoriteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyWithoutUserInput = {
    favoriteId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUpdateWithoutFavoriteInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type UserFavoriteUncheckedUpdateWithoutFavoriteInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFavoriteUncheckedUpdateManyWithoutFavoriteInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}